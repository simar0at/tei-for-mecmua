<?xml version="1.0" encoding="utf-8"?>
<!--
Copyright TEI Consortium. 
Licensed under the GNU General Public License. 
See the file COPYING for details.
$Date$
$Id$
-->
<div xmlns="http://www.tei-c.org/ns/1.0" type="div1" xml:id="MD">

<head>Personalization and Customization</head>

<p xmlns="http://www.tei-c.org/ns/1.0">These Guidelines provide an
encoding scheme suitable for encoding a very wide range of texts, and
capable of supporting a wide variety of applications. For this reason,
the TEI scheme supports a variety of different approaches to solving
similar problems, and also defines a much richer set of elements than
is likely to be necessary in any given project.  Furthermore, the TEI
scheme may be extended in well-defined and documented ways for texts
that cannot be conveniently or appropriately encoded using what is
provided.  For these reasons, it is almost impossible to use the TEI
scheme without customizing or personalizing it in some way. </p>

<p>This chapter describes how the TEI encoding scheme may be
customized, and should be read in conjunction with chapter <ptr
target="#TD"/>, which describes how a specific application of the TEI
encoding scheme should be documented.  The documentation system
described in that chapter is, like the rest of the TEI scheme,
independent of any particular schema or document type definition
language. </p>

<p>Formally speaking, these Guidelines provide both syntactic rules
about how elements and attributes may be used in valid documents and
semantic recommendations about what interpretation should be attached
to a given syntactic construct. In this sense, they provide both a
<term>document type definition</term> and a <term>document type
declaration</term>. More exactly, we may distinguish between the
<term>TEI abstract model</term>, which defines a set of related
concepts, and the <term>TEI schema</term> which defines a set of
syntactic rules and constraints. Many (though not all) of the semantic
recommendations are provided solely as informal descriptive prose,
though some of them are also enforced by means of such constructs as
datatypes (see <ptr target="#DTYPES"/>). Although the descriptions
have been written with care, there will inevitably be cases where the
intention of the contributors has not been conveyed with sufficient
clarity to prevent users of the Guidelines from
<soCalled>extending</soCalled> them in the sense of attaching slightly
variant semantics to them. </p>

<p>Beyond this unintentional semantic extension, some of the elements
described can intentionally be used in a variety of ways; for example,
the element <gi>note</gi> has an attribute <att>type</att> which can
take on arbitrary string values, depending on how it is used in a
document.  A new type of <q>note</q>, therefore, requires no change in
the existing model. On the other hand, for some application, it may be
desired to constrain the possible values for the <att>type</att>
attribute to a small set of possibilities. A schema modified in this
way would no longer necessarily regard as valid the same set of
documents as the corresponding unmodified TEI schema, but would remain
faithful to the same conceptual model.</p>

<!--

<p>Furthermore, there are several ways for combining and extending the
existing syntactic mechanisms themselves.  Earlier chapters have
identified these amongst others:
<list type="bullets">
<item>selecting from and combining the supplied modules as described in chapter <ptr target="#ST"/>; </item>
<item>documenting how non-standard characters are represented  in
a document by providing extensions to the Unicode character
definitions, as
described in chapter <ptr target="#WD"/>;</item>
<item>extending the intentionally open-ended feature structure mechanism
by providing one or more feature system declarations, as described in
chapter <ptr target="#FD"/>.</item></list>
</p>
-->

<p>This section explains how the TEI scheme can be customized by
suppressing elements, modifying classes of elements, adding elements,
and renaming elements.  Documents which validate against an
application of the TEI scheme which has been customized in this way
may or may not be considered <soCalled>TEI conformant</soCalled>, as
further discussed in section <ptr target="#CF"/>.</p>

<p>The TEI scheme is designed to support modification and
customization in a documented way that can be validated by an XML
processor. This is achieved by writing a small TEI-conformant
document, from which an appropriate processor can generate both
human-readable documentation, and a schema expressed in a language
such as RELAX NG or DTD.  The mechanisms used to instantiate a TEI
schema differ for different schema languages, and are therefore not
defined here. In XML DTDs, for example, extensive use is made of
parameter entities, while in RELAX NG schemas, extensive use is made
of patterns. In either case, the names of elements and, wherever
possible, their attributes and content models are defined
indirectly. The syntax used to implement this indirection also varies
with the schema language used, but the underlying constructs in the
TEI abstract model are given the same names. </p>

<p>As further discussed in section <ptr target="#ST"/>, the TEI
encoding scheme comprises a set of class and macro declarations, and a
number of <term>modules</term>. Each module is made up of 
element and attribute declarations, and a schema is made by combining
a particular set of modules together. In the absence of any other kind
of personalization, when modules are combined together:
<list type="ordered">
<item>all the elements defined by the module (and described in the corresponding section of these
  Guidelines) are included in the schema;</item>
<item>each such element is identified by the canonical name given it in  these Guidelines;</item>
<item>the content model of each such element is as defined by these Guidelines;</item>
<item>the names,  datatypes, and permitted values declared for each
attribute associated with each such element are as given in these Guidelines;</item>
<item>the elements comprising  element classes and the meaning of macro
declarations expressed in terms of element classes is determined by
the particular combination of modules selected.</item></list> The
TEI personalization mechanisms allow the user
to control this behaviour as follows:
<list type="ordered">
<item>particular elements may be suppressed, removing them from any
classes in which they are members, and also from any generated schema;
</item>
<item>within certain limits, the name (generic identifier) associated with an element may
      be changed, without changing the semantic or syntactic
properties  of the element;</item>
<item>new elements may be added to an existing class, thus making them
available in macros or  content models defined in terms of those classes;</item>
<item>additional  attributes, or attribute values, may be
      specified for an individual element or for classes of
      elements; </item>
<item>within certain limits, attributes, or attribute values, may also be
      removed either from an individual element or for classes of
      elements; </item>
<item>the characteristics inherited by one class from another class
may be modified by modifying its class membership: all members of the
class then   inherit the changed characteristics;</item>
<item>the set of values legal for an attribute or attribute class may
be constrained or relaxed by supplying or modifying a value list, or
by modifying its datatype.</item> </list>

The modification mechanisms presented in this chapter are quite general,
and may be used to make all the types of changes just listed.  
</p>

<p>The recommended way of implementing and documenting all such modifications is by
means of the ODD system described in chapter <ptr target="#TD"/>; in
the remainder of this section we give specific examples to illustrate
how that system may be applied. An ODD processor, such as the Roma
application supported by the TEI, or any other comparable set of
stylesheets will use the declarations provided by an ODD to generate
appropriate sets of declarations in a specific schema language such as
RELAX NG or the XML DTD language.  We do not discuss in detail here how
this should be done, since the details are schema language-specific;
some background information about the methods used for XML DTD and
RELAX NG schema generation is however provided in section <ptr
target="#STIN"/>.  Several example ODD files are also provided as
part of the standard TEI  release: see further section <ptr
target="#MDlite"/> below.</p>

<div type="div2" xml:id="MDMD"><head>Kinds of Modification</head>
<p>For ease of discussion, we distinguish the following different kind of
modification:
<list type="ordered">
<item>deletion of elements;</item><!-- <ptr target="#MDMDSU"/>-->
<item>renaming of elements;</item><!-- <ptr target="#MDMDNM"/>-->
<item>modification of content models;</item> <!-- <ptr target="#MDMDCM"/>-->
<item>modification of attribute and attribute-value lists;</item> <!-- <ptr target="#MDMDAT"/>-->
<item>modification of class membership;</item> <!-- <ptr target="#MDMDCL"/>-->
<item>addition of new elements.</item></list>  <!-- <ptr target="#MDMDNE"/>-->
Each of these is described in the following  sections.</p>

<p>Each kind of modification changes the set of documents that will be
considered valid according to the resulting schema. Any combination of
unchanged TEI modules may be thought of as defining a certain set of
documents. Each schema resulting from a modified combination of TEI
modules will define a different set of documents.  The set of
documents valid according to the unmodified schema may or may not be
properly contained in the set of documents considered to be valid
according to the modified schema.  We use the term <term>clean
modification</term> to describe a modification which regards as valid
a subset of the documents considered valid by the same combination of
TEI modules unmodified. Alternatively, the set of documents considered
valid by the original schema might be disjoint from the set of
documents considered valid by the modified schema, with neither being
properly contained by the other.  Modifications that have this result
are called <term>unclean modifications</term>. Despite this
terminology, unclean modifications are not particularly deprecated,
and their use may often be vital to the success of a project. The
concept is introduced solely to distinguish  the effects of different
kinds of modification.</p>
<p>Cleanliness can only be assessed with reference to elements in the
TEI namespace. </p>


<!--It is
however essential to the successful interchange of documents that such
modifications be clearly distinguished from clean modifications of the
TEI. For this reason, amongst others, elements which have been
modified in this way should generally be placed in a non-TEI
namespace, as further discussed in <ptr target="#MDNS"/>. </p>-->

<div type="div3" xml:id="MDMDSU"><head>Deletion of Elements</head>

<p>The simplest way to modify the supplied modules is to suppress one
or more of the supplied elements.  This is simply done by setting the
attribute <att>mode</att> to <val>delete</val> on an
<gi>elementSpec</gi> for the element concerned.
</p>

<p>For example, if the <gi>note</gi>
element is not to be used in a particular application, the schema
specification concerned will contain a declaration like the following:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><elementSpec ident="note"
						    module="core" mode="delete"/></egXML>

The <att>ident</att> attribute here supplies the canonical name of the
element to be deleted, the <att>module</att> attribute identifies the
module in which this element is declared, and the <att>mode</att>
attribute specifies what is to be done with it. Note that the module
name must be supplied explicitly, and that the schema specification in
which this declaration appears must also contain a reference to the
module itself. The full specification for a schema in which this
modification is applied would thus be
something like the following:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><schemaSpec ident="mySchema">
  <moduleRef key="core"/>
  <!-- other modules used by this schema -->
  <elementSpec ident="note" module="core" mode="delete"/>
</schemaSpec></egXML>
</p>

<p>In most cases, deletion is a clean modification, since most
elements are optional. Documents that are valid with respect to the
modified schema are also valid according to the unmodified schema.  To
say this another way, the set of documents matching the new schema is
contained by the set of documents matching the original schema.</p>

<p>If however the element deleted by some modification is mandatory
within the content model of some other (undeleted) element, the result
is an unclean modification because some documents that would be
regarded as valid by the new schema would be regarded as invalid
according to the original schema.  If an element is defined as having
some other specific element as a mandatory child, removing that child
would break the TEI abstract model (<ptr target="#CFAM"/>), though the
parent of a mandatory child can of course be removed safely if it is
itself optional.</p>

</div>


<div type="div3" xml:id="MDMDNM"><head>Renaming of Elements</head>

<p>Every element and other named markup construct in the TEI scheme
has a <term>canonical name</term>, usually in the English language:
this name is supplied as the value of the <att>ident</att> attribute
on the <gi>elementSpec</gi>, <gi>attDef</gi>, <gi>classSpec</gi>, or
<gi>macroSpec</gi> used to define it.  The element or attribute
declaration used within a schema generated from that specification may
however be different, thus permitting schemas to be written using
elements with generic identifiers from a different language, or
otherwise modified. There may be many alternative identifiers for the
same markup construct, and an ODD processor may choose which of them
to use for a given purpose. Each such alternative name is supplied by
means of an <gi>altIdent</gi> element within the specification element
concerned.</p>
<p>For example, the following declaration converts <gi>note</gi> to
<gi>annotation</gi>:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><elementSpec ident="note"
						    module="core"
						    mode="change">
<altIdent>annotation</altIdent></elementSpec></egXML>
Note that the <att>mode</att> attribute on the <gi>elementSpec</gi>
now takes the value <val>change</val> to indicate that those parts of
the element specification not supplied are to be inherited from the
standard definition. The content of the <gi>altIdent</gi> element will
be used in place of the canonical <att>ident</att> value in the schema
generated. 
</p>

<p>Renaming in this way is always a <term>reversible</term>
modification. Although it is an inherently unclean modification
(because the set of documents matched by the resulting schema is
disjoint with the set matched by its unmodified equivalent), the
process of converting any document in which elements have been renamed
into an exactly equivalent document using canonical names is
completely deterministic, requiring only access to the ODD in which
the renaming has been specified. This assumes that the renamed
elements used are not placed in the TEI namespace but either use a
null namespace or some user defined namespace, as further discussed in
<ptr target="#MDNS"/>; if this is not the case, care must be taken to
avoid name collision between the new name and all existing TEI
names. Furthermore, unclean modifications which do not specify a namespace are not
conformant (see further <ptr target="#MD"/>) </p>

<p>The TEI provides a systematic set of renamings into languages other
than English. These all use a language-specific namespace.</p>

<!--
<p>Two different cases of renaming can be identified.  The first case
involves replacing existing names with names that are otherwise unused
in the TEI scheme.  (This can be easily checked by looking in the
index of the Guidelines.)  Such a modification is clean in that the new
schema still accepts any document accepted by the unmodified schema
(given the appropriate renaming of elements).  The new name cannot
possibly conflict with the generic identifier of any other element,
since there can be no other occurrences.  To say this another way, the
set of documents matching the new schema is isomorphic to the set of
documents matching the old schema.  The example given results in a clean
modification because there is no element <gi>annotation</gi>
specified in these Guidelines.  It is also true that any document not
using the renamed element which is valid according to the unmodified schema will
also be valid according to the  modified schema.</p>

<p>The second case involves introducing a name already used somewhere
in a TEI module.  This is unclean in that it changes what an existing
generic identifier means.  The name in question could not be declared
by any module that is used in the new schema, as it is syntactically
invalid to provide two declarations for the same element.  The new
generic identifier might however occur in some TEI module not currently
included in the schema used to parse the document.  For example, if in
some setting the element <gi>note</gi> were assigned the new
name <gi>fs</gi> (because, say, notes are used in some
technical document to record functional specifications) there might be
no immediate problem.  If however it was later decided to add the
feature structure analysis module into the schema used to parse the
document,  a name clash would occur. There would also be
problems in interchanging the resulting documents without confusion.</p>

<p>As a special case, consider translating all of the generic
identifiers for all elements into some other language, L.  It may be,
for example, that the word for <q>paragraph</q> in language L begins
with the letter <q>s</q> and that thus the paragraph element is
renamed as <gi>s</gi>.  By the definition just given, this
would be an unclean modification because an element <gi>s</gi>
already exists in the TEI scheme.  However, this is clearly not a
problem so long as all of the names are redefined at once and that no
collisions occur in the new name space: that is, provided that the TEI
element <gi>s</gi> is also renamed as some other string. </p>
-->

</div>



<div type="div3" xml:id="MDMDCM"><head>Modification of Content Models</head>

<p>The content model for an element in the TEI scheme is defined by
means of a <gi>content</gi> element within the <gi>elementSpec</gi>
which specifies it. As shown elsewhere in these Guidelines, the
content model is defined using RELAX NG syntax, whether the
resulting schema is expressed in RELAX NG or in some other schema
language. </p> 

<p>For example, the specification for the element <gi>term</gi>
provided by the Guidelines contains a <gi>content</gi> element like
the following:

<egXML xmlns="http://www.tei-c.org/ns/Examples">
  <content xmlns:rng="http://relaxng.org/ns/structure/1.0">
    <rng:ref  name="macro.phraseSeq"/>
  </content>
</egXML>

This indicates that the content model contains declarations taken from
the RELAX NG namespace, and that it consists of a reference to a
pattern called <ident type="macro">macro.phraseSeq</ident>. Further
examination shows that this pattern in turn expands to an optional repeatable
alternation of text (<code>rng:text</code>) with references to three
other classes (<ident type="class">model.gLike</ident>, <ident
type="class">model.phrase</ident>, or <ident
type="class">model.global</ident>). For some particular application it
might be preferable to insist that <gi>term</gi> elements should only
contain plain text, excluding these other possibilities<note
place="foot">Excluding <ident type="class">model.gLike</ident> is
generally inadvisable however, since without it the resulting schema
has no way of referencing non-Unicode characters.</note> This could be
achieved simply by supplying a specification for <gi>term</gi> like
the following: <egXML rend="full"
xmlns="http://www.tei-c.org/ns/Examples"><elementSpec ident="term"
module="core" mode="change" > <content
xmlns:rng="http://relaxng.org/ns/structure/1.0"><rng:text/></content></elementSpec></egXML>
</p>

<p>This is a clean modification which does not change the meaning of a
TEI element; there is therefore no need to assign the element to some other namespace than
that of the TEI, though it may be considered good practice; see further <ptr target="#MDNS"/>
below. </p>
<p>A change of this kind, which simplifies the possible content of an
element by reducing its model to one of its existing components, is
always clean, because the set of documents matched by the resulting
schema is a subset of the set of documents which would have been
matched by the unmodified schema.</p>

<p>Note that content models are generally defined (as far as possible)
in terms of references to model classes, rather than to explicit
elements. This means that the need to modify content models is greatly
reduced: if an element is deleted or modified, for example, then the
deletion or modification will be available for every content model
which references that element via its class, as well as those which
reference it explicitly. For this reason it is not (in general) good
practice to replace class references by explicit element references,
since this may have unintended side effects.
</p>

<p>An unqualified reference to an element class within a content model
generates a content model which is equivalent to an alternation of all
the members of the class referenced. Thus, a content model which
refers to the model class <ident type="class">model.phrase</ident>
will generate a content model in which any one of the members of that
class is equally acceptable. It is also possible to reference
predefined content model fragments based on classes, such as <q>an
optional repeatable alternation of all members of a class</q>, <q>a sequence
containing no more than one of each member of the class</q>, etc. as
described further in <ptr target="#TDCLA"/>. </p>

<p>Content model changes which are not simple restrictions on an
existing model should be undertaken with caution. The set of documents
matching the schema which results from such changes is likely to be
disjoint with the set of documents matching the unmodified schema, and
such changes are therefore regarded as unclean. When content models
are changed or extended, care should be taken to respect the existing
semantics of the element concerned as stated in the Guidelines. For
example, the element <gi>l</gi> is defined as containing a line of
verse. It would not therefore make sense to redefine its content model
so that it could also include members of the class <ident
type="class">model.pLike</ident>: such a modification although
syntactically feasible would not be regarded as TEI conformant because
it breaks the TEI abstract model. </p>

</div>

 
<div xml:id="MDMDAL"><head>Modification of Attribute and Attribute
Value Lists</head>

<p>The attributes applicable to a given element may be specified in
two ways: they may be given explicitly, by means of an
<gi>attList</gi> element within the corresponding
<gi>elementSpec</gi>, or they may be inherited from an attribute
class, as specified in the <gi>classes</gi> element. To add a new
attribute to an element, the schema builder should therefore first
check to see whether this attribute is already defined by some
existing attribute class. If it is, then the simplest method of adding
it will be to make the element in question a member of that class, as
further discussed below. If this is not possible, then a new
<gi>attDef</gi> element must be added to the existing <gi>attList</gi>
for the element in question. </p>

<p>Whichever method is adopted, the  modification capabilities are the
same as those available for elements. Attributes may be added or
deleted from the list, using the <att>mode</att> attribute on
<gi>attdef</gi> in the same way as on <gi>elementSpec</gi>. The
<q>content</q> of an attribute is defined by means of its <gi>datatype</gi>
<gi>valList</gi> or <gi>valDesc</gi> elements,  which can also
be changed. </p>

<p>Suppose, for example, that we wish to add two attributes to the
<gi>eg</gi> element (used to indicate examples in a text),
<att>type</att> to characterize the example in some way, and
<gi>source</gi> to indicate where the example comes from. A quick
glance through the Guidelines indicates that the attribute class
<ident type="class">att.typed</ident> could be used to provide the
<att>type</att> attribute, but there is no comparable class which will
provide a <att>source</att> attribute. The existing <gi>eg</gi>
element in fact has no local attributes defined for it at all: we will
therefore need to add not only an <gi>attDef</gi> element to define
the new attribute, but also an <gi>attList</gi> to hold it. </p>
<p>We begin by  adding the new <att>source</att> attribute:
<egXML rend="full" xmlns="http://www.tei-c.org/ns/Examples"><elementSpec ident="eg"
module="tagdocs" mode="change" >
<attList>
<attDef ident="source" mode="add" ns="http://www.hatstand.org/ns">
<desc>specifies the source of an example by pointing to a
single bibliographic reference for it</desc>
<datatype maxOccurs="1"
	  xmlns:rng="http://relaxng.org/ns/structure/1.0">
  <rng:ref name="data.pointer"/>
</datatype>
</attDef></attList>
 </elementSpec></egXML>
</p>
<p>The value supplied for the <att>mode</att> attribute on the
<gi>attDef</gi> element is <val>add</val>; if this attribute already
existed on the element we are modifying this should generate an error,
since a specification cannot have more than one attribute of the same
name. If the attribute is already present, we can replace the whole of
the existing declaration by supplying <val>replace</val> as the value
for <att>mode</att>; alternatively, we can change some parts of an
existing declaration only by supplying just the new parts, and setting
<val>change</val> as the value for <att>mode</att>.</p>

<p>Because the new attribute is not defined by  the TEI,
we must specify a namespace for it on the <gi>attDef</gi>; see further <ptr
target="#MDNS"/>.</p>


<p>As noted above, adding the new <att>type</att> attribute involves
changing this element's class membership; we therefore discuss that in
the next section (<ptr target="#MDMDCM"/>).</p>

<p>The canonical name for the new attribute is <att>source</att>, and
is supplied on the <att>ident</att> attribute of the <gi>attDef</gi>
element. In this simple example, we supply only a description and
datatype for the new attribute; the former is given by the
<gi>desc</gi> element, and the latter by the <gi>datatype</gi>
element. (There are of course many other pieces of information which
could be supplied, as documented in <ptr target="#TD"/>). The content
of the <gi>datatype</gi> element, like that of the <gi>content</gi>
element, uses patterns from the RELAX NG namespace, in this case to select
one of the predefined TEI datatypes (<ptr target="#DTYPES"/>).
</p>

<p>It is often desirable to constrain the possible values for an
attribute to a greater extent than is possible by simply supplying a
TEI datatype for it. This facility is provided by the <gi>valList</gi>
element, which can also appear as a child of the <gi>attDef</gi>
element. Suppose for example that, rather than supplying them as
pointers to a bibliography, all that we wish to indicate about the
source of our examples is that each comes from one of three predefined
sources, which we call A, B, and C. A declaration like the following
might be appropriate:

<egXML rend="full" xmlns="http://www.tei-c.org/ns/Examples"><elementSpec ident="eg"
module="tagdocs" mode="change" >
<attList>
<attDef ident="source" ns="http://example.com/ns" mode="add">
<desc>specifies the source of an example by supplying one of three
predefined codes for it.</desc>
<datatype maxOccurs="1"
	  xmlns:rng="http://relaxng.org/ns/structure/1.0">
  <rng:ref name="data.word"/>
</datatype>
<valList type="closed">
<valItem ident="A">
  <desc>Examples taken from  the A-list</desc>
</valItem>
<valItem ident="B">
  <desc>Examples taken from  the B-list</desc>
</valItem>
<valItem ident="C">
  <desc>Examples taken from  the C-list</desc>
</valItem>
</valList>
</attDef></attList>
 </elementSpec></egXML>
</p>

<p>The same technique may be used to replace or extend the
<gi>valList</gi> supplied as part of any attribute in the TEI
scheme.</p>

<!-- following para uses diff meaning for clean acc. Birnbaum -->

<p>The set of documents matched by a schema generated from an ODD
modified in this way, and the set of documents matched by the
unmodified schema may be related in several different ways.  It is
certainly possible that the former could properly include the latter
or vice versa; either of these could be said to be clean modifications
because the set to be matched has become strictly larger or strictly
smaller. But it is more likely that such modifications will be
unclean. </p>

</div> 
<div type="div3" xml:id="MDMDCL"><head>Class Modification</head>

<p>The concept of element classes was
introduced in <ptr target="#STECCM"/>; an understanding of it is
fundamental to successful use of the TEI scheme. As noted there, we
distinguish <term>model classes</term>, the members of which all
have structural similarity, from <term>attribute classes</term>, the
members of which simply share a set of attributes. </p>
<p>The part of an element specification which determines its class
membership is an element called <gi>classes</gi>. All classes to which
the element belongs must be specified within this, using a
<gi>memberOf</gi> element for each. This implies that, when the class
membership of an element is changed, care must be taken to review and
(if appropriate) preserve its existing memberships.</p>
<p>For example, the <gi>eg</gi> element discussed in the previous
section is already a member of two classes (<ident
type="class">model.common</ident> and <ident
type="class">model.graphicLike</ident>). To add it to another class as
proposed above without also affecting its other class memberships,
these declarations must be preserved. The modification which adds a
<att>type</att> attribute to the <gi>element</gi> therefore looks like
this:
<egXML rend="full" xmlns="http://www.tei-c.org/ns/Examples"><elementSpec ident="eg"
module="tagdocs" mode="change" ns="http://example.com/ns">
  <classes>
    <memberOf key="model.common"/>
    <memberOf key="model.graphicLike"/>
    <memberOf key="att.typed"/>
  </classes>
</elementSpec></egXML>
</p>
<p>Equally, to remove the attributes which  an element
inherits from its membership in some class, all that is needed is to
remove the relevant <gi>memberOf</gi> element. For example, the
element <gi>term</gi> defined in the core module is a member of two
attribute classes, <ident type="class">att.typed</ident> and <ident
type="class">att.declaring</ident>. It inherits the attributes
<att>type</att> and <att>subtype</att> from the former, and the
attribute <att>declaring</att> from the latter. To remove the last of these
attributes from this element, we would supply a modification like the
following: <egXML rend="full"
xmlns="http://www.tei-c.org/ns/Examples"><elementSpec ident="term"
module="core" mode="change" ns="http://example.com/ns">
  <classes>
    <memberOf key="model.emphLike"/>
    <memberOf key="att.typed"/>
  </classes>
</elementSpec></egXML>
</p>
<p>To change or remove attributes inherited from an attribute class
for all members of the class (as opposed to specific members of that
class), it is also possible to  modify the class specification itself. For
example, the class <ident type="class">att.global</ident> defines
several attributes which are available for all elements, notably
<att>xml:id</att>, <att>n</att>, <att>rend</att> and others. If we decide
that we  never wish to use the <att>n</att> attribute, the simplest
way of removing it is to supply a modified class specification for
<ident type="class">att.global</ident> as follows: <egXML
xmlns="http://www.tei-c.org/ns/Examples"><classSpec ident="att.global"
type="atts" mode="change">
<attList>
<attDef ident="n" mode="delete"/>
</attList>
</classSpec>
</egXML>
Because the <att>mode</att> attribute on the <gi>classSpec</gi>
defining the attributes inherited through membership of this class has
the value <val>change</val>, any of its existing identifiable
components not specified in the modification above will remain
unchanged. The only effect will therefore be to delete the <att>n</att>
attribute from the class. This in turn will affect the attributes
inherited by all members of the class.</p>


<p>Full details of the classes used in the TEI scheme are provided in
chapter <ptr target="#ST"/>. Note in particular that classes are
themselves classified: the attributes inherited by a member of
attribute class A may come to it directly from that class, or from
another class of which A is itself a member. For example, the class
<ident type="class">att.global</ident> is itself a member of the
classes <ident type="class">att.global.linking</ident> and <ident
type="class">att.global.analytic</ident>.  By default, these two
classes are predefined as empty. However, if (for example) the <ident
type="module">linking</ident> module is included in a schema, a number
of attributes (<att>corresp</att>, <att>sameAs</att>, etc) are defined
as members of the <ident type="class">att.global.linking</ident>
class.  All elements which are members of <ident
type="class">att.global</ident> will then inherit these new attributes
(see further section <ptr target="#STECAT"/>). A new attribute may
thus be added to the global class in two ways: either by adding it to
the <gi>attList</gi> defined within the class specification for
att.global; or by defining a new attribute class, and changing the
class membership of the att.global class to reference it. </p>


<p>Such global changes should be undertaken with caution: in general
removing existing non-mandatory attributes from a class will always be
a clean modification, in the same way as removing non-mandatory
elements.  Adding a new attribute to a class however can be a
clean modification only if the new attribute is labelled as belonging
to some namespace other than the TEI.</p>

<p>The same mechanisms are available for modification of model
classes. Care should be taken when modifying the model class
membership of existing elements since model class membership is what
determines the content model of most elements in the TEI scheme, and a
small change may have unintended consequences.  <!-- Adding new members to
an existing model class (discussed in the next section) is however
usually a simple operation and is also a clean modification. --> </p>


</div> 


<div type="div3" xml:id="MDMDNE"><head>Addition of New Elements</head>

<p>To add  a completely new element into a schema involves providing a complete
element specification for it, the <gi>classes</gi> element of which
includes a reference to at least one TEI model class. Without such a
reference, the new element will not be referenced by the content model
of any other TEI element, and will therefore be inaccessible within a
TEI document. </p>

<p>For example, the three elements  <gi>bibl</gi>, <gi>biblFull</gi>, and
<gi>biblStruct</gi> are all defined as members of the class <ident
type="class">model.biblLike</ident>. To add a fourth member (say
<gi>myBibl</gi>) to this class, we need to include in the
<gi>elementSpec</gi> defining our new element a <gi>memberOf</gi>
element which nominates the intended class:
<egXML rend="full" xmlns="http://www.tei-c.org/ns/Examples"><elementSpec ident="myBibl"
						    mode="add" ns="http://www.example.com/ns/">
<classes><memberOf key="model.biblLike"/></classes> <!-- other parts
of the new declaration here --></elementSpec></egXML> The other parts
of this declaration will typically include a description for the new
element and information about its content model, its attributes,
etc. as further described in <ptr target="#TD"/>.
</p>
</div>

</div>

<div type="div2" xml:id="MDNS"><head>Modification and Namespaces</head>

<p>All the elements defined in the TEI scheme are labelled as
belonging to a single <term>namespace</term>, maintained by the TEI
and with the URI <val>http://www.tei-c.org/ns/1.0</val><note
place="foot">This is not strictly the case, since the element
<gi>egXML</gi> used to represent TEI examples is in its own namespace,
<val>http://www.tei-c.org/ns/Examples</val></note>. Only elements
 which are unmodified or which have undergone a clean
modification may use this namespace. </p>

<p>This implies that any other modification (including a renaming or
reversible modification) must either specify a different namespace or
specify no namespace at all. The <att>ns</att> attribute is provided
on elements <gi>schemaSpec</gi>, <gi>elementSpec</gi>, and
<gi>attDef</gi> for this purpose. </p>
<p>Suppose, for example, that we wish to add a new attribute
<att>topic</att> to the existing TEI element <gi>p</gi>.  In the
absence of namespace considerations, this would be an unclean
modification, since <gi>p</gi> does not currently have such an
attribute. The most appropriate action is to explicitly attach the new
attribute to a new namespace by a declaration such as the following:
<egXML rend="full"
xmlns="http://www.tei-c.org/ns/Examples"><elementSpec ident="p"
mode="change">

<attList>
<attDef ident="topic" mode="add" ns="http://www.example.com/ns">
<desc>indicates the topic of a TEI paragraph</desc>
</attDef>
</attList>
</elementSpec></egXML></p>
<p>Document instances using a schema derived from this ODD can now
indicate clearly the status of this attribute:

<egXML rend="full" xmlns="http://www.tei-c.org/ns/Examples">
  <div xmlns:my="http://www.example.com/ns">
<!-- ... -->
<p n="12" my:topic="rabbits">Flopsy, Mopsy, Cottontail, and
Peter...</p>
</div></egXML></p>

<p>Since <att>topic</att> is explicitly labelled as belonging to
something other than the TEI namespace, we regard the modification
which introduced it as clean. A namespace-aware processor will regard
this document as valid according to the unmodified schema.<note
place="foot">Namespace support does not exist in the DTD language, and
therefore these techniques are available only to users of more modern
schema languages such as RELAX NG or W3C schema.</note></p>
<p>Similar methods may be used if a modification (clean or unclean) is
made to the content model or some other aspect of an element, or if it
declares a new element. </p>
<p>If the <att>ns</att> attribute is supplied on a <gi>schemaSpec</gi>
element, it identifies the namespace applicable to all components of
the schema being specified. Even if such a schema includes unmodified
modules from the TEI namespace, the elements contained by such modules
will now be regarded as belonging to the namespace specified on the
<gi>schemaSpec</gi>. This can be useful if it is desired simply to
avoid namespace processing. For example, the following schema
specification results in a schema called <ident>noName</ident> which
has no namespace, even though it comprises declarations from the TEI
<ident type="module">header</ident> module:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><schemaSpec ns="" ident="noName">
<moduleRef key="header"/><!-- ... -->
</schemaSpec></egXML>
</p>
<p>In addition to the TEI canonical namespace mentioned above, the TEI
also defines namespaces for approved translations of the TEI scheme
into other languages. These may be used as appropriate to indicate that a
customisation uses a standardized set of renamings. The namespace for
such translations is the same as that for the canonical namespace,
suffixed by the two character language identifier. A schema specification using
the  Chinese
translation, for example, would use the namespace <ident
type="ns">http://www.tei-c.org/ns/1.0/zh</ident>
</p></div>

<div type="div2" xml:id="MDDO"><head>Documenting the Modification</head> 

<p>The elements used to define a TEI customisation
(<gi>schemaSpec</gi>, <gi>moduleRef</gi>, <gi>elementSpec</gi>, etc.)
will typically be used within a TEI document which supplies further
information about the intended use of the new schema, the meaning and
application of any new or modified elements within it, and so on. This
document will typically conform to a TEI (or other) schema which
includes the module  described in chapter <ptr target="#TD"/><note
place="foot">This module can be used to document any XML schema, and
has indeed been used to document several non-TEI schemas.</note></p>
<p>Where the customization to be documented simply consists in a
selection of modules, perhaps with some deletion of unwanted elements
or attributes, the documentation need not specify anything
further. Even here however it may be considered worthwhile to replace
some of the semantic information provided by the unmodified TEI
specification. For example, the <gi>desc</gi> element of an unmodified
TEI <gi>elementSpec</gi> may describe an element in terms more general
than appropriate to a particular project, or the <gi>exemplum</gi>
elements within it may not illustrate the project's actual intended
usage of the element, or the <gi>remarks</gi> element may contain
discussions of matters irrelevant to the project. These elements may
therefore be replaced or deleted within an <gi>elementSpec</gi> as
necessary. </p>

<!-- example needed -->

<p>Radical revision is also possible.  It is feasible to produce a
modification in which the <gi>teiHeader</gi> or <gi>text</gi> elements
are not required, or in which any other rule stated in these Guidelines
is either not enforced or not enforceable.  In fact, the mechanism, if
used in an extreme way, permits replacement of all that the TEI has to
say about every component of its scheme. Such revisions would result
in documents that are not TEI conformant in even the broadest sense,
and it is not intended that encoders use the mechanism in this
way. We discuss exactly what is meant by the concept of <term>TEI
conformance</term> in the next section, <ptr target="#CF"/>. </p></div>



<div type="div2" xml:id="MDlite"><head>Examples of Modification </head>

<!--    <div xml:id="CFCUSTEX" type="div3">-->

<p>Several  examples of customizations of the TEI
are available as part of the standard release, within the directory
<ident>Exemplars</ident>. They include the following:
<list type="gloss">
          <label>tei_bare</label>
          <item>The schema generated from this customization is the
	  minimum needed for TEI conformance. It provides only a
	  handful of elements. </item>
	  <label>tei_all</label>
          <item>The schema generated from this customization combines
	  all available TEI modules, providing over 500
	  elements.</item>
	  <label>tei_allPlus</label>
          <item>The schema generated from this customization combines
	  all available TEI modules with three other non-TEI
	  vocabularies, specifically MathML, SVG, and XInclude.</item>
</list>
</p>
<p>It is unlikely that any project would wish to use any of these
extremes unchanged. However, they form a useful starting point for
customization, whether by removing modules from tei_all or tei_allPlus, or by
replacing elements deleted from tei_bare. They also demonstrate how an
ODD document may be constructed to provide a basic reference manual to
accompany schemas generated from it.</p>

<p>Shortly after publication of the first edition of these Guidelines,
as a demonstration of how the TEI encoding scheme might be adopted to
meet 90% of the needs of 90% of the TEI user community, the TEI
editors produced a brief tutorial defining one specific
<soCalled>clean</soCalled> modification of the TEI scheme, which they
called TEI Lite. This tutorial and its associated DTD became very
popular and are still available from the TEI web site at
<ptr target="http://www.tei-c.org/Lite/"/>. The tutorial and
associated schema specification is also included as one of the 
Exemplars provided with TEI P5.
</p>
<p>The Exemplars provided with TEI P5 also include a customization
file from which a schema for the validation of other customization
files may be generated. This ODD, called tei_odd, combines the four
basic modules with the tagdocs, dictionaries, gaiji, linking, and
figures modules as well as including the (non-TEI) module defining the
RELAX NG language. This enables schemas derived from this customization
to validate examples contained within them in a number of ways,
further described within the document.</p>
</div>

<!--
          <label>tei_math</label>
          <item>TEI with MathML: This TEI customization file includes
            the minimum TEI modules as well as that for figures, in
            which it customizes the <gi>formula</gi> element to accept
            content from the MathML schema. </item>
          <label>tei_minimal</label>
          <item> TEI with Minimal Setup: This TEI customization file
            includes only the basic four TEI modules. This contains
            slightly more elements than tei_bare, such as all those
            elements in the TEI Core module. </item>
          <label>tei_ms</label>S
          <item> TEI for Manuscript Description: This TEI
            customization file includes the minimum TEI modules likely
            to be needed for manuscript description. </item>
          <label>tei_speech</label>
          <item> TEI for Transcriptions of Speech: This TEI
            customization file includes the minimum TEI modules likely
            to be needed for creating transcriptions of speech or
            language corpora. </item>
          <label>tei_svg</label>
          <item> TEI with SVG: This TEI customization file includes
            the minimum basic four TEI modules plus those for figures
            and tables. It extends the the use of <gi>figure</gi>
            element by allowing elements from the Scaleable Vector
            Graphics (SVG) schema alongside or instead of
            <gi>graphic</gi>. </item>
       <label>tei_xinclude</label>
          <item> TEI with XInclude: This TEI customization file
            includes the minimum basic four TEI modules plus the
              <gi>include</gi> element from the XInclude schema. This
            example has been setup to add includes to the
              <gi>teiHeader</gi> element and allows validation of TEI
            documents before includes have been processed, however the
            usual method of working would be to process includes
            before validation. </item>
-->





<!--


<div><head>DTD stuff punted</head>
<p>Parameter entities are a mechanism for allowing string substitution
within markup declarations; they can thus can be used to effect
changes in declarations.  A parameter entity, unlike an element, may
be declared more than once in a DTD; if more than one declaration is
given, the parser uses the first one it encounters.  Since the
declaration subset within the document is read before the external
file containing the predefined DTD, an entity declaration in the DTD
subset will take precedence over one in the external file.  In the TEI
DTD, the literal string which defines the model group for some
elements, say <gi>p</gi>, is made the value of a parameter entity; the
actual element declaration for <gi>p</gi> contains not the literal
string itself, but a reference to the parameter entity (in this case,
<ident type="pe">macro.paraContent</ident>).  If the document's DTD
subset contains a declaration for <ident type="pe">macro.paraContent</ident>, this will be used in preference
to the standard definition within the external TEI DTD files.  The
redefinability of parameter entities accounts both for the TEI's use
of parameter entities as the vehicle for effecting extensions, and for
the separation of entity definitions from other material (to be
defined below) that might be needed for certain modifications of the
TEI DTD.</p>
<p>Local modifications are most conveniently grouped into two files,
one containing modifications to the TEI parameter entities, and the
other containing new or changed declarations of elements and their
attributes.  Names for these files should be specified by the
parameter entities <ident type="pe">extensions-decl</ident> and
<ident type="pe">extensions</ident>, by declarations such as the
following:
<eg><![CDATA[<!ENTITY % extensions-decl SYSTEM 'project.ent' >
<!ENTITY % extensions SYSTEM 'project.dtd' >]]></eg>
These declarations must be given in the document's DTD subset.  The
first will be needed for all of the modifications discussed below.
The second is only required for the last type of extension
described. The parameter entities thus defined are then referenced at
an appropriate point in the compiling of the TEI DTD, as further
described in section </p> -->

<!-- In the modifiable version of the
DTDs, every element declaration is enclosed by a marked section.  The
marked section is governed by one of the keywords <val>IGNORE</val> or <val>INCLUDE</val>, which is
provided indirectly using a parameter entity. This parameter entity
has the same name as the generic identifier of the element.  Thus, the
declaration for the paragraph element, <gi>p</gi>, occurs within a
marked section <soCalled>guarded</soCalled> by the parameter entity
<ident type="pe">p</ident>:
<eg><![CDATA[ %p; [-->
<!-- element and attlist declaration for p goes here   -->
<!--]]
]]></eg>
The declaration given for these <term>guard entities</term> in the
modifiable version is <val>INCLUDE</val> in all cases.  The
construct above is interpreted thus: the first of the three lines is
the opening of a marked section; when the parser encounters the
section and sees the keyword <val>INCLUDE</val> as its guard (more
precisely, sees a parameter entity the value of which is the keyword
<val>INCLUDE</val>), the content of the marked section is parsed;
the second line of the three is the content of the marked section; and
the third line of the three is the closing of a marked section.  If
the guard is changed to <val>IGNORE</val>, the parser will
ignore the content of the marked section.</p>
<p>Thus, to delete the declaration of a generic identifier and thus
suppress the element entirely, the entity that provides the guard on the
marked section wherein the element declaration appears must be
set to <val>IGNORE</val>.  -->

<!--<eg><![CDATA[<!ENTITY % note 'IGNORE'>]]></eg>
should appear somewhere in the DTD prior to its reference in the guard
around the declaration for the <gi>note</gi> element. This is achieved
by  inserting the above declaration in the file which has its name given by the entity
<ident type="pe">extensions-decl</ident>.-->

<!--instead, the modifiable version
of the DTD makes use of parameter entities that expand to the standard
generic identifiers.  This --> 


<!-- by redefining the
appropriate parameter entities.  The names of parameter entities used
for naming are formed by taking the standard generic identifier of the
element and attaching the string <q>n.</q> (for <q>name</q>) as a
prefix.  Thus, the standard generic identifiers for paragraphs, notes
and quotations, <gi>p</gi>, <gi>note</gi>, and <gi>q</gi>, are defined
by declarations of the following form:
<eg><![CDATA[<!ENTITY % n.p        'p'>
<!ENTITY % n.note     'note'>
<!ENTITY % n.soCalled 'soCalled'>]]></eg>
These parameter entities are all contained within a file (<ident type="file">teigis.ent</ident>) which is embedded during the compilation
of a TEI DTD. --> 
 <!-- all that
is needed is to provide an overriding declaration for the appropriate
parameter entity. -->
<!--

<eg><![CDATA[<!ENTITY % n.note 'annotation'>]]></eg>
This declaration must be inserted in the file which has its name given
by the entity <ident type="pe">extensions-decl</ident>.-->

 <!-- This can be done
by a total replacement of the file that contains the entity
declarations for the names of the elements.  This systematic
replacement of names in the DTD must be followed by a systematic use
(or replacement) of the new names in the document.  To think about
this in the terms used earlier, the set of documents matching the new
DTD (with all names systematically changed in both the DTD and the
documents) is isomorphic to the set of documents matching the original
DTD with no names changed (in either the DTD or the documents).-->

<!--
<p>The formal declarations of the parameter entities used for generic
identifiers are contained in the file <ident type="file">teigis.ent</ident>; since their names and replacement texts
are fully predictable, these parameter entities are not individually
documented in the reference section of these Guidelines.  The
parameter entity <ident type="pe">tei.elementNames</ident> is used to
embed the file <ident type="file">teigis.ent</ident> in the DTD. A
re-declaration for this parameter entity may therefore be used to
embed a different version of this file:
<eg><![CDATA[<!ENTITY % tei.elementNames SYSTEM 'OTAgis.ent' >]]></eg></p>
<p>If an element is renamed using the techniques described here, its
declaration for the global <att>TEIform</att> attribute will be left
undisturbed; the default value will therefore still be the standard
TEI name for the element.  TEI-aware application programs can thus
process TEI-conformant documents which rename TEI elements, since by
consulting the <att>TEIform</att> attribute value the application can
learn the standard name for the element and process it accordingly.</p>
<p>In the normal course of events, the value of this attribute will
never be specified in a TEI-conformant document; all occurrences will
have the default value.  In some special circumstances, it can be
useful to specify a non-default value on some instances of an element;
this allows application programs to process correctly a locally
defined element which usually corresponds to one TEI element (which
would be expressed by the default value) but sometimes to another TEI
element (which would be expressed by explicit values attached to the
element instance).</p>-->


 <!--
In the modifiable version of the TEI DTD, an additional entity is
defined for each model class.  This additional entity also takes the
name of the class, this time prefixed by the string <q>x.</q> (for
<q>extension</q>).  The default value of these <term>x-dot
entities</term> is always the empty string.  A reference to the
corresponding x-dot entity is always included within the replacement
string for each m-dot entity.  This enables an encoder to add new
members to a class simply by declaring a new value for its associated
x-dot entity.-->

<!--
Its content-model entity is defined thus:
<eg><![CDATA[<!ENTITY % x.bibl '' >
<!ENTITY % model.biblLike '%x.bibl; bibl | biblFull | biblStruct' >]]></eg>
With the default value of the x-dot entity, this is the same as
defining <ident type="class">tei.model.biblLike</ident> with the replacement text
<code>bibl | biblFull | biblStruct</code>.</p>
<p>An encoder can add an element to the class by providing a new
declaration for the x-dot entity.  For example, to add a new element
called <gi>my.bib</gi>, this definition would be used:
<eg><![CDATA[<!ENTITY % x.bibl 'my.bib |' >]]></eg>
Note that the specification of an x-dot entity must always end with
the vertical bar character (for alternation).  The definition would be
inserted at the appropriate place in the file associated with the
entity <ident type="pe">extensions-decl</ident>.  This changes the
replacement text of <ident type="pe">model.biblLike</ident> from its default
value to <code>my.bib | bibl | biblFull |
biblStruct</code>.  If more than one element is to be added to a
class, the x-dot entity for the class should be redefined as a list of
the new generic identifiers, each one (<emph>including the
last</emph>) followed by a vertical bar.-->
<!--


There are two ways in which information
about the modifications is recorded.</p> <p>The first record of the
modifications is in the use of the extension files.  The file
associated with the entity <ident type="pe">extensions-decl</ident>
contains the specifications of the parameter entities that are
redefined to accomplish the modifications.  This file should be
structured in such a way that readers can easily identify any
modifications that have been made.  The following structure is
recommended.
<eg/>
The appropriate parameter entity specifications should be entered
after each comment in this file.  The order of the comments
corresponds to the order of the discussion in this chapter (roughly,
from simple to complex).  Setting the appropriate entity to <val>IGNORE</val> for each revised element is done in the last
section of the file.</p> <p>The file associated with the entity <ident type="pe">extensions</ident> should contain the DTD fragments
for new and changed element definitions.  The following structure is
recommended.
<eg/>
</p>
<p>These files give a parser sufficient information to implement
the modifications and are also useful in providing human readers with
some indication of the changes made in the TEI DTD


 To effect this,
the following doctype declaration (available in the file <ident type="file">teilite.dec</ident>) was appropriate:
<eg><![CDATA[<!DOCTYPE TEI PUBLIC "-//TEI P5//DTD Main DTD Driver File//EN" 'tei2.dtd' [
<!ENTITY % TEI.prose    'INCLUDE' >
<!ENTITY % TEI.linking  'INCLUDE' >
<!ENTITY % TEI.analysis 'INCLUDE' >
<!ENTITY % TEI.figures  'INCLUDE' >
<!ENTITY % TEI.XML      'INCLUDE' >
<!ENTITY % extensions-decl SYSTEM 'teilitex.ent' >
<!ENTITY % extensions SYSTEM 'teilitex.dtd' >
]>]]></eg>
This declaration is  appropriate for an XML customization. If an
SGML version is required, the parameter entity <ident type="pe">TEI.XML</ident>
should be redefined, by replacing its declaration above with a
declaration like the following:
<eg><![CDATA[<!ENTITY % TEI.XML  "IGNORE">]]></eg>-->
<!-- 
** commented out 2002-02-03 by Syd as I think it is simply untrue. **
Note that the position of this declaration is critical: it must
precede the declarations for the two TEI extension files. -->
<!--<p>The file <ident type="file">teilitex.ent</ident> consists largely of
declarations like the following:
<eg><![CDATA[<!ENTITY % TEI      'INCLUDE' >
<!ENTITY % teiCorpus  'IGNORE' >]]></eg> 
There is one line for each element potentially available in the
tagsets selected, indicating whether it is to be included in the
resulting DTD or not. By default, elements are always included, so the
first line above is not strictly necessary. However, its inclusion
makes it easier for the user of this extension file to see at a glance
which elements from the original DTD have been included and which have
not. </p>
<p>This file also contains, at its start, 
declarations for four  parameter entities used in defining content
models. The first three are needed to add the new (non-TEI) elements
declared for this customization into existing model classes:
<eg><![CDATA[<!ENTITY % x.data      'ident | code | kw |'                    >
<!ENTITY % x.inter     'eg |'                                   >
<!ENTITY % x.common    'eg |'                                   >]]></eg>
As further discussed in section <ptr target="#STEC"/>, these
declarations have the effect of adding the elements <gi>ident</gi>,
<gi>code</gi>, and <gi>kw</gi> to the <ident type="class">model.pPart.data</ident>
model class, and adding the element <gi>eg</gi> to the <ident type="class">model.inter</ident> and <ident type="class">model.common</ident>
classes. Without these declarations, the elements named here would not
appear anywhere within the structure of the TEI DTD.</p>
<p>The entity file also redefines the <ident type="class">att.global.linking</ident> attribute class, which is used to add
linking attributes to all elements when the <ident type="pe">TEI.linking</ident>
tag set is enabled. In TEI lite only a subset of the linking
attributes, given by the following definition, is required (compare
this declaration with that in the reference section for this class):
<eg><![CDATA[<!ENTITY % a.linking '
          corresp            IDREFS              #IMPLIED
          next               IDREF               #IMPLIED
          prev               IDREF               #IMPLIED'      >]]></eg>
</p>
<p>In addition, this entity file contains declarations for a number of
commonly used character entity sets (see further chapter <ptr target="#CH"/>) and graphic notations (see further section <ptr target="#FTGRA"/>). Different sets will be declared, depending on
whether the parameter entity <ident type="pe">TEI.XML</ident> is
specified as <val>INCLUDE</val> or <val>IGNORE</val>. The XML
version of TEI Lite supplies Unicode definitions for these character
entities; the SGML version supplies SDATA declarations. </p> 
<p>As supplied, the following is typical of the character entity
set declarations included for XML:
<eg><![CDATA[<!ENTITY % ISOlat1 
    PUBLIC "-//TEI//ENTITIES Unicode values for ISO 8879 Added Latin 1//EN"
   "iso-lat1.ent">]]></eg>
</p>
<p>This declaration associates the parameter entity <ident type="pe">ISOlat1</ident> with a public entity defined by the TEI with
the formal identifier <ident type="fpi">-//TEI//ENTITIES Unicode values for ISO
8879 Added Latin 1//EN</ident>. The user may specify the actual
location of this entity in a number of ways: the default is to seek a
file with the name <ident type="file">iso-lat1.ent</ident>. This may be
over-ridden by supplying an alternative location for the entity set,
either by means of another declaration in the DTD subset, or by means
of an alternative entry in an associated SGML Open Catalog
file. Sample copies of the standard entity sets are available from the
TEI web site at <ptr target="http://www.tei-c.org/XML_Entities/"/>, so one way of modifying the
above declaration for an XML DTD might be
<eg><![CDATA[<!ENTITY % ISOlat1 
    PUBLIC "-//TEI//ENTITIES Unicode values for ISO 8879 Added Latin 1//EN"
   "http://www.tei-c.org/XML_Entities/iso-lat1.ent">]]></eg>
</p>
<p>SGML versions for the same entity sets are also available. These have a different
formal public identifier, but the same default system identifier: thus, if the
parameter entity <ident type="pe">TEI.XML</ident> has the value
<val>IGNORE</val>, the declaration for <ident type="pe">ISOlat1</ident> will be as follows: 
<eg><![CDATA[<!ENTITY % ISOlat1 
    PUBLIC "ISO 8879-1986//ENTITIES Added Latin 1//EN"
   "iso-lat1.ent">]]></eg>
</p>
<p>Again, the user can override this association by specifying a
different system identifier in the DTD subset, or in a local catalog
file; sample entity sets for SGML are also available from the TEI web
	  site at <ptr target="http://www.tei-c.org/ISO_Entities"/>, so
one way of modifying the above declaration for an SGML DTD might be
<eg><![CDATA[<!ENTITY % ISOlat1 
    PUBLIC "ISO 8879-1986//ENTITIES Added Latin 1//EN"
   "http://www.tei-c.org/ISO_Entities/iso-lat1.ent">]]></eg> 
</p>
<p>Following
their declaration, the parameter identifiers for these four entity sets are referenced:
<eg>%ISOlat1;
%ISOlat2;
%ISOpub; %ISOnum;</eg>
</p>
<p>The remainder of the TEI Lite  extension entity file contains
declarations  for the following commonly used notations:
<eg><![CDATA[<!NOTATION png PUBLIC
  '-//TEI//NOTATION IETF RFC2083 Portable Network Graphics//EN' >
<!NOTATION jpeg PUBLIC
  'ISO DIS 10918//NOTATION JPEG Graphics Format//EN' >
<!NOTATION tiff PUBLIC
   '-//TEI//NOTATION Aldus Tagged Image File Format//EN'>
<!NOTATION gif PUBLIC
  '-//TEI//NOTATION Compuserve Graphics Interchange Format//EN' >
<!NOTATION sgml PUBLIC
  'ISO 8879:1986//NOTATION Standard Generalized Markup Language//EN' >
<!NOTATION wsd  PUBLIC
  '-//TEI P3-1994//NOTATION Writing System Declaration//EN' >]]></eg>
With these declarations in force, the TEI Lite user may embed graphics
in PNG, JPEG, TIFF, or GIF format (as further discussed in section
<ptr target="#FTGRA"/>; the declarations for SGML and for WSD are
required to allow for
reference to  external SGML or WSD documents as further discussed in sections
<ptr target="#SA"/> and <ptr target="#WD"/> respectively.</p>
<p>The file <ident type="file">teilitex.dtd</ident> contains
the following declarations for the new elements listed above:
<eg><![CDATA[<!ELEMENT %n.gi;     %om.RO; (#PCDATA)                             >
<!ATTLIST %n.gi;             %a.global;
          TEI                (yes | no)          'yes'
          TEIform            CDATA               'gi'              >
<!ELEMENT %n.eg;     %om.RR; (#PCDATA)                             >
<!ATTLIST %n.eg;             %a.global;
          TEIform            CDATA               'eg'              >
<!ELEMENT ident      %om.RR; (#PCDATA)                             >
<!ATTLIST ident              %a.global;  
                             type CDATA #IMPLIED                   >
<!ELEMENT code       %om.RR; (#PCDATA)                             >
<!ATTLIST code               %a.global;                            >
<!ELEMENT kw         %om.RR; (#PCDATA)                             >
<!ATTLIST kw                 %a.global;          
                             type CDATA #IMPLIED                  >]]></eg>
</p>
<p>Note that these declarations use the same parameter entities as
other parts of the TEI DTD, in particular the parameter entities
<ident type="pe">om.RR</ident> and <ident type="pe">om.RO</ident>
which make the same extension file usable in both XML or SGML
contexts, as further explained in section <ptr target="#STXML"/>, and
<ident type="pe">a.global</ident>, which supplies the standard
definition for the global attributes.</p>
<p>Two of the elements listed above as <soCalled>new</soCalled> are in
fact already defined in the auxiliary tag set for tagset documentation
discussed in chapter <ptr target="#TD"/>; since, however, the extension
mechanism defined here does not allow us to include auxiliary tagsets
as such, we have simply copied the definitions for those elements
(<gi>gi</gi> and <gi>eg</gi>) from the DTD into our extension file,
thus allowing for them to be renamable. The other new elements are
simply defined in the same way as any others</p>
<p>To complete the job, full tag descriptions for the  new elements added
should be provided. Here is a sample description for the
<gi>ident</gi> element:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<tagDoc><gi>ident</gi>
<rs>identifier</rs>
<desc>contains an identifier in some formal language
(e.g. a variable name); also used for <soCalled>syntactic
variables</soCalled> in syntax diagrams and the like.</desc>
<attList>
<attDef><attName>type</attName><desc>
indicates the type of identifier.</desc><datatype>CDATA</datatype>
<valList>
<val>fpi</val><desc>formal public identifier</desc>
<val>file</val><desc>operating system filename</desc>
<val>pe</val><desc>parameter entity</desc>
<val>gi</val><desc>generic identifier in SGML or XML</desc>
</valList>
<default>#IMPLIED</default></attDef></attList>
Further examples of such descriptions are provided in
chapter <ptr target="#XT"/>. </tagDoc>]]></egXML></p>
-->


<!-- <p>Content models or attributes for existing elements are
modified in two stages.  First, the existing declaration of the element
must be deleted in the manner described in the first section of this
chapter.  Second, a new declaration for the element is given.  This new
declaration must be inserted in the file associated with the entity
<ident type="pe">extensions</ident>.</p> -->
<!--example, suppose that symbolic designations to be marked with the
element <gi>term</gi> can always be associated with a particular
source.  While the content model of the publication version of the TEI
DTD is acceptable, the attribute list needs to be extended.  To
perform this modification, the following steps must be taken.  The
declaration <eg><![CDATA[<!ENTITY % term 'IGNORE' >]]></eg> must be
inserted into the file associated with the entity <ident
type="pe">extensions-decl</ident>.  Then a new definition must be
inserted into the file associated with the entity <ident
type="pe">extensions</ident>.  In this example, the definition will be
the same as that given in <ptr target="#COHQU"/>, save for the
addition of a new attribute.  <eg><![CDATA[<!ELEMENT term %om.RR;
(%macro.phraseSeq;) > <!ATTLIST term %a.global; type CDATA #IMPLIED
source CDATA #IMPLIED >]]></eg></p>
<p>New elements are defined by inserting their definitions into the
file associated with the entity <ident type="pe">extensions</ident>.  To be usable, they must somehow
be included in the model for some existing element.  This can be done
either by class extension (which can now be seen to be a restricted,
special case of the process defined here) or by redefining the
element(s) within which the new element is to be included.</p>

<p>In the RelaxNG schema fragments, a pattern is associated
with each named model class; in the XML DTD fragments, a parameter
entity is used. For example, the value of the pattern (or parameter
entity) <ident type="pe">model.biblLike</ident> in a TEI schema will
be a list of the members of the class <ident
type="class">model.biblLike</ident>.</p>-->
<!-- not quite true... -->
<!--<p>This indirection makes it
possible to add new elements to any content model, simply by adding them
to the class referenced in the content model.</p>

</div
-->


</div>

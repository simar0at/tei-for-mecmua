<!--
Copyright TEI Consortium. 
Licensed under the GNU General Public License. 
See the file COPYING for details.
$Date$
$Author$
-->
<div1 xmlns="http://www.tei-c.org/ns/1.0" type="Chapter" xml:id="ST" n="3">

<head>The TEI infrastructure</head>

<p>This chapter describes the infrastructure for the encoding scheme
defined by these Guidelines.  It introduces the conceptual framework
within which the following chapters are to be understood, and
describes the technical means by which that conceptual framework is
implemented.  It assumes some familiarity with XML and XML schemas
(see chapter <ptr target="#SG"/>) but is intended to be accessible to
any user of these Guidelines. </p>

<p>The TEI encoding scheme consists of a number of
<term>modules</term>, each of which declares particular XML elements
and their attributes. Part of an element's declaration includes its
assignment to one or more element <term>classes</term>. Modules, and
their contents, may be combined more less freely to form a
<term>schema</term> appropriate to a particular set of
requirements. It is also possible to add new elements which reference
existing classes or elements to a schema, as it is to remove existing
elements from a schema.
	</p>

<p>In principle, a TEI schema may be constructed using any combination
of modules. However, certain TEI modules are of particular importance,
and should always be included in all but exceptional circumstances:
the module <ident type="module">tei</ident> described in the present
chapter is of this kind because it defines classes, macros, and
datatypes which are used by all other modules. The <ident
type="module">core</ident> module, defined in chapter <ptr
target="#CO"/> contains declarations for elements and attributes which
are likely to be needed in almost any kind of documents, and is
therefore recommended for global use. The <ident
type="module">header</ident> module defined in chapter <ptr
target="#HD"/> provides declarations for metadata elements and
attributes required for TEI conformance, while the <ident
type="module">textstructure</ident> module defined in chapter <ptr
target="#DS"/> declares basic structural elements needed for the
encoding of almost any text-like object. Most schemas will therefore
need to include these four modules, but are free to mix and match them
with others.</p>

<p>The specification for a TEI schema is itself a TEI document, using
elements from the module described in chapter <ptr target="#TD"/>: we
refer to such a document informally as an <term>ODD</term> document,
from the abbreviation <q>One Document Does it all</q>. Stylesheets for
maintaining and processing ODD documents are maintained by the TEI,
and these Guidelines are also maintained as an ODD. An ODD document
can be processed to generate a schema expressed using any of the three
schema languages currently in wide use: the XML DTD language, the ISO
RELAXNG language, or the W3C Schema language. </p>

<p>This chapter begins by briefly characterizing each of the modules
available in the TEI scheme. Section <ptr target="#STIN" type="div2"/>
describes in general terms the method of constructing  a TEI schema
in a specific schema language such as XML DTD language, RELAXNG, or
W3C Schema. </p>

<p>The <term>global attributes</term>, characteristics postulated of
every element  in the encoding scheme, are discussed in section 
<ptr target="#STGA" type="div2"/>.</p>

<p>The bulk of the chapter describes the TEI infrastructure
module itself. Although it may be skipped at a first reading, an
understanding of the topics addressed here is essential for anyone
planning to take full advantage of the TEI customization techniques
described in chapter <ptr target="#MD"/>. </p>

<p>In particular, the infrastructure module provides the following
components of the TEI encoding scheme:
<list>
<item>declarations for all 
<term>element classes</term> used to define groups of elements and
their characteristics (section <ptr target="#STEC"/>)</item>
<item>definition of the <term>datatypes</term> used to constrain the
range of legal values for TEI attributes (section <ptr
target="#DTYPES"/>)</item>
<item>definition of other <term>macros</term> used to express some
commonly used content models (section <ptr target="#STmacros"/>)</item>
</list>
</p>

<p>Finally, in section <ptr target="#STPE"/>, the chapter describes
the implementation methods used to generate TEI conformant schema
fragments, in particular for XML DTDs. </p>


<div2 xml:id="STMA"><head>TEI modules</head>

<p>These Guidelines define a large number of elements and attributes
for marking up documents of any kind. Each definition combines a prose
description, provided within a chapter of the Guidelines and in the
reference lists, with a formal declaration, expressed for reference by
means of the ISO schema language RELAXNG. For convenience, each
element is assigned to a single module: the declaration file for each
module thus contains a set of related element declarations, typically
for use in some specific application area, or to support a particular
kind of usage.
 </p>

<p>Corresponding with each module, the TEI provides a <term>schema
fragment</term> in each of three supported schema languages. A TEI
schema is made by combining these fragments, each of which contains
sets of declarations, as further described in section <ptr
target="#STIN"/> below. </p>
<p>For RELAXNG and W3C each module generates a single schema
fragment with the same name as the module. For XML DTD fragments,
however, some  modules generates two fragments: for example
the <ident type="module">analysis</ident> module generates fragments
called <ident type="schemafrag">analysis-decl</ident> and <ident
type="schemafrag">analysis</ident>. This is because the declarations
they contain are needed at different points in the creation of
an XML DTD. The fragment suffixed <ident>-decls</ident> will
typically contain additional class or macro declarations that
complement those provided by the present chapter; for technical
reasons, these must be available separately from the additional
element and attribute declarations contained by the main fragment.  </p>
<p>The following table lists the modules defined by the
current release of the Guidelines:

<!-- table can be re-autogenerated from modules.xsl LB 20-xii-05 -->



<table xml:id="tab-mods">
<row role="label">
<cell>Module name</cell>
<cell>Formal public identifier</cell>
<cell>Where defined</cell>
</row>
<row><cell>analysis</cell><cell>Analysis and Interpretation</cell><cell><ptr target="#AI"/></cell></row>
<row><cell>certainty</cell><cell>Certainty and Uncertainty</cell><cell><ptr target="#CE"/></cell></row>
<row><cell>core</cell><cell>Common Core</cell><cell><ptr target="#CO"/></cell></row>
<row><cell>corpus</cell><cell>Metadata for Language Corpora</cell><cell><ptr target="#CC"/></cell></row>
<row><cell>declarefs</cell><cell>Feature System Declaration</cell><cell><ptr target="#FD"/></cell></row>
<row><cell>dictionaries</cell><cell>Print Dictionaries</cell><cell><ptr target="#DI"/></cell></row>
<row><cell>drama</cell><cell>Performance Texts</cell><cell><ptr target="#DR"/></cell></row>
<row><cell>figures</cell><cell>Tables, Formulae, Figures</cell><cell><ptr target="#FT"/></cell></row>
<row><cell>gaiji</cell><cell>Character and Glyph Documentation</cell><cell><ptr target="#WD"/></cell></row>
<row><cell>header</cell><cell>Common Metadata</cell><cell><ptr target="#HD"/></cell></row>
<row><cell>iso-fs</cell><cell>Feature Structures</cell><cell><ptr target="#FS"/></cell></row>
<row><cell>linking</cell><cell>Linking, Segmentation, and Alignment</cell><cell><ptr target="#SA"/></cell></row>
<row><cell>msdescription</cell><cell>Manuscript Description</cell><cell><ptr target="#MS"/></cell></row>
<row><cell>namesdates</cell><cell>Names and Dates</cell><cell><ptr target="#ND"/></cell></row>
<row><cell>nets</cell><cell>Graphs, networks and trees</cell><cell><ptr target="#GD"/></cell></row>
<row><cell>spoken</cell><cell>Transcribed Speech</cell><cell><ptr target="#TS"/></cell></row>
<row><cell>tagdocs</cell><cell>Documentation Elements</cell><cell><ptr target="#TD"/></cell></row>
<row><cell>tei</cell><cell>TEI Infrastructure</cell><cell><ptr target="#ST"/></cell></row>
<row><cell>terminology</cell><cell>terminology</cell><cell><ptr target="#TE"/></cell></row>
<row><cell>textcrit</cell><cell>Text Criticism</cell><cell><ptr target="#TC"/></cell></row>
<row><cell>textstructure</cell><cell>Default Text Structure</cell><cell><ptr target="#DS"/></cell></row>
<row><cell>transcr</cell><cell>Transcription of Primary Sources</cell><cell><ptr target="#PH"/></cell></row>
<row><cell>verse</cell><cell>Verse</cell><cell><ptr target="#VE"/></cell></row>
</table>

</p></div2>

<div2 xml:id="STIN"><head>Defining a TEI schema</head>

<p>To determine that an XML document is valid (as opposed to merely
well-formed), its structure must be checked against a schema, as
discussed in chapter <ptr target="#SG"/>. For a valid TEI document,
this schema must be a conformant TEI schema, as further defined in
chapter <ptr target="#CF"/>.  Local systems may allow their schema or
DTD to be implicit, but for interchange purposes the schema associated
with a document <emph>must</emph> be made explicit. </p>

<p>A TEI-conformant schema is a specific combination of TEI modules, possibly
also including additional declarations that add or
change the element and attribute declarations contained by each
module. The TEI provides an application-independent
way of specifying the components of a TEI schema by means of the
<gi>schemaSpec</gi> element defined in chapter <ptr target="#TD"/>
element, but it may also be supplied using schema definition
mechanisms specific to a particular schema language. The process of
assembling a usable schema, which a running
XML system such as a validating editor might use, may thus be carried
out in several different ways:

<list>
<item>the ODD specification may be processed to generate
a schema document in whichever schema language the editor
supports</item>
<item>for an editor using DTD language, a DTD subset declaration
invoking the DTD fragments corresponding with the schema specification
may be produced, together with XML DTD code for any additional
modifications</item>
<item>for an editor using RELAXNG language, a schema referencing the
appropriate predefined RELAXNG patterns may be produced, together
with any additional definitions required to support
modifications</item>
</list>
</p>
<p>The schema fragments produced by the TEI are delivered in a
parameterised form which facilitates the second and third options
listed above. The recommended method of customization is however the
first. For blind interchange of TEI documents, it should be necessary
to supply no more than a complete ODD specification along with the
documents.
</p>

<p>The simplest customization of the TEI scheme combines just the
four recommended modules mentioned above. In ODD format, this would
look like this:
<egXML xmlns="http://www.tei-c.org/ns/Examples">
<schemaSpec ident="TEI-minimal" start="TEI">
  <moduleRef key="tei"/>
  <moduleRef key="header"/>
  <moduleRef key="core"/>
  <moduleRef key="textstructure"/>
</schemaSpec>
</egXML></p>
<p>This schema specification contains references to each of the four
modules, identified by the <att>key</att> attribute on the
<gi>moduleRef</gi> element. The schema specification itself is also
given an identifier (<ident>TEI-minimal</ident>) and its start point, or
root element, is specified by means of the <att>start</att> attribute.
An ODD processor will generate an appropriate XML DTD, or relaxNG
or W3C schema from this set of declarations, which would then be
associated with the document instance by one of a number of different
mechanisms, as further described in chapter <ptr target="#SG"/><!-- somewhere --> </p>

<p>The same effect might be obtained by means of a RELAXNG
schema like the following:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[
include "tei.rnc" 
include "core.rnc"
include "header.rnc"
include "textstructure.rnc"
start = TEI 
]]></egXML>
which combines the declarations from the filenames specified to form a
schema with the given start point. </p>
<p>The same effect might be obtained in a DTD processing environment
by prefixing the document with a <term>DOCTYPE declaration</term> like the following:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!DOCTYPE TEI
PUBLIC "-//TEI P5//DTD Main Document Type//EN" "tei.dtd" [
      <!ENTITY % TEI.header 'INCLUDE' >
      <!ENTITY % TEI.core 'INCLUDE' >
      <!ENTITY % TEI.textstructure 'INCLUDE' >
]>]]></egXML>
This uses an indirect method of nominating the DTD schema fragments
from which the DTD is to be constructed, based on the use of parameter
entities, as further discussed in section <ptr target="#STPE"/>.
</p>

<!-- does this belong here? -->
<p>In much of the discussion elsewhere in these Guidelines, it is
generally assumed for clarity of exposition that a text is a unitary
object for which only one module is necessary.  It is not uncommon,
however, for a text to combine different kinds of object, or for an
encoder to wish to enrich their encoding with elements drawn from many
different modules.  Examples include:

<list type="bullets">
<item>when the text is a collection of other texts, which do not all use
the same module:  e.g. an anthology of prose, verse, and drama</item>
<item>when the text contains other smaller, embedded texts:  e.g. a poem
or song included in a prose narrative</item>
<item>when some sections of the text are written in one form, and others
in a different form:  e.g. a novel where some chapters are in prose,
others take the form of dictionary entries, and still others the form of
scenes in a play</item>
<item>when the text moves back and forth among forms not between
sections but within a single section:  e.g. mixed prose-and-verse forms
like many pastorals or like some portions of the Poetic Edda</item></list></p>
<p>The TEI provides the following mechanisms to handle these cases:
<list type="bullets">
<item>a definition of a corpus or collection as a series of
<gi>TEI</gi>
documents, sharing a common TEI header (see chapter <ptr target="#CC"/>)</item>
<item>a definition of composite texts which combine optional front and
backmatter with a
group of collected texts,
themselves possibly composite (see section <ptr target="#DSGRP"/>)</item>
<item>a notion of <term>embedded text</term>
which allows one narrative to be embedded within another: this is
accomplished by defining the <gi>text</gi> element to be a member of
the class of elements which can appear within or between text
components such as paragraphs, as described
briefly at the conclusion of section <ptr target="#DSGRP"/>)</item></list></p>
<p>The following element specification for example allows for any mixture of
the low level structural tags defined in the prose, drama and dictionary
 modules:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><schemaSpec ident="TEI-Moby" start="TEI">
  <moduleRef key="tei"/>
  <moduleRef key="header"/>
  <moduleRef key="core"/>
  <moduleRef key="textstructure"/>
  <moduleRef key="drama"/>
  <moduleRef key="dictionaries"/>
  <!-- Structurally, Moby Dick is not your
       everyday common or garden variety novel ... -->
</schemaSpec></egXML></p>
</div2>

<div2 xml:id="STGA"><head>Global Attributes</head>
<p>The following attributes are defined for every TEI element.<note
place="foot">More exactly, these are the attributes of the attribute
class <ident type="class">att.global</ident>, to which all elements
belong; for further discussion of attribute classes and ways in which
attributes may be inherited and over-ridden, see section <ptr
target="#STECAT"/>.</note> <specList><specDesc key="att.global"
atts="xml:id n xml:lang rend"/></specList>
 </p>
<p>Some modules (e.g. those for terminology, linking, and analysis)
define other global attributes; these are documented in the appropriate
chapters of Part III and Part IV.  See also section <ptr target="#STECAT"/>.
 </p>
<p>Any TEI element may be given values for <att>xml:id</att>, <att>n</att>,
<att>xml:lang</att>, <att>rend</att>, simply by
specifying values for these attributes.
The following two examples convey the same information about the text:
that the material transcribed occurs within a <gi>p</gi> element
(paragraph).  They differ only in that the second provides an identifier
for the paragraph, to which other elements (e.g. notes or hypertext
links) can conveniently refer.
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p>If to do were as easy as to know what were
good to do, chapels had been churches and poor men's cottages
princes' palaces.  It is a good divine that follows his own
instructions ...</p></egXML>
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p xml:id="mv1.2.5">If to do were as easy as to know what were
good to do, chapels had been churches and poor men's cottages
princes' palaces.  It is a good divine that follows his own
instructions ...</p></egXML>
<!-- Merchant of Venice, I.ii, speech 5 (Portia)              -->
</p>
  <p>The values of <att>xml:id</att> attributes must be legal
	<ident type="kw">names</ident> with respect to the SGML declaration in
	force. For XML documents this means that an <att>xml:id</att> value
	must begin with a letter (as defined in the World Wide Web
	Consortium's XML Recommendation) or the underscore charcter
	(<q>_</q>), and contain no characters other than letters, digits,
	hyphens, underscores, full
	stops, and certain combining and extension characters.<note place="foot">The colon is also by default a
	valid name character; however, it is reserved for a specific
	purpose in XML (to indicate namespace prefixes), and is not
	therefore generally recommended by these Guidelines, for
	compatability reasons.</note></p>
  <p>In XML names (and thus the values of <att>xml:id</att> in an XML TEI
	document) upper and lower case letters are distinguished, and
	thus <mentioned>partTime</mentioned> and
	<mentioned>parttime</mentioned> are two distinctly different
	names, and could (perhaps unwisely) be used to denote two
	different element types.</p>
  <p>If two elements are given the same identifier,a validating XML parser will
	signal a syntax error. The following example, therefore, is
	<emph>not</emph> valid:
<egXML xmlns="http://www.tei-c.org/ns/Examples">&lt;p xml:id="PAGE1"><q>What's it going to be then, eh?</q>&lt;/p>
<p xml:id="PAGE1">There was me, that is Alex, and my three droogs,
that is Pete, Georgie, and Dim, ... </p></egXML>
<!-- Clockwork Orange, opening -->
</p>
<p>For a discussion of methods of providing unique identifiers for
elements, see section <ptr target="#CORS2"/>.</p>
<p>The <att>n</att> attribute allows identifying information (e.g.
chapter numbers, etc.) to be encoded even if it would not be a legal
<att>xml:id</att> value.  Its value may be any string of characters;
typically it is a number or other similar enumerator or label.  For
example, the numbers given to the items of a numbered list may be
recorded with the <att>n</att> attribute; this would make it possible to
record errors in the numeration of the original, as in this list of
chapters, transcribed from a faulty original in which the number 10 is
used twice, and 11 is omitted:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><list type="ordered">
  <item n="1">About These Guidelines</item>
  <item n="2">A Gentle Introduction to SGML</item>
  <item n="9">Verse</item>
  <item n="10">Drama</item>
  <item n="10">Spoken Materials </item>
  <item n="12">Print Dictionaries</item>
</list></egXML>
The <att>n</att> attribute may also be used to record non-unique names
associated with elements in a text, possibly together with a unique
identifier as in the following example start-tags:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><div type='chap' n='One' xml:id='TXT0101'/></egXML>
<egXML xmlns="http://www.tei-c.org/ns/Examples"><div type='stanza' n='xlii'/></egXML>
 </p>
<p>The <att>xml:lang</att> attribute indicates the language, writing system,
and character set associated with a given element and all its contents.
If it is not specified, the value is inherited from that of the
immediately enclosing element.  As a rule, therefore, it is simplest to
specify the base language of the text on the <gi>TEI</gi> element, and
allow most elements to take the default value for <att>xml:lang</att>; the
language of an element then need be explicitly specified only for
elements in languages other than the base language.
 </p>
<p>The values used for the <att>xml:lang</att> attribute must be
constructed in a particular way, using values from standard lists. See
further <ptr target="#CHSH"/>.</p>
<p>The following two encodings convey the same information about the
language of the text, since in the first the <att>xml:lang</att> attributes
on the <gi>emph</gi> elements specify the same value as that on the
parent <gi>p</gi> element, while in the second they inherit that value
without specifying it.
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p xml:lang="en"> ... Both parties deprecated war, but one of
 them would <emph xml:lang="en">make</emph> war rather than let
 the nation survive, and the other would <emph xml:lang="en">accept
 </emph> war rather than let it perish, and the war came.</p></egXML>
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p xml:lang="en"> ... Both parties deprecated war, but one of
 them would <emph>make</emph> war rather than let
 the nation survive, and the other would <emph>accept</emph>
 war rather than let it perish, and the war came.</p></egXML>
<!-- Lincoln's Second Inaugural Address, 4 March 1865, rpt.   -->
	<!-- (from Richardson, ed., Messages and Papers, 6:276ff) in  -->
	<!-- H. S. Commager, ed., Documents of American History, 5th  -->
	<!-- ed.  (New York:  Appleton-Century-Crofts, 1949), p.      -->
	<!-- 442.                                                     -->
 </p>
<p>In the following example, by contrast, the <att>xml:lang</att> attribute
on the <gi>term</gi> element must be given if we wish to record the fact
that the technical terms used are Latin rather than English; no
<att>xml:lang</att> attribute is needed on the <gi>q</gi> element, by
contrast, because it is in the same language as its parent.  It is
strongly recommended that all language shifts in the source be
explicitly identified by use of the <att>xml:lang</att> attribute, as
described in chapter <ptr target="#CH"/>.
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p xml:lang="en">The constitution declares <q>that no bill of attainder
or <term xml:lang="la">ex post facto</term> law shall be passed.</q> ... </p></egXML>
<!-- Marbury v. Madison, 1 Cranch, 137 (1803), rpt. in H. S.  -->
	<!-- Commager, ed., Documents of American History, 5th ed.    -->
	<!-- (New York:  Appleton-Century-Crofts, 1949), p. 192.      -->
</p>
<p>As further discussed in section <ptr target="#CHSH"/>, additional
information  about a particular language
may be supplied in the <gi>language</gi> element within the header (see
section <ptr target="#HD41"/>).</p>
<p>The <att>rend</att> attribute is used to give information about the
physical presentation of the text in the source.  In the following
example, it is used to indicate that both the emphasized word and the
proper name are printed in italics:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p> ... Their motives <emph rend="italics">might</emph> be
 pure and pious; but he was equally alarmed by his knowledge
 of the ambitious <name rend="italics">Bohemond</name>, and
 his ignorance of the Transalpine chiefs: ...</p></egXML>
<!-- Gibbon, Decline and Fall, chapter 58, para beginning     -->
	<!-- 'In some Oriental tale I have read ...', p. 391 of       -->
	<!-- Britannica edition.                                      -->
	<!--  ... played fast and loose with by LB for pedagogic purposes -->
	<!-- Shame, shame.                                            -->
If all or most <gi>emph</gi> and <gi>name</gi> elements are rendered in
the text by italics, it will be more convenient to register that fact in
the TEI header once and for all and specify a <att>rend</att> value
only for any elements which deviate from the usual rendition.
 </p>
<p>The contents of the <att>rend</att> attribute are free text.  In any
given project, encoders are advised to settle on a standard vocabulary
with which to describe typographic or manuscript rendition of the text,
and to document their usage of that vocabulary in the <gi>rendition</gi>
element of the TEI header. </p>
</div2>


<div2 xml:id="STOV"><head>The TEI infrastructure module</head>

<p>The TEI infrastructure module is a required component of any TEI
schema. It provides declarations for all datatypes, and for the
attribute classes, model classes, and macros used by other modules in
the TEI scheme. Its components are listed below:
<!-- only they aren't-->
<moduleSpec xml:id="DSTTEI2"  ident="tei" type="core">
<altIdent type="FPI">TEI Infrastructure</altIdent>
<desc>Declarations for datatypes, classes, and macros available to all
TEI modules</desc>
</moduleSpec>
</p>

<p>The order in which declarations are provided within the
infrastructure module is critical, since several declarations refer to
others, which must therefore precede them. Other constraints on the
order of declarations derive from the way in which the modularity of
the TEI scheme is implemented in different schema languages. The XML
DTD fragment implementing this TEI module make extensive use of
<term>parameter entities</term> and <term>marked sections</term> to
effect a kind of conditional construction; the RELAXNG schema fragment
similarly predeclares a number of patterns with null
(<soCalled>notAllowed</soCalled>) values. These techniques are further
explained in chapter <ptr target="#SG"/>. </p>

<p>Some components of the infrastructure module are automatically
generated by the ODD processor. Most of these are needed only for the XML
DTD implementation, which contains the following sections in the order
given:
<list>
<item>Declare naming entities for all elements to permit renaming (see
further <ptr target="#STPEGI"/>).</item>
<item>Embed any user-supplied entity declarations (see
further <ptr target="#STOVLO"/>).</item>
<item>Embed all available datatype macro declarations (see <ptr
target="#DTYPES"/>)</item>
<item>Declare TEI.XML marked section to permit SGML support (see
further <ptr target="#STXML"/>). </item>
<item>Embed all <soCalled>pre-declared</soCalled>  class and
macro declarations</item>
<item>Embed all other globally available class declarations </item>
<item>Embed conditionally available module-specific classes (see
further <ptr target="#STPED"/>). </item>
<item>Embed all other macro declarations</item>
<item>Embed any user-supplied element declarations (see
further <ptr target="#STOVLO"/>).  </item>
<item>Embed conditionally available module-specific declarations (see
further <ptr target="#STPED"/>).</item>
</list>
</p>
<p>The RELAXNG schema fragment corresponding to this module  contains simply the following:

<list>
<item>Declare default values for predeclared classes</item>
<item>Declare initial values for all classes</item>
<item>Declare all macros</item>
</list>

</p>
<p>This simpler structure is a consequence of the way that the RELAXNG
schema language permits declarations to be combined from different
modules in any order, provided that the patterns defining those
declarations are properly initialised.</p>

</div2>

<div2 xml:id="DTYPES"><head>Datatype macros</head>
<p>The values which attributes may take in a TEI schema are defined,
for the most part, by reference to a TEI <term>datatype</term>. Each
such datatype is defined in terms of other primitive datatypes (for
the most part defined by the W3C Schema language <!-- need proper
reference-->), literal values, or other datatypes. This indirection
makes it possible for a TEI application to set constraints either
globally or in individual cases, by redefining the datatype definition
or the reference to it respectively. In some cases, the TEI datatype
includes additional usage constraints which cannot be enforced by
existing schema languages, although a TEI-compliant processor should
attempt to validate them (see further discussion in chapter <ptr
target="#CF"/>). </p>
<p>Where literal values or name tokens are used in a datatype
definition, an associated value list supplies definitions for the
significance of suggested or (in the case of closed lists) all
possible values.</p>
<!-- but can we put a valList in a macroSpec ? -->
<p>TEI-defined datatypes may be grouped into those which define
normalised values for numeric quantities or probabilities, those which
define various kinds of short-hand codes or keys, and those which
define pointers or links. </p>
<p>The following datatypes are used for attributes which are intended
to hold normalized values of various kinds. First, expressions of
quantity or probability:
<specList>
<specDesc key="data.certainty"/> 
<specDesc key="data.probability"/>
<specDesc key="data.numeric"/>
<specDesc key="data.count"/>
</specList>
</p>
<p>Examples of attributes using the data.probability datatype include
<att>degree</att> on <gi>damage</gi> or <gi>certainty</gi>;  <att>scale</att> on
<gi>graphic</gi>; examples of  data.numeric include
<att>quantity</att> on  members of the <ident
type="class">att.measurement</ident> class or <att>value</att> on
<gi>numeric</gi>; examples of data.count include <att>cols</att> on
<gi>cell</gi> and <gi>table</gi>.</p>

<p>
They are formally defined as follows:
<specGrp xmlns:rng="http://relaxng.org/ns/structure/1.0"
	 xml:id="DTYPES-1" n="Numeric Datatypes">
&data.certainty; 
&data.probability;
&data.numeric;
&data.count;
</specGrp>
</p>
<p>Next, the datatypes used for attributes which are intended to hold
normalized dates or times, durations, or truth values:
<specList>
<specDesc key="data.duration"/> <!-- only one usage! -->
<specDesc key="data.temporal"/>
<specDesc key="data.truthValue"/>
<specDesc key="data.xTruthValue"/>
<specDesc key="data.language"/>
<specDesc key="data.sex"/>
</specList>
</p>
<p>Note that in each of these cases the values used are those
recommended by existing international standards: ISO 8601 in the case of duration; ISO 8601 as profiled
by <title>XML Schema Part 2: Datatypes Second Edition</title> in the
case of time and date; W3C Schema datatypes in the case of truth values;
RFC 3066 in the case of language; and ISO 5218 in the case of sex.</p>
<p>Formal declarations for these  datatypes are as follows:
<specGrp xmlns:rng="http://relaxng.org/ns/structure/1.0"
	 xml:id="DTYPES-2" n="Normalised Datatypes">
&data.temporal;
&data.duration;
&data.truthValue;
&data.xTruthValue;
&data.language;
&data.sex;
</specGrp>
</p>
<p>The following datatypes have more specialised uses:
<specList>
<specDesc key="data.outputMeasurement"/>
<specDesc key="data.namespace"/>
<specDesc key="data.pattern"/> <!-- only one usage -->
<specDesc key="data.pointer"/>
<specDesc key="data.pointers"/>
</specList>
</p>
<p>They are formally defined as follows:
<specGrp xmlns:rng="http://relaxng.org/ns/structure/1.0"
	 xml:id="DTYPES-3" n="Notation and pointer datatypes">
&data.namespace;
&data.outputMeasurement;
&data.pattern;
&data.pointer;
&data.pointers;
</specGrp>
</p>
<p>By far the largest number of TEI attributes have values which are
coded values or names of some kind. These values may be constrained or
defined in a number of different ways, each of which is given a
different name, as follows:
<specList>
<specDesc key="data.key"/> <!-- 2 uses -->
<specDesc key="data.word"/>
<specDesc key="data.words"/>
<specDesc key="data.name"/>
<specDesc key="data.names"/>
<specDesc key="data.enumerated"/>
<specDesc key="data.code"/>
</specList>
</p>

<p>Attributes such as <att>key</att> of <gi>persName</gi> and other
members of the <ident type="class">att.naming</ident> class are of type
<ident type="datatype">data.key</ident>. They are used to supply an externally-defined
identifier, such as a database key or filename. Because such
identifiers are externally-defined, no constraints are placed on their
possible values: and any string of Unicode characters may be used. If
constraints on their values are known to the encoder such as the rules
for constructing a valid database key in a particular system, this may
be documented within the TEI Header but cannot be enforced.</p>

<p>Attributes of type <ident type="datatype">data.word</ident>, such as
<att>age</att> on <gi>person</gi> are used to supply an identifier
expressed as any kind of single token or word. The TEI places a few
constraints on the characters which may be used for this purpose:
only Unicode characters classified as letters, digits, punctuation
characters, or symbols can appear in an attribute value of this
kind. Note in particular that such values cannot include
whitespace characters. Legal values include
<val>cholmondeley</val>, <val>été</val>, <val>1234</val>, <val>e_content</val>, or
<val>xml:id</val>, but not  <val>grand wazoo</val>. Attributes of this kind are sometimes used to associate (by
co-reference) elements of different types.</p>

<p>Attributes of type <ident type="datatype">data.name</ident> are also words in
this sense, but they have the additional constraint that they must be
legal XML identifiers, as defined by the XML 1.0 specification. As
such, they may not begin with digits or punctuation characters. Legal
identifiers include <val>cholmondeley</val>, <val>été</val>,
<val>e_content</val>, or <val>xml:id</val>, but not <val>grand
wazoo</val> or <val>1234</val>. Attributes of this kind are typically used to
represent XML element or attribute names.</p>

<p>Corresponding with these two datatypes, the TEI provides
<soCalled>list</soCalled>-valued datatypes <ident type="datatype">data.words</ident>
and <ident type="datatype">data.names</ident>. These may be used to supply a list of
words or names (as defined above), each being separated by a single space. </p>

<p>Attributes of type <ident type="datatype">data.enumerated</ident>, such as
<att>anchored</att> on <gi>note</gi> have the same definition as
<ident type="datatype">data.word</ident> above, with the added semantics that the word
supplied is taken from a specific list of possibilities. In each case,
the element or class specification which includes the definition for
the attribute will also contain a list of possible values, together
with a prose description of their intended significance. This list may
be open (in which case the list is advisory), or closed (in which
case, it determines the range of legal values).</p>

<p>Attributes of type <ident type="datatype">data.code</ident> such as <att>new</att>
and <att>old</att> on <gi>handShift</gi> are similar in function, in
that they also supply encoded names for values which are defined in
more detail elsewhere. In this case, however, the full definition is
supplied as content of another XML element, typically but not
necessarily in the same document, and it is referenced by means of a
pointer. </p>

<p>Here are the specifications for these datatypes:
<specGrp xmlns:rng="http://relaxng.org/ns/structure/1.0"
	 xml:id="DTYPES-4" n="Coded value datatypes">
&data.code;
&data.enumerated;
&data.key;
&data.word;
&data.names;
&data.words;
&data.name;
</specGrp>
</p>
</div2>

<div2 xml:id="STEC"><head>The TEI Class System</head>

<p>The TEI scheme distinguishes over four hundred different elements.
To aid comprehension, modularity, and modification, the majority of
these elements are formally classified in some way.  Classes are used
to express two distinct kinds of commonality among elements.  The
elements of a class may share some set of attributes, or they may
appear in the same locations in a content model.  A class is known as
an <term>attribute class</term> if its members share attributes, and
as a <term>model class</term> if its members appear in the same
locations. In either case, an element is said to <term>inherit</term>
properties from any classes of which it is a member.  Classes may have
subclasses and superclasses, and the properties of a superclass are
inherited by all members of its subclasses.
 </p>

<p>In the RELAXNG fragments which express the TEI scheme, attribute
and model classes are represented by patterns whose names begin with
<ident>att.</ident> or <ident>model.</ident> respectively. The same
names are used in the XML DTD fragments for the parameter entities
used to implement the class system.
 </p>

<p>In both cases, the <ident type="module">tei</ident> module provides
an appropriate initial declaration for the class, so that it can
subsequently be referenced, either by a subclass, or by someone
wishing to extend the class with a new element. In the TEI DTD
fragments, each class is fully defined by its associated parameter
entity declaration; in the RELAXNG schema fragment, each class is
incrementally defined as each element declaration modifies the initial
pattern provided by the TEI infrastructure module.</p>

<p>This section describes the major element classes of each type.
 </p>

<div3 xml:id="STECAT"><head>Attribute Classes</head>

<p>An attribute class groups together elements which share some set of
common attributes.  Attribute classes are given names beginning
<code>att.</code> and are usually adjectival. For example, the members
of the class <ident type="class">att.naming</ident> have in common a
<att>key</att> attribute, which is inherited from their membership in
the class rather than individually defined for each element.  This
attribute is said to be defined by (or inherited from) the <ident
type="class">att.naming</ident> class. If another element were to be
added to the TEI scheme for which a similar <att>key</att> attribute
was considered useful, the simplest way to add it would be to make the
new element a member of the <ident type="class">att.naming</ident>
class. </p>

<p>The attributes provided by an attribute class are generally only
those specified by the class itself. However, one attribute class may
itself inherit attributes from another. For example, the attribute
class <ident type="class">att.pointing.group</ident> provides
attributes <att>domains</att> and <att>targFunc</att> to all of its
members. This class is however a subclass of the <ident
type="class">att.pointing</ident> class, from which its members also
inherit the attributes <att>type</att> and <att>evaluate</att>.
Members of the class <ident type="class">att.pointing</ident> will
thus have these two attributes, while members of the class <ident
type="class">att.pointing.group</ident> will have all four.</p>

<p>Most attribute classes are defined within the present module and
are thus globally available. Some classes are specific to particular
modules and thus defined in other chapters. Attributes defined by such
classes will not be available unless the module concerned is included
in a schema. </p>

<p>Note that some modules define classes which are superclasses of a
globally-defined class (typically <ident
type="class">att.global</ident>).  For example, the global attribute
class <ident type="class">att.divLike</ident> makes attributes
<att>org</att>, <att>uniform</att>, and <att>sample</att> available,
while the <ident type="class">att.metrical</ident> class, which is
specific to the <ident type="module">verse</ident> module, provides
attributes <att>met</att>, <att>real</att>, and
<att>rhyme</att>. Because <ident type="class">att.metrical</ident> is
defined as a superclass of <ident type="class">att.divLike</ident>,
all six of these attributes are available to <ident
type="class">att.metrical</ident> elements; the att.metrical
declaration adds its three attributes to the three already defined by
att.divLike when the <ident type="module">verse</ident> module is
included in a schema. If, however, this module is not included in a
schema the <ident type="class">att.divLike</ident> elements supplies
only the three attributes first mentioned. </p>

<p>The following lists all attribute classes declared by this module :

<!-- shd be generated -->

<table xml:id="tab-atts"><row role="label"><cell>class</cell><cell>function</cell><cell>superclass</cell></row>
<row><cell>att.ascribed</cell><cell>provides attributes for elements representing speech or action that can be ascribed to a specific individual.</cell><cell/></row>
<row><cell>att.authorialIntervention</cell><cell>provides attributes describing the nature of an authorial intervention.</cell><cell/></row>
<row><cell>att.datable</cell><cell>provides attributes for normalization of elements that contain datable events.</cell><cell/></row>
<row><cell>att.datePart</cell><cell>provides attributes for elements that contain temporal expressions.</cell><cell/></row>
<row><cell>att.declarable</cell><cell>provides attributes for those elements in the TEI Header which may be independently selected by means of  the specialpurpose decls attribute.</cell><cell/></row>
<row><cell>att.declaring</cell><cell>provides attributes for elements which may be independently associated with a particular declarable element within the header, thus overriding the inherited default for that element.</cell><cell/></row>
<row><cell>att.divLike</cell><cell>provides a set of attributes common to all elements which behave in the same way as divisions.</cell><cell>att.metrical  </cell></row>
<row><cell>att.editLike</cell><cell>provides attributes describing the nature of a encoded scholarly intervention or interpretation of any kind.</cell><cell/></row>
<row><cell>att.global</cell><cell>provides a set of attributes common to all elements in the TEI  encoding scheme.</cell><cell>att.global.linking  att.global.analytic  </cell></row>
<row><cell>att.interpLike</cell><cell>provides attributes for elements which represent a formal analysis or interpretation.</cell><cell/></row>
<row><cell>att.measured</cell><cell>provides attributes which qualify a measurement of some kind.</cell><cell/></row>
<row><cell>att.measurement</cell><cell>provides attributes to represent a regularized or normalized measurement.</cell><cell/></row>
<row><cell>att.naming</cell><cell>provides attributes common to  elements which refer to named persons, places, organizations etc.</cell><cell/></row>
<row><cell>att.placement</cell><cell>provides attributes for describing where on the source page or object a textual element appears.</cell><cell/></row>
<row><cell>att.segLike</cell><cell>provides attributes for elements used for arbitrary segmentation. </cell><cell>att.metrical  </cell></row>
<row><cell>att.spanning</cell><cell>provides attributes for elements which delimit a span of text by pointing mechanisms rather than by enclosing it.</cell><cell/></row>
<row><cell>att.tableDecoration</cell><cell>provides attributes used to decorate rows or cells of a table.</cell><cell/></row>
<row><cell>att.timed</cell><cell>provides a set of attributes common to those elements which have a duration in time, expressed either absolutely or by reference to an alignment map.</cell><cell/></row>
<row><cell>att.typed</cell><cell>provides generic attributes which can be used to classify or subclassify elements in any way. </cell><cell/></row>
</table>
</p>


<specGrp xml:id="DSTECAT" n="Attribute classes">
&att.ascribed;
&att.authorialIntervention;
&att.datable;
&att.datePart;    
&att.declarable; <!-- move to HD or CC? -->
&att.declaring; 
&att.divLike;  
&att.interpLike; <!-- shd move to analysis-decl? -->
&att.editLike; 
&att.global;
&att.measured;
&att.measurement;
&att.naming;
&att.placement;
&att.segLike; 
&att.spanning; 
&att.tableDecoration; <!-- move to FT? -->
&att.timed;   <!-- move to TS? -->
&att.typed;

</specGrp>


<p>In RELAXNG schema fragments, all attribute classes are defined as
named patterns, as shown above. For each class, one pattern combining
the class name with the suffix <code>.attributes</code> is defined,
and for each attribute supplied by membership in the class a further
pattern is defined combining the class name, the string
<code>attribute</code> and the attribute name. Thus, the class <ident
type="class">att.naming</ident> is implemented using the pattern
<ident type="pattern">att.naming.attributes</ident>, which is in turn
a reference to the pattern <ident
type="pattern">att.naming.attribute.key</ident>. The attribute
<att>key</att> supplied by the class is declared using this
pattern. </p>

<p>Members of the class inherit its definition by referring to this
pattern:
<eg><![CDATA[
name =
  element name { name.content, name.attributes }
name.content = macro.phraseSeq
name.attributes =
  att.global.attributes,
  att.naming.attributes,
  attribute type { data.enumerated }?,
  empty
]]></eg></p>
 
<p>Superclasses are implemented using the same patterns. For example,
the class <ident type="class">att.divLike</ident>, as noted above, is
a subclass of the module-specific class <ident
type="class">att.metrical</ident>. The corresponding RELAXNG pattern
for the subclass therefore includes a reference to the superclass, as
shown above. In the <ident type="module">tei</ident> module, the
pattern <ident type="pattern">att.metrical.attributes</ident> is
<term>predeclared</term> with the value <code>empty</code>; however,
if the <ident type="module">verse</ident> module is loaded, a new
definition is provided for this same pattern, which  includes the
verse-specific attributes discussed above.</p>

<p>In XML DTD fragments, the attributes shared by the members of an
attribute class are defined by a parameter entity; member elements
inherit their attributes by referring to this parameter entity within
their attribute-list declaration. The parameter entities used for this
purpose are named in the same way as the corresponding RELAXNG
patterns: they take the name of the class they define (including the
<code>att.</code> prefix), suffixed the string
<mentioned>attributes</mentioned>.  For example, the declaration for
the <ident type="class">att.naming</ident> class in the XML DTD
fragment is :

<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % att.naming.attributes '
      key  CDATA #IMPLIED'> 
]]></egXML> 
Members of the class inherit the definition by referring to this
parameter entity:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % name 'INCLUDE' >
<!ELEMENT %n.name; %om.RR;  %phrase.seq;> 
<!ATTLIST %n.name;
      %att.global.attributes;
      %att.naming.attributes;
      type CDATA #IMPLIED  >
]]></egXML>
 </p>

<p>Superclasses are also implemented using parameter entities. For
example, the parameter entity corresponding with the <ident
type="class">att.divLike</ident>  attribute class is defined as
follows:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % att.divlike.attributes '
	%att.metrical.attributes;
 type  %data.enumerated;  #IMPLIED
 org  (composite|uniform) "uniform" 
 sample  (initial|medial|final|unknown|complete) "complete" 
 part  (Y|N|I|M|F) "N" '> 
]]></egXML> 
Note the reference to <ident
type="pe">att.metrical.attributes</ident>. This parameter entity is
defined by the <ident type="module">tei</ident> module as a null
string and therefore has no effect by default. However, if
the verse module is included in a schema, the same parameter entity
will have been already declared with the following values:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % att.metrical.attributes '
 met  CDATA #IMPLIED
 real  CDATA #IMPLIED
 rhyme  CDATA #IMPLIED'> ]]></egXML>
in such a way as to over-ride this default (see further <ptr
target="#STPE"/>), thus extending the definition for <ident
type="class">att.divLike</ident>. </p>

<p>A similar mechanism is used to extend the definition for the <ident
type="class">att.global</ident>  class when certain modules are
included in the schema. The <ident type="module">tei</ident> module
provides dummy declarations for all the attribute classes listed as
<q>superclasses</q> in <ptr target="#tab-atts"/> above; the full
declaration for each such class is only operational when the module
containing it is loaded. 
</p>

</div3>
<div3 xml:id="STECCM"><head>Model Classes</head>

<p>When the members of a class are structurally similar and can appear
at the same kinds of structural locations in the document, they are
said to constitute a <soCalled>model class</soCalled>. Like attribute
classes, model classes may have subclasses or superclasses.  Just as
elements inherit from a class the ability to appear in certain
locations of a document (wherever the class can appear), so all
members of a subclass inherit the ability to appear wherever any
superclass can appear. </p>


<!-- <p>Model classes are implemented by
defining a parameter entity for use in the formal declaration of element
content models.  The parameter entity takes the name of the class it
defines, and prefixes the string <mentioned>m.</mentioned>, which can be
interpreted as <gloss>model</gloss> or as <gloss>members</gloss>.  The
replacement text of the entity is a list of the members of the class,
separated by <mentioned>|</mentioned>, the content model symbol for alternation.</p>

<p>For each class an additional entity is defined, which also takes
the name of the class, this time prefixed by the string
<mentioned>x.</mentioned> (for extension); the default value of these
<term>x-dot entities</term> is always an empty string.  A reference to
the corresponding x-dot entity is always included within the
replacement string for each m-dot entity.  This enables an encoder to
add new members to a class simply by declaring a new value for an
x-dot entity.
 </p>
<p>For example, the class <ident type="class">model.biblLike</ident> has the three
members <gi>bibl</gi>, <gi>biblFull</gi>, and <gi>biblStruct</gi>.
Its content-model entity is defined thus:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % x.bibl '' >
<!ENTITY % model.biblLike '%x.bibl; bibl | biblFull | biblStruct' >]]></egXML>
With the default value of the x-dot entity, this is the same as defining
<ident type="pe">model.biblLike</ident> with the replacement text <code>bibl | biblFull | biblStruct</code>.  If an encoder wishes
to add a new bibliographic element called <gi>my.bib</gi>, it can
be added to the <ident type="class">model.biblLike</ident> class by redefining the
x-dot entity thus:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % x.bibl 'my.bib |' >]]></egXML>
This changes the replacement text of <ident type="pe">model.biblLike</ident> from
its default value to <code>my.bib | bibl | biblFull |
biblStruct</code>.  If more than one element is to be added to a class,
the x-dot entity for the class should be redefined as a list of the new
generic identifiers, each one <emph>(including the last)</emph> followed
by a vertical bar.  The same effect could be achieved simply by
redefining the whole of the new <ident type="pe">model.biblLike</ident> entity
directly, but the x-dot method requires no repetition of the already
existing members of the class and thus minimizes the chance of error.
 </p>
<p> Superclasses transmit their location characteristics to their
subclasses by referring, in declaring their m-dot entity, to the m-dot
entities of the subclasses.
 </p>
<p>For example, the class <ident type="class">model.phrase</ident> includes the
classes <ident type="class">model.pPart.data</ident>, <ident type="class">model.pPart.edit</ident>,
<ident type="class">model.hiLike</ident>, <ident type="class">model.ptrLike</ident>, and
<ident type="class">model.segLike</ident> as members, as can be seen in the
declaration for its m-dot entity:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % class.phrase "%x.class.phrase; %class.data; | %class.edit;
 | %class.formPointers; | %class.hqphrase; | %class.loc; 
 | %class.oddPhr; | %class.phrase.verse; | %class.seg; | %n.formula; 
 | %n.handShift;">]]></egXML>
 When the entity <ident type="pe">model.phrase</ident> is referred to in
content models, all members of all subclasses are included in the model.
 </p>


</div3>


<div3 xml:id="STECOV"><head>High-level structural element classes</head>

-->

<p>The TEI class system is structured around the following threefold
division of elements:
<list type="gloss"><label><term>chunks</term> </label>
<item>elements such as paragraphs and other
paragraph-level elements, which can appear directly within texts or
within text subdivisions (i.e. <gi>div</gi> elements), but not within
other chunks</item><label><term>phrase-level elements</term> </label>
<item>elements such as
highlighted phrases, book titles, or editorial corrections which can
occur only within chunks (paragraphs or paragraph-level elements), but
not between them (and thus cannot appear directly within a
<gi>div</gi>)<note place="foot">Note that in this context, <term>phrase</term> means
any string of characters, and can apply to individual words, parts of
words, and groups of words indifferently; it does not refer only to
linguistically motivated phrasal units.  This may cause confusion for
readers accustomed to applying the word in a more restrictive sense.</note></item>
<label><term>inter-level elements</term></label>
<item>elements such as lists,
notes, quotations, etc. which can appear either between chunks (as
children of a <gi>div</gi>) or within them</item></list>
 </p>
<p>Together the two sets of <term>chunks</term> and <term>inter-level
elements</term> make up the set of:
<list type="gloss"><label><term>text components</term> </label>
<item>elements which can appear
directly within texts or text divisions; also called simply
<term>components</term> or <soCalled>component-level elements</soCalled></item></list>
In general, the body of any text comprises a series of components,
optionally grouped into <gi>div</gi> elements.
 </p>
<p>Some elements belong to none of these classes; these include
high-level structural elements like <gi>TEI</gi> and
<gi>group</gi> as well as some specialized elements which appear only
within particular structures (like <gi>analytic</gi>,
<gi>monographic</gi>, and <gi>series</gi>).  The majority of elements
found in normal running text, however, are assigned  to
one or the other of these classes.
 </p>
<p>Some <term>macro.component</term> elements (e.g. <gi>p</gi> or
<gi>note</gi>) are common to all modules, while others are unique
to individual modules.  
</p>
</div3>

<div3 xml:id="STECLO"><head>Low-Level Element Classes</head>
<p>The following low-level classes group together sets of semantically
or structurally similar elements.  These classes may include both
elements in the core and elements declared in particular modules; a
reference is given at least to the relevant section on the core tags.
 </p>
<p>The following are phrase-level element classes:
<specList>
<specDesc key="model.biblLike"/>
<specDesc key="model.dateLike"/>
<specDesc key="model.global"/>
<specDesc key="model.graphicLike"/>
<specDesc key="model.hiLike"/>
<specDesc key="model.listLike"/>
<specDesc key="model.measureLike"/>
<specDesc key="model.noteLike"/>
<specDesc key="model.pPart.data"/>
<specDesc key="model.pPart.edit"/>
<specDesc key="model.pPart.msdesc"/>
<specDesc key="model.ptrLike"/>
<specDesc key="model.ptrLike.form"/>
<specDesc key="model.qLike"/>
<specDesc key="model.segLike"/>
<specDesc key="model.timeLike"/>
</specList>
</p>

<p>Here are the formal declarations for the generally-available model classes;

<!-- specGrp xml:id="DSTECLO" n="Primitive Lowlevel classes"-->

these classes refer only to elements:

&model.nameLike.agent;
&model.segLike;
&model.hiLike;
&model.dateLike;
&model.timeLike;
&model.measureLike;
&model.graphicLike;
&model.pPart.msdesc;  <!-- model.pPartMsdesc -->
&model.pPart.edit; 
&model.ptrLike;  
&model.lPart;
&model.global.meta; 
&model.milestoneLike; 
&model.gLike;
&model.oddDecl;
&model.oddRef;
&model.oddPhr;

<!-- inter level -->

&model.qLike;
&model.biblLike;
&model.listLike;
&model.noteLike;
&model.stageLike;
&model.complexVal;
&model.singleVal;
&model.entryParts.top;
&model.global.edit;

&model.divPart;
&model.blockLike;
&model.pLike; 

&model.persTraitLike;
&model.persStateLike;
&model.persEventLike;
&model.assertLike;
&model.personPart;

&model.publicationStmtPart;
&model.glossLike;
&model.quoteLike;
&model.respLike;
&model.divWrapper.bottom;
&model.divWrapper;
&model.frontPart.drama;
&model.pLike.front;
&model.titlepagePart;
&model.msItemPart;
&model.choicePart;
&model.lLike;
&model.recordingPart;
&model.imprintPart;
&model.catDescPart;

&model.settingPart;
&model.textDescPart;
&model.castItemPart;
&model.physDescPart;
<!--/specGrp-->

<specGrp xml:id="DSTECLO-1" n="level 1 classes">
<p>These classes refer only to primitive lowlevel classes or to elements</p>
&model.nameLike;
&model.global;
&model.featureVal;
&model.common;
&model.biblPart;
&model.datePart;
&model.frontPart;
</specGrp>
<specGrp xml:id="DSTECLO-2" n="level 2 classes">
<p>These classes refer only to level 1 or to primitive lowlevel
classes or to elements</p>
&model.addrPart;
&model.pPart.data;
&model.inter;
</specGrp>
</p>
</div3>
<div3 xml:id="STECHI"><head>High-Level Element Classes</head>
<p>The following element classes are used to implement the threefold
structural distinction among phrases, chunks, and intermediate elements
discussed above in section <ptr target="#STECCM"/>.  In this terminology,
<term>chunk</term>s (or <term>chunk elements</term>) are elements which
can occur only in chunk-level sequences (e.g. between but not within
paragraphs); <term>inter-level elements</term> can occur either within
chunks (at phrase-level) or between chunks (e.g. at paragraph-level),
and <term>phrase-level elements</term> can occur only at phrase level,
within chunks (e.g. within but not between paragraphs).
 </p>
<p>The element class <ident type="class">model.common</ident> includes all
component-level (chunk- and inter-level) elements <!-- common to more than
one base.  It is used in implementing the combined bases described in
section <ptr target="#STECMX"/>.-->
  </p>
<p>The relevant declaration looks like this:
<specGrp xml:id="DSTECHI" n="Common high-level classes">
<!-- model.phrase--> &model.phrase;
</specGrp>
</p></div3>
<div3 xml:id="STECMK"><head>Elements Marked for Text Type</head>
<p>The following element classes are used to group together
component-level elements which are allowed only in texts of a particular
type (i.e. texts using a specific module).
<specList>
<specDesc key="model.divPart.spoken"/>
<specDesc key="model.divPart.stage"/>
<specDesc key="model.divPart.verse"/>
<specDesc key="model.entryLike"/>
<!-- specDesc key="tei.comp.terminology"/-->
</specList>
 </p>
<p>Declarations for these module-specific element classes are included
in a separate <ident type="module">-decls</ident> schema fragment when
XML DTDs are used. In  RELAXNG  schema fragments, the corresponding
declarations are given at the start of the same schema fragment as the
other declarations. </p></div3>

<div3 xml:id="STECMI"><head>Miscellaneous Content-Model Classes</head>
<p>The following element classes occupy specific places in content
models; most are relevant only when certain modules are selected
<specList>
<specDesc key="model.addrPart"/>
<specDesc key="model.biblPart"/>
<specDesc key="model.castItemPart"/>
<specDesc key="model.datePart"/>
<specDesc key="model.choicePart"/>
<specDesc key="model.divWrapper"/>
<specDesc key="model.divWrapper.bottom"/>
<specDesc key="model.frontPart"/>
<specDesc key="model.frontPart.drama"/>
<specDesc key="model.glossLike"/>
<specDesc key="model.imprintPart"/>
<specDesc key="model.lLike"/>
<specDesc key="model.msItemPart"/>
<specDesc key="model.nameLike.agent"/>
<specDesc key="model.pLike.front"/>
<specDesc key="model.persNamePart"/>
<specDesc key="model.personPart"/>
<specDesc key="model.physDescPart"/>
<specDesc key="model.placeNamePart"/>
<specDesc key="model.publicationStmtPart"/>
<specDesc key="model.quoteLike"/>
<specDesc key="model.recordingPart"/>
<specDesc key="model.respLike"/>
<specDesc key="model.settingPart"/>
<specDesc key="model.stageLike"/>
<specDesc key="model.textDescPart"/>
<specDesc key="model.titlepagePart"/>
</specList>
 </p>
</div3>


</div2>

<div2 xml:id="STmacros"><head>Macros</head>

<p>The <ident type="module">tei</ident> module also declares a number
of <term>macros</term>, which are used for two distinct purposes in the
TEI scheme. Firstly, macros are used to stand for
frequently-encountered content models, or parts of content models
(<ptr target="#STECST"/>); secondly, they are used to enable some
components of other macros to be defined in a way that permits their
significance to vary depending on the collection of modules in use
(<ptr target="#STECMX"/>). In both cases, macros are implemented in
the same way: as patterns in the RELAXNG schema fragments, and as
parameter entities in the XML DTD  fragments.</p>

<div3 xml:id="STECST"><head>Standard Content Models</head>
<p>As far as possible, the TEI schemas use the following set of
frequently-encountered content models to help achieve consistency among
different elements.
<specList>
<specDesc key="macro.bodyPart.div"/>
<specDesc key="macro.bodyPart.div0"/>
<specDesc key="macro.bodyPart.div1"/>
<specDesc key="macro.bodyPart.main"/> <!-- references pre -->
<specDesc key="macro.bodyPart.pre"/>
<specDesc key="macro.component"/>
<specDesc key="macro.componentSeq"/>
<specDesc key="macro.fileDescPart"/>
<specDesc key="macro.glossSeq"/>
<specDesc key="macro.paraContent"/>
<specDesc key="macro.phraseSeq"/>
<!-- specDesc key="macro.phrasegroup"/-->
<specDesc key="macro.schemapattern"/>
<specDesc key="macro.specialPara"/>
<specDesc key="macro.xtext"/>
</specList>
</p>

<p>The body part macros are declared as follows:
<specGrp xml:id="DSTECST" n="Standard Content Models">
&macro.bodyPart.div;
&macro.bodyPart.div0;
&macro.bodyPart.div1;
&macro.bodyPart.pre;
&macro.bodyPart.main; <!-- references pre -->
</specGrp>

</p>

<p>The component part macros reference the special purpose
<soCalled>mix-in</soCalled> macros <!-- ; the latter must therefore be
declared first:-->

<!--
<specGrp xml:id="DSTECMX" n="Definition of components for combined bases">
<p>Default declarations for the mix-ins used in the definition of macro.component</p>
&drmixxx.odd; 
&tsmixxx.odd;
&dimixxx.odd;
</specGrp>
-->
(see further <ptr target="#STECMX"/>). They are declared as follows:

<!-- specGrpRef target="#DSTECMX"/--> 
<specGrp>
&macro.component;
&macro.componentSeq;
&macro.paraContent;
&macro.phraseSeq;
&macro.specialPara;
&macro.xtext;
&macro.fileDescPart;
&macro.glossSeq;

</specGrp>
 </p></div3>

<div3 xml:id="STECMX"><head>Module-specific Components</head>

<p>The macro <ident type="macro">macro.component</ident> is defined as
the concatenation of a number of other macros and its actual meaning
will differ, depending on which modules are in use. This effect is
achieved by indirection; the macro value refers to the following
special-purpose macros:

<specList>
<specDesc key="mix.dictionaries"/>
<specDesc key="mix.drama"/>
<specDesc key="mix.spoken"/>
</specList></p>

<p>These <soCalled>mix-in</soCalled> macros are defined differently in
different modules. In the <ident type="module">tei</ident> module,
they are all defined as the null string. In the modules after which
they are named, however, each one references a class of elements
defined by that module which are to be mixed into the component macro,
but only if the module in question is included.</p>

<p>For example, when the drama module is included in a schema, the
macro <ident>mix.drama</ident> references the class
<code>model.divPart.stage</code>, so that members of that class will
be included when  <ident>macro.component.seq</ident> is evaluated.
</p>
<!-- cannot yet face explaining why there is an | in the dtd version
and not the relaxng one -->

<p>
</p>
</div3>

</div2>


<div2 xml:id="STPE"><head>TEI DTD-specific mechanisms</head>

<p>The TEI DTD fragments use parameter entities for several purposes:
<list type="bullets">
<item>as a way of implementing attribute classes</item>
<item>as a way of implementing extensible model classes</item>
<item>as a way of selecting modules to include within a schema</item>
<item>as a way of including or excluding  elements from a schema</item>
<item>as a way of renaming elements</item>
<item>as a way of representing  tag omissibility information within
an SGML DTD</item>
</list>
The use of parameter entities in implementing classes was  described above in
section <ptr target="#STEC"/>.  In the remainder of this section we
briefly describe the other uses of parameter entities in the TEI DTD fragments.
 </p>

<div3 xml:id="STPED"><head>Selection of DTD fragments</head>

<p>Special-purpose parameter entities are used to specify which
modules are to be combined into a TEI DTD. They take the
form <val>TEI.xxxxx</val> where <code>xxxx</code> is the name of the
module as given in  table <ptr target="#tab-mods"/> in <ptr
target="#STMA"/> above. For example, the
parameter entity <ident type="pe">TEI.linking</ident> is used to
define whether or not to include the module <ident
type="module">linking</ident>. All such parameter entities are
declared by default with the value <val>IGNORE</val>:  to select a
module, therefore, the encoder declares the appropriate parameter entities with the
value <val>INCLUDE</val>. 
</p>
<p>The parameter entity concerned is used as the keyword  controlling
a conditional marked section
in the DTD fragment generated by the <ident type="module">tei</ident> module. The declarations
for each  DTD fragment constituting the module are contained within such  marked
sections. For example, the parameter entity <ident
type="pe">TEI.linking</ident> appears twice  in <ident
type="file">tei.dtd</ident>, once for the <ident
type="frag">linking-decl</ident> schema fragment:
<eg><![CDATA[
<!ENTITY % file.linking-decl 
   PUBLIC '-//TEI P5//ENTITIES Linking, Segmentation, and Alignment//EN' 
   'linking-decl.dtd' >
<![%TEI.linking;[ %file.linking-decl; ]&nil;]>
]]></eg>
and once for the <ident
type="frag">linking</ident> schema fragment:
<eg><![CDATA[
<![%TEI.linking;[
<!ENTITY % file.linking 
   PUBLIC '-//TEI P5//ELEMENTS Linking, Segmentation, and Alignment//EN' 
  'linking.dtd' >
%file.linking; ]&nil;]>
]]></eg>
If TEI.linking has its default value of IGNORE, neither declaration has
any effect. If however it has the value INCLUDE, then the content of
each marked section is acted upon: the parameter entities <ident
type="pe">file.linking</ident> and <ident
type="pe">file.linking-decl</ident> are referenced, which
has the effect of embedding the content of the files they represent at
the appropriate point in the DTD. </p>
</div3>


<div3 xml:id="STPEEX"><head>Inclusion and Exclusion of Elements</head>

<p>The TEI DTD fragments also use marked sections and parameter entity
references to allow users to exclude the definitions of individual
elements, in order either to make the elements illegal in a document
or to allow the element to be redefined. The parameter entities used
for this purpose have exactly the same name as the generic identifier
of the element concerned.  The default definition for these parameter
entities is <val>INCLUDE</val> but they may be changed to
<val>IGNORE</val> in order to exclude the standard element and
attribute definition list declarations from the DTD.
 </p>

<p>The declarations for the element <gi>p</gi>, for example, are
preceded by a definition for a parameter entity with the name
<ident rend="noindex" type="ge">p</ident> and contained within a marked
section whose keyword is
given as <code>%p;</code>:
<eg><![CDATA[<!ENTITY % p 'INCLUDE' >
<![ %p; [
       <!-- element and attlist declaration for p here -->
]]]]></eg></p><p>These parameter entities are defined immediately preceding the
element whose declarations they control; because their names are
completely regular, they are not documented further.
 </p>
<p>To define a DTD in which the element <gi>p</gi> is excluded
therefore, the entity <ident rend="noindex" type="pe">p</ident> needs
to be redefined as <val>IGNORE</val> by ensuring that a declaration
such as
<eg><![CDATA[<!ENTITY % p 'IGNORE' >]]></eg>
is added earlier in the DTD than the default (see further <ptr target="#STOVLO"/>). </p>

<p>In the RELAXNG schemas, every element is defined by a pattern named
after the element. To undefine an element therefore all that is
necessary is to add a declaration like the following:

<eg><![CDATA[ p = notAllowed ]]></eg>
</p></div3>

<div3 xml:id="STPEGI"><head>Parameter Entities for Element Generic Identifiers</head>

<p>In the TEI DTD fragments, elements are not referred to directly by
their generic identifiers; instead, the DTD fragments refer to
parameter entities which expand to the standard generic identifiers.
This allows users to rename elements by redefining the appropriate
parameter entity.  Parameter entities used for this purpose are formed
by taking the standard generic identifier of the element and attaching
the string <q>n.</q> as a prefix.  Thus the standard generic
identifiers for paragraphs, notes, and quotations, <gi>p</gi>,
<gi>note</gi>, and <gi>q</gi> are defined by declarations of the
following form: <egXML
xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % n.p "p">
<!ENTITY % n.pb "pb"> <!ENTITY % n.persName "persName">]]></egXML>
Since all names in the TEI DTD are case-sensitive, the specific mix of
upper and lower case letters in the standard generic identifier must
be preserved in the entity name.
 </p>
<p>These declarations are automatically generated by an ODD processor
when  TEI DTD fragments are created. </p>
<p> In the RELAXNG schemas, all elements are defined using a pattern
with the same name as the element: for example
<eg><![CDATA[
abbr = element abbr { abbr.content, abbr.attributes }
]]></eg>
The easiest way of renaming the element is thus simply to declare a
new pattern:
<eg><![CDATA[
abbrev = element abbr { abbr.content, abbr.attributes }
]]></eg>
More complex revisions, such as redefining the content of the element
(defined by the pattern <ident type="rng">abbr.content</ident>) or its
attributes (defined by the pattern <ident
type="rng">abbr.attributes</ident>) can be accomplished in a similar
way, using the features of the RELAXNG language. The recommended
method of carrying out such modifications is however to use the ODD
language as further described in section <ptr target="#TD"/>.</p>
</div3>


<div3 xml:id="STOVLO"><head>Embedding Local Modifications</head>

<p>Any local modifications (i.e. changes to a schema other than simple
inclusion or exclusion of modules) are made by declarations stored in
one of two local extension files, one containing modifications to the
TEI parameter entities, and the other new or changed declarations of
elements and their attributes.  Entity declarations must be made
associating the names of these two files with the appropriate
parameter entity so that the declarations they contain can be embedded
within the TEI DTD at an appropriate point.</p>

<p>The following entities are referred to by the main
<ident type="file">tei.dtd</ident> file to embed portions of the TEI DTD fragments
or locally developed extensions.
<list type="gloss"><label><ident type="pe">TEI.extensions.ent</ident></label>
<item>identifies a local file containing
extensions to the TEI parameter entities</item>
<label><ident type="pe">TEI.extensions.dtd</ident></label>
<item>identifies a local file containing
extensions to the TEI module</item>
</list></p>
<p>For example, if the relevant files are called <ident rend="noindex"
type="file">project.ent</ident> and <ident rend="noindex"
type="file">project.dtd</ident>, then declarations like the following
would be appropriate:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % TEI.extensions.ent SYSTEM 'project.ent' >
<!ENTITY % TEI.extensions.dtd SYSTEM 'project.dtd' >]]></egXML></p>

<p>When an entity is declared more than once, the first declaration is
binding and the others are ignored.  The local modifications to
parameter entities should therefore be handled before the standard
parameter entities themselves are declared in <ident
type="file">tei.dtd</ident>.  The entity <ident
type="pe">TEI.extensions.ent</ident> is referred to before any TEI
declarations are handled, to allow the user's declarations to take
priority.  If the user does not provide a <ident
type="pe">TEI.extensions.ent</ident> entity, the entity will be expanded
to the empty string.</p>
<p>For example the encoder might wish to add two phrase-level elements
<gi>it</gi> and <gi>bd</gi>, perhaps as synonyms for
<tag>hi rend='italics'</tag> and <tag>hi rend='bold'</tag>.  As
described in chapter <ptr target="#MD"/>, this involves two distinct steps:
one to define the new elements, and the other to ensure that they are
placed into the TEI document structure at the right place.  We deal with
the second first, by specifying the element class to which the new
elements should be attached.  To do this, the parameter entity
<ident type="pe">x.phrase</ident> should be modified to include the two
new generic identifiers.  The file containing local declarations of the
standard parameter entities will thus contain a declaration of the
following form:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % x.phrase 'it | bd |' >]]></egXML></p>
</div3>

<div3 xml:id="STXML"><head>Generation of SGML or XML DTD fragments </head>

<p>The DTD fragments generated by the Guidelines may be used in either
SGML or XML mode.</p>

<p>Only two SGML tag omissibility indicators are used in the TEI
Guidelines: <code>- O</code> (i.e., the end-tag may be omitted but not
the start-tag); and <code>- -</code> (i.e. neither start- nor end-tag
may be omitted). Two parameter entities are defined, one called <ident
type="pe">om.RO</ident> (<q>omissibility-required-optional</q>), and
the other called <ident type="pe">om.RR</ident>
(<q>omissibility-required-required</q>). Content models in the text of
the Guidelines and in generated DTD fragments always reference the
omissibility information by means of one or the other of these
parameter entities. </p>

<p>In XML mode (the default), tags are never omissible and
omissibility indicators are syntactically invalid. In an XML DTD,
therefore these parameter entities must be redefined as the null
string. This is done by means of a second set of declarations
controlled by a marked section guarded by the <ident
type="pe">TEI.XML</ident> parameter entity.  If the user declares a
parameter entity TEI.XML with the value IGNORE in the DTD subset, then
these redefinitions will not be processed, so that the resulting DTD
is SGML conformant. In SGML mode, the value for each of these
parameter entities is the appropriate indicator. </p>
</div3>
</div2>
</div1>

<?xml version="1.0" encoding="utf-8"?>
<div xml:id="IM" xmlns="http://www.tei-c.org/ns/1.0">
<head>Implementation of an ODD System</head>
<p>This chapter specifies how a processing system may take advantage
of the markup specification elements documented in chapter <ptr
target="#TD"/> of these Guidelines in order to produce
project specific user documentation, 
schemas in one or more schema languages, and 
validation tools for other processors.</p>

<p>The specifications in this chapter are illustrative but not
normative. Its function is to further illustrate the intended scope
and application of the elements documented in chapter <ptr
target="#TD"/>, since it is believed that these may have application
beyond the areas directly addressed by the TEI.</p>

<p>An ODD processing system  has two tasks to undertake.
Firstly, the application of changes and additions in an ODD customization
(as described in <ptr target="#MD"/>) to the TEI P5 ODD specification
through a process of selection,  merging and deletion. Secondly,
the conversion of the resulting unified ODD to the desired output.</p>

<p>An ODD processor is not mandated to do these two stages in sequence,
but that can be a convenient way to simplify the second part of the
work; this is how the tools used for the TEI Guidelines work.</p>

<div xml:id="IM-unified">
<head>Making a unified ODD</head>
<p>Merging an ODD customization with the  TEI P5 ODD specification
is driven by a <gi>schemaSpec</gi> element, which specifies
the name and default namespace of the result. The content
can be of four types:
<list type="ordered">
<item><gi>elementSpec</gi>, <gi>classSpec</gi> or <gi>macroSpec</gi>
elements; these must have a <att>mode</att> attribute which determines
how they will be processed.<note>We do not here say what happens in
case of errors; a specification in <val>add</val> mode which is also
present in an imported module should obviously be flagged as an
error.</note> If the value of <att>mode</att> is <val>add</val>, then
the object is simply copied to the output, but if it is
<val>change</val>, <val>delete</val>, or <val>replace</val>, then it
will be looked at by other parts of the process.</item>

<item><gi>specGrpRef</gi> pointers to <gi>specGrp</gi> groups
elsewhere in this, or another, document. A <gi>specGrp</gi> is used to
hold chunks of ODD markup at the points in documentation where they
are discussed, rather than being forced to put them all inside
<gi>schemaSpec</gi>. The pointer to any such groups should be
followed, and <gi>elementSpec</gi>, <gi>classSpec</gi> or
<gi>macroSpec</gi> elements in the <gi>specGrp</gi> be processed as
described in the previous item.</item>

<item><gi>moduleRef</gi> elements which refer to components
of the TEI, using the <att>key</att> attribute. This reference
must be satisfied by some means, such as reading an XML
file with the TEI ODD specification, or looking up the reference
in an XML database; whatever means is used, it should return a stream
of XML containing the elements, classes and macros belonging to the
specified module. These elements can then be checked against overrides in
the <gi>schemaSpec</gi> being processed.</item>

<item><gi>moduleRef</gi> elements which refer to external
schemas written in RELAX NG, using the <att>url</att> attribute.
These will remain untouched, and passed directly to the output
schema when that is created.
</item>
</list>
</p>

<p>Each object obtained from the TEI ODD specification using
<gi>moduleRef</gi> must be checked against objects in the
customization <gi>schemaSpec</gi> according to the following rules:
<list type="ordered">
<item>if there is an object  in the ODD customization with the same value for the
<att>ident</att> attribute, and a <att>mode</att> value of
<att>delete</att>,
then the object from the module is ignored</item>
<item>if there is an object  in the ODD customization with the same value for the
<att>ident</att> attribute, and a <att>mode</att> value of
<att>replace</att>,
then the object from the module is ignored, and the one
from the ODD customization is used in its place</item>
<item>if there is an object  in the ODD customization
with the same value for the
<att>ident</att> attribute, and a <att>mode</att> value of
<att>change</att>,
then the two objects must be merged, as described below</item>
<item>otherwise, the object from the module is copied to the result</item>
</list>
</p>

<p>To merge two objects with the same <att>ident</att>,
each component (attributes and child elements) must be
looked at, recursively. They can be of four types:
<list type="ordered">

<item>objects which can only occur once (attributes,
and <gi>altIdent</gi>,
<gi>content</gi>, and <gi>classes</gi> elements) are taken from the
ODD customization if present there, otherwise from the TEI ODD
specifification.
</item>

<item>grouping objects (<gi>attList</gi>, <gi>valList</gi>)
are copied, and their children processed using these rules</item>

<item>objects which can occur multiple times, but have no
identification (<gi>equiv</gi>, <gi>desc</gi>, <gi>gloss</gi>,
<gi>exemplum</gi>, <gi>remarks</gi>, <gi>listRef</gi> in elements and
macros, and <gi>datatype</gi> and <gi>defaultVal</gi> in attributes),
should be copied from both the TEI ODD specification and the ODD
customization, and all included in the output</item>

<item>identified objects (i.e. those with an <att>ident</att>
attribute, i.e. <gi>attDef</gi> and <gi>valItem</gi>) 
are processed according to their <att>mode</att> attribute, following
the rules in this list.</item>
</list>
</p>
<p>A special problem arises with elements which are members of
attribute classes, as they are permitted to override attributes
inherited from a class. For example, consider this simple element:
<egXML xmlns="http://www.tei-c.org/ns/Examples">
<elementSpec ident="p">
  <classes>
    <memberOf key="att.typed"/>
  </classes>
  <content>
  <!--…-->
  </content>
</elementSpec>
</egXML>
The affect of the <val>att.typed</val> class is to provide <gi>p</gi>
with a <att>type</att> attribute and a <att>subtype</att>
attribute. If
we wish <gi>p</gi> to <emph>not</emph> have <att>subtype</att>, we
could extend the customization in our schema as follows:
<egXML xmlns="http://www.tei-c.org/ns/Examples">
<elementSpec ident="p">
  <classes>
    <memberOf key="att.typed"/>
  </classes>
  <content>
  <!--… -->
  </content>
  <attList>
    <attDef ident="subtype" mode="delete"/>
  </attList>
</elementSpec>
</egXML>
This means that when <code><![CDATA[<memberOf
key="att.typed"/>]]></code> is processed, that class is looked up,
each attribute which it defines is examined in turn, and
the customization is searched for  an override. 
If the modification is of
the attribute class itself, work proceeds as usual; if, however, the
modification is at the element level, the class reference is deleted
and a series of <gi>attRef</gi> elements is added to the element, one for
each attribute inherited from the class. Since attribute classes can
themselves be members of other attribute classes, membership must be
followed recursively.</p>

<p>The effect of the concatenation of unidentifiable components should
be considered carefully. An original may have
<egXML xmlns="http://www.tei-c.org/ns/Examples">
<elementSpec ident="p">
  <desc>marks paragraphs in prose.</desc>
  <!--…-->
</elementSpec>
</egXML>
which would usefully be extended with this:
<egXML xmlns="http://www.tei-c.org/ns/Examples">
<elementSpec ident="p" mode="change">
  <desc xml:lang="es">marca párrafos en prosa.</desc>
  <!--…-->
</elementSpec>
</egXML>
to provide an alternate description in another language.
Nothing prevents the user from supplying <gi>desc</gi> several times
in the same language, and subsequent applications will have to 
decide what that may mean. </p>

<p>Multiple examples, possibly in different languages, are easier to
deal with. Note that since the <gi>exemplum</gi> element is not
identifiable, examples can only be deleted by supplying an entire new
<gi>elementSpec</gi> in <val>replace</val> mode.</p>

<p>When processing the content models of elements, and the content of
macros, the processor has to decide whether to take account of deleted
elements.<note>The carthago program behind the PizzaChef application,
written by Michael Sperberg-McQueen for TEI P3 and P4, went to very
great efforts to get this right. The tools behind the P5 Roma
application are not as sophisticated, partly because the RELAX NG
language is more forgiving than DTDs.</note> A content model like this:
<egXML xmlns="http://www.tei-c.org/ns/Examples">
<elementSpec ident="person">
  <!--…-->
  <content>
    <rng:choice xmlns:rng="http://relaxng.org/ns/structure/1.0">
      <rng:oneOrMore>
        <rng:ref name="model.pLike"/>
      </rng:oneOrMore>
      <rng:zeroOrMore>
        <rng:choice>
          <rng:ref name="model.personPart"/>
          <rng:ref name="model.global"/>
        </rng:choice>
      </rng:zeroOrMore>
    </rng:choice>
  </content>
  <!--…-->
</elementSpec>
</egXML>
probably requires no special treatment, as everything is expressed in
terms of model classes; if <val>model.personPart</val> is empty, the
<gi>choice</gi> is simply <att>model.global</att>. An ODD processor
may choose to simplify that by removing the wrapper RELAX NG
<gi>choice</gi> element. However, if that <gi>choice</gi> is itself
inside an <gi>zeroOrMore</gi> inside a <gi>group</gi>, the simplifying
process may be harder, and the resolution is left to a later stage. If
an element refers directly an element child, like this:
<egXML xmlns="http://www.tei-c.org/ns/Examples">
<elementSpec ident="figure">
  <!--…-->
  <content>
    <rng:zeroOrMore xmlns:rng="http://relaxng.org/ns/structure/1.0">
      <rng:choice>
        <rng:ref name="model.pLike"/>
        <rng:ref name="model.global"/>
        <rng:ref name="figure"/>
        <rng:ref name="figDesc"/>
        <rng:ref name="model.graphicLike"/>
        <rng:ref name="model.headLike"/>
      </rng:choice>
    </rng:zeroOrMore>
  </content>
  <!--…-->
</elementSpec>
</egXML>
and <gi>figDesc</gi> has been deleted,<note>Note that deletion of some
elements, if they are not optional in the original specification, will
cause the schema specification to be not suitable for validating TEI
Documents, since they break the TEI abstract model; conformance topics
are addressed in more detail in <ptr target="#CF"/>.</note> it will be
necessary to remove that reference, or the resulting schema will be
invalid.  Surrounding constructs, such as a <gi>zeroOrMore</gi>, may
also have to be consequentially removed.</p>

<p>The result of the endeavours above will be a new
<gi>schemaSpec</gi> which contains a flat set of element, class and
macro specifications, along with any <gi>moduleRef</gi>
elements with <att>url</att> attributes identifying external
schemas.</p>

</div>

<div>
<head>Generating schemas</head>
<p>Assuming that any modifications have been resolved, as outlined in
the previous section, making a schema is four-fold task. Firsly, we
must collect all datatype and other macro specifications, and declare
them at the start of the output schema. Secondly, we must declare all
classes. Thirdly, we declare the elements. Lastly, we process any
<gi>moduleRef</gi> elements with a <att>url</att> attribute
identifying an external schema. Working in this order giving the best
chance of working with all the schema languages. However, there are a
a number of obstacles to overcome along the way.</p>

<p>Firstly, a decision must be made about which schema language is
going to be used. The TEI ODD specification, using RELAX NG to express
content models, is slightly biased towards this language, and the
processing of these Guidelines adopts the following tactics:
<list>

<item>A RELAX NG (XML) schema is generated by creating 
wrappers around the content models direct from the ODD specification;
a RELAX NG compact version is generated using
James Clark's <ident>trang</ident> application.</item>

<item>A DTD schema is generated by converting the RELAX NG
content models to DTD language, often simplifying it to 
allow for the less-sophisticated output language</item>

<item>A W3C Schema schema is created by generating a RELAX NG schema
and then using James Clark's <ident>trang</ident> application.</item>
</list>
Note that the method of generated W3C Schema means that
a processor must ensure that the RELAX NG it generates
follows the subset which <ident>trang</ident> is able to
translate properly — this may involve simple trial and error.</p>

<p>Other projects may decide to follow a different route, perhaps
implementing a direct ODD to W3C Schema translator.</p>

<p>Secondly, it is possible to create two rather different styles of
schema. On the one hand, the schema can try to maintain all the
flexibility of ODD by using the facilities of the schema language for
parameterization; on the other, it can remove all customization
features and produce a flat result which is not suitable for further
manipulation. The TEI project generates both styles of schema; the
first as a set of schema fragments in DTD and RELAX NG languages,
which can be included as modules in other schemas, and customized
further; the second as the output from the Roma processors, which
produce single file schemas in as simple a style as possible.</p>

<p>The difference between the schema styles may be illustrated by
considering this ODD specification:
<egXML xmlns="http://www.tei-c.org/ns/Examples">
<elementSpec module="drama" ident="performance">
  <!--..-->
  <classes>
    <memberOf key="model.frontPart.drama"/>
  </classes>
  <content>
    <rng:group xmlns:rng="http://relaxng.org/ns/structure/1.0">
      <rng:zeroOrMore>
        <rng:choice>
          <rng:ref name="model.divWrapper"/>
          <rng:ref name="model.global"/>
        </rng:choice>
      </rng:zeroOrMore>
      <rng:oneOrMore>
        <rng:group>
          <rng:ref name="model.common"/>
        </rng:group>
        <rng:zeroOrMore>
          <rng:ref name="model.global"/>
        </rng:zeroOrMore>
      </rng:oneOrMore>
      <rng:zeroOrMore>
        <rng:group>
          <rng:ref name="model.divWrapper.bottom"/>
        </rng:group>
        <rng:zeroOrMore>
          <rng:ref name="model.global"/>
        </rng:zeroOrMore>
      </rng:zeroOrMore>
    </rng:group>
  </content>
</elementSpec>
</egXML>
A simple rendering to RELAX NG produces this:
<eg>
performance =
 element performance { 
  (model.divWrapper | model.global)*,
  (model.common, model.global*)+,
  (model.divWrapper.bottom, model.global*)*
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.global.linking.attribute.corresp,
  att.global.linking.attribute.synch,
  att.global.linking.attribute.sameAs,
  att.global.linking.attribute.copyOf,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.global.linking.attribute.exclude,
  att.global.linking.attribute.select
}
</eg>
In this, the knowledge that the attributes such as <att>n</att> and
<att>rend</att> come from the global attribute class is lost, and
there is easy way for another  schema to modify the element. A
parameterized version may look this this:
<eg>
performance =
  element performance { performance.content, performance.attributes }
performance.content =
  (model.divWrapper | model.global)*,
  (model.common, model.global*)+,
  (model.divWrapper.bottom, model.global*)*
performance.attributes = att.global.attributes, empty
</eg>
Here, the class attributes are provided with a pointer (allowing
for redefinition of the class), and the attributes are separated from
the content model, allowing either to be overridden.</p>
<p>In the remainder of these chapter, the terms 
<term>simple schema</term> are <term>parameterized schema</term>
are used to distinguish the two schema types. An ODD processor
is not mandated to support both.</p>

<p>Lastly, the problem of missing
components must be resolved. For example, consider this (simplified) model
for <gi>sp</gi>:
<egXML xmlns="http://www.tei-c.org/ns/Examples">
<elementSpec ident="sp">
  <!--…-->
  <content xmlns:rng="http://relaxng.org/ns/structure/1.0">
    <rng:zeroOrMore>
      <rng:ref name="model.global"/>
    </rng:zeroOrMore>
    <rng:optional>
      <rng:ref name="speaker"/>
      <rng:zeroOrMore>
	<rng:ref name="model.global"/>
      </rng:zeroOrMore>
    </rng:optional>
  </content>
  <!--…-->
</elementSpec>
</egXML>
This proposes anything from the global model class, followed by some
<gi>speaker</gi> elements, followed by anything from the global model
class. What happens if <gi>speaker</gi> is gone? The following would
result:
<egXML xmlns="http://www.tei-c.org/ns/Examples">
<elementSpec ident="sp">
  <!--…-->
  <content xmlns:rng="http://relaxng.org/ns/structure/1.0">
    <rng:zeroOrMore>
      <rng:ref name="model.global"/>
    </rng:zeroOrMore>
    <rng:zeroOrMore>
      <rng:ref name="model.global"/>
    </rng:zeroOrMore>
  </content>
  <!--…-->
</elementSpec>
</egXML>
which is illegal in DTD and W3C schema languages,
since for a given member of <val>model.global</val> it is impossible to
be sure which rule is being used. RELAX NG does not need to know
which rule has fired, and so avoids the problem.</p>
</div>

<div xml:id="IM-naming">
<head>Naming and documenting in generated schemas</head>
<p>When processing class, element or macro specifications, there are
three general rules:
<list type="ordered">
<item>If a RELAX NG pattern or DTD parameter entity
is being created, its name is the value of
the <att>ident</att> attribute, prefixed by the value of any
<att>prefix</att> attribute on <gi>schemaSpec</gi>. This allows for
external schemas to be mixed in which have elements of the same names
as the TEI, if <att>prefix</att> is given a value of
e.g. <val>tei_</val>. 
Thus
<egXML xmlns="http://www.tei-c.org/ns/Examples">
<schemaSpec ident="test" prefix="tei_">
  <elementSpec ident="sp">
    <!--...-->
  </elementSpec>
</schemaSpec>
</egXML>
may generate a RELAX NG (compact) pattern like this:
<eg>
 tei_sp = element sp { ... }
</eg>
Referring strings have to be adjusted accordingly.
</item>

<item>If an element or attribute is being created, its default name is
the value of the <att>ident</att> attribute, but if there is an
<gi>altIdent</gi> child, the value of that is used instead.
</item>

<item>Where appropriate, the documentation strings in <gi>gloss</gi>
and <gi>desc</gi> should be copied into the generated schema. If there
is only one use of these elements, they should be used regardless, but if
there
are several with different values of <att>xml:lang</att>, a locale
indication in the processing environment should be used to decide
which to use. For example, 
<egXML xmlns="http://www.tei-c.org/ns/Examples">
<elementSpec module="core" ident="head">
  <equiv/>
  <gloss>heading</gloss>
  <gloss xml:lang="es">encabezamiento</gloss>
  <gloss xml:lang="zh-tw">標題</gloss>
  <gloss xml:lang="ja">表題</gloss>
<!-- ... -->
</elementSpec>
</egXML>
might generate a RELAX NG schema fragment like the following, if the
locale is determined to be Chinese:
<eg>
head =
  ## 標題
  element head { head.content, head.attributes }
</eg>
</item>
</list>
</p>
<p>In addition, there are three conventions about
naming patterns relating to classes; ODD processors need not follow them,
but  those reading the schemas generated by the TEI
project will find it necessary to understand them:
<list type="ordered">
<item>when a pattern for  attribute class  is created,
it is named after the model class identifier (as above)
suffixed by <code>.attributes</code>
(e.g. <code>att.editLike.attributes</code>).
</item>
<item>when a pattern for  an attribute attribute class  is created,
it is named after the model class identifer (as above)
suffixed by <code>.attribute.</code> and then the identifier
of the attribute (e.g. <code>att.editLike.attribute.resp</code>).</item>
<item>when a parameterized schema is created, each
element generates patterns for its attributes and its contents
separately, suffixing respectively <code>.attributes</code>
and <code>.contents</code> to the element name.</item>
</list>
</p>
</div>

<div>
<head>Making a RELAX NG schema</head>

<p>To create a RELAX NG schema, the processor
processes every <gi>macroSpec</gi>,
<gi>classSpec</gi> and <gi>elementSpec</gi> in turn, creating
a RELAX NG pattern for each, using the naming conventions listed
above.  The order of declaration is not important, and a processor
may well sort them into alphabetical order of identifier.</p>

<p>A complete RELAX NG schema must have a <gi>start</gi> element
defining which elements can occur as the root of a document. The
ODD <gi>schemaSpec</gi> has an optional <att>start</att> attribute,
containing one or more element names, which can be used to construct 
<gi>start</gi>.</p>

<div>
<head>Macros</head>
<p>An ODD macro
generates a corresponding RELAX NG pattern simply by copying the body
of the <gi>content</gi> element. Thus
<egXML xmlns="http://www.tei-c.org/ns/Examples">
<macroSpec module="tei" type="pe" ident="macro.phraseSeq">
  <content>
    <rng:zeroOrMore xmlns:rng="http://relaxng.org/ns/structure/1.0">
      <rng:choice>
        <rng:text/>
        <rng:ref name="model.gLike"/>
        <rng:ref name="model.phrase"/>
        <rng:ref name="model.global"/>
      </rng:choice>
    </rng:zeroOrMore>
  </content>
</macroSpec>
</egXML>
produces
<egXML xmlns="http://www.tei-c.org/ns/Examples">
  <define xmlns="http://relaxng.org/ns/structure/1.0" name="macro.phraseSeq">
    <zeroOrMore>
      <choice>
        <text/>
        <ref name="model.gLike"/>
        <ref name="model.phrase"/>
        <ref name="model.global"/>
      </choice>
    </zeroOrMore>
  </define>
</egXML>
Note that in much of these Guidelines, we show the RELAX NG
output in compact format; the ODD specification stores it in the more
verbose XML format, but the two are interchangeable.</p>
</div>

<div>
<head>Classes</head>
<p>An ODD model class generates a RELAX NG alternation pattern listing 
all the members of the class present in the ODD. So this
example
<egXML xmlns="http://www.tei-c.org/ns/Examples">
<classSpec module="tei" type="model" ident="model.measureLike">
<!-- ... -->
</classSpec>
</egXML>
may produce, for a given customization:
<egXML xmlns="http://www.tei-c.org/ns/Examples">
  <define xmlns="http://relaxng.org/ns/structure/1.0" name="model.measureLike">
    <choice>
      <ref name="num"/>
      <ref name="measure"/>
      <ref name="measureGrp"/>
    </choice>
  </define>
</egXML>
if the elements <gi>num</gi>, <gi>measure</gi> and <gi>measureGrp</gi>
are included. Depending on the value of the <att>generate</att>
attribute on the <gi>classSpec</gi>, it may also generate a set
of sequences as well as alternation patterns. Thus we may also
generate the <ident>sequence</ident>, 
<ident>sequenceOptional</ident>,  
<ident>sequenceRepeatable</ident>,  and 
<ident>sequenceOptionalRepeatable</ident> patterns:
<egXML xmlns="http://www.tei-c.org/ns/Examples">
  <define xmlns="http://relaxng.org/ns/structure/1.0" name="model.measureLike_sequence">
    <ref name="num"/>
    <ref name="measure"/>
    <ref name="measureGrp"/>
  </define>
  <define xmlns="http://relaxng.org/ns/structure/1.0" name="model.measureLike_sequenceOptional">
    <optional>
      <ref name="num"/>
    </optional>
    <optional>
      <ref name="measure"/>
    </optional>
    <optional>
      <ref name="measureGrp"/>
    </optional>
  </define>
  <define xmlns="http://relaxng.org/ns/structure/1.0" name="model.measureLike_sequenceOptionalRepeatable">
    <zeroOrMore>
      <ref name="num"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="measure"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="measureGrp"/>
    </zeroOrMore>
  </define>
  <define xmlns="http://relaxng.org/ns/structure/1.0" name="model.measureLike_sequenceRepeatable">
    <oneOrMore>
      <ref name="num"/>
    </oneOrMore>
    <oneOrMore>
      <ref name="measure"/>
    </oneOrMore>
    <oneOrMore>
      <ref name="measureGrp"/>
    </oneOrMore>
  </define>
</egXML>
where the pattern name is created by appending an underscore and the
name of the generation sequence to the class name.
</p>

<p>Attribute classes work by producing a pattern containing
definitions of the appropriate attributes. So
<egXML xmlns="http://www.tei-c.org/ns/Examples">
<classSpec module="verse" type="atts" ident="att.enjamb">
  <attList>
    <attDef ident="enjamb" usage="opt">
      <equiv/>
      <desc>indicates that the end of a verse line is marked by enjambement.</desc>
      <datatype>
        <rng:ref xmlns:rng="http://relaxng.org/ns/structure/1.0" name="data.enumerated"/>
      </datatype>
      <valList type="open">
        <valItem ident="no">
          <equiv/>
          <desc>the line is end-stopped
	  </desc>
        </valItem>
        <valItem ident="yes">
          <equiv/>
          <desc>the line in question runs on into the next
    </desc>
        </valItem>
        <valItem ident="weak">
          <equiv/>
          <desc>the line is weakly enjambed
    </desc>
        </valItem>
        <valItem ident="strong">
          <equiv/>
          <desc>the line is strongly enjambed</desc>
        </valItem>
      </valList>
    </attDef>
  </attList>
</classSpec>
</egXML>
produces
<egXML xmlns="http://www.tei-c.org/ns/Examples">
  <define xmlns="http://relaxng.org/ns/structure/1.0" name="att.enjamb.attributes">
    <ref name="att.enjamb.attribute.enjamb"/>
    <empty/>
  </define>
  <define xmlns="http://relaxng.org/ns/structure/1.0" name="att.enjamb.attribute.enjamb">
    <optional>
      <attribute name="enjamb">
        <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">indicates that the end of a verse line is marked by enjambement.
Sample values include: 1] no; 2] yes; 3] weak; 4] strong</a:documentation>
        <ref name="data.enumerated"/>
      </attribute>
    </optional>
  </define>
</egXML>
Since the processor may have expanded the attribute
classes already, separate patterns are generated
for each attribute in the class as well as one for
the class itself. This allows an element to refer directly
to a member of a class. Notice that the <gi>desc</gi> element
is used to add a <gi>documentation</gi> element to the schema,
which some editors use to provide help during composition. The 
<gi>desc</gi> elements in the <gi>valList</gi> are used to create
the human-readable sentence <quote>Sample values include: 1] no; 2]
yes; 3] weak; 4] strong</quote> Naturally, this sort of use
of the documentation elements is not mandatory, and other ODD
processors may ignore them when creating schemas.</p>

<p>An individual attribute consists of a RELAX NG <gi>attribute</gi>
with a <att>name</att> attribute derived according to the naming rules
described above. In addition, the ODD model supports a
<gi>defaultVal</gi>, which is transformed to a <att>defaultValue</att>
in the namespace
<ident>http://relaxng.org/ns/compatibility/annotations/1.0</ident>
attribute on the RELAX NG <gi>attribute</gi>. The body of the
attribute is taken from the <gi>datatype</gi> child, unless there is a
supporting <gi>valList</gi> with a <att>type</att> value of
<val>closed</val>. In that case a RELAX NG <gi>choice</gi> is created,
listing the allowed values. Thus the following attribute definition
<egXML  xmlns="http://www.tei-c.org/ns/Examples">
  <attDef ident="full" usage="opt">
    <defaultVal>yes</defaultVal>
    <valList type="closed">
      <valItem ident="yes">
	<desc>the name component is spelled out in full.</desc>
      </valItem>
      <valItem ident="abb">
	<gloss>abbreviated</gloss>
	<desc>the name component is given in an abbreviated form.</desc>
      </valItem>
      <valItem ident="init">
	<gloss>initial letter</gloss>
	<desc>the name component is indicated only by one initial.</desc>
      </valItem>
    </valList>
  </attDef>
</egXML>
may generate this RELAX NG code:
<egXML  xmlns="http://www.tei-c.org/ns/Examples">
  <define xmlns="http://relaxng.org/ns/structure/1.0" name="att.full">
    <optional>
      <attribute xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" name="full" a:defaultValue="yes">
        <a:documentation>indicates whether the name component is given in full, as an
abbreviation or simply as an initial.</a:documentation>
        <choice>
          <value>yes</value>
          <a:documentation>the name component is spelled out in full.</a:documentation>
          <value>abb</value>
          <a:documentation>(abbreviated) the name component is given in an
abbreviated form.</a:documentation>
          <value>init</value>
          <a:documentation>(initial letter) the name component is indicated only by
one initial.</a:documentation>
        </choice>
      </attribute>
    </optional>
  </define>
</egXML>
Note the use of the 
<ident>http://relaxng.org/ns/compatibility/annotations/1.0</ident>
namespace to provide default values and documentation.
</p>
</div>

<div>
<head>Elements</head>
<p>An <gi>elementSpec</gi> produces a RELAX NG specification in two
parts; firstly, it must generate a <gi>define</gi>
pattern by which other elements
can refer to it, and then it must generate an
<gi>element</gi> with the content model and attributes. 
It may be convenient to make two separate patterns, one
for the element's attributes and one for its content model.</p>
<p>The content model is created simply by copying the body of the
<gi>content</gi>
element; the attributes are processed in the same way as those from
attribute classes, described above.</p>
</div>

</div>


<div xml:id="IM-makeDTD">
<head>Making a DTD</head>
<p>Generation of DTDs largely follows the same pattern
as RELAX NG generation, with one important exception — <hi>the order
of declaration matters</hi>. 
A DTD may not refer to an entity which
has not yet been declared. 
Since both macros and classes generate DTD entities,
the TEI Guidelines are constructed so that they can be
declared in the right order. A processor
must therefore work in the following order:
<list type="ordered">
<item>declare all model classes which have a <att>predeclare</att>
value of <val>true</val></item>
<item>declare all macros  which have a <att>predeclare</att>
value of <val>true</val></item>
<item>declare all other classes</item>
<item>declare the modules (if DTD fragments are being
constructed)</item>
<item>declare any remaining macros</item>
<item>declare the elements and their attributes</item>
</list>
The implementor who avoids careful study of this issue
will come to grief.</p>
<p>Let us consider a complete example, a simple
element with no attributes of its own:
<egXML  xmlns="http://www.tei-c.org/ns/Examples">
<elementSpec module="namesdates" ident="faith">
  <desc>specifies the faith,  religion, or belief set of a person.</desc>
  <classes>
    <memberOf key="model.persTraitLike"/>
    <memberOf key="att.editLike"/>
    <memberOf key="att.datable"/>
  </classes>
  <content xmlns:rng="http://relaxng.org/ns/structure/1.0">
    <rng:ref name="macro.phraseSeq"/>
  </content>
</elementSpec>
</egXML>
If DTD fragments are being generated (for use as described in <ptr
target="#STPE"/>), this will result in  the following:
<eg>&lt;!ENTITY % faith 'INCLUDE' &gt;
&lt;![ %faith; [

&lt;!--doc:specifies the faith,  religion, or belief set of a person. -->
&lt;!ELEMENT %n.faith; %om.RR; %macro.phraseSeq;>
&lt;!ATTLIST %n.faith; xmlns CDATA "http://www.tei-c.org/ns/1.0">
&lt;!ATTLIST %n.faith;
 %att.global.attributes;
 %att.editLike.attributes;
 %att.datable.attributes; >
]]&gt;
</eg>
Here the whole stanza is contained in a marked section
(for use as described in <ptr
target="#STPEEX"/>), the element name is parameterized
(see <ptr target="#STPEGI"/>), and the class attributes are
entity references derived from the <gi>memberOf</gi> records in
<gi>classes</gi>. Note the additional attribute which provides
a <att>xmlns</att> declaration for the element.
</p>

<p>A simpler rendition for a flattened DTD generated
from a customization will result in  the following, with no
containing marked section, and no parameterized name:
<eg>
&lt;!ELEMENT faith %macro.phraseSeq;>
&lt;!ATTLIST faith xmlns CDATA "http://www.tei-c.org/ns/1.0">
&lt;!ATTLIST faith
 %att.global.attribute.xmlspace;
 %att.global.attribute.xmlid;
 %att.global.attribute.n;
 %att.global.attribute.xmllang;
 %att.global.attribute.rend;
 %att.global.attribute.xmlbase;
 %att.global.linking.attribute.corresp;
 %att.global.linking.attribute.synch;
 %att.global.linking.attribute.sameAs;
 %att.global.linking.attribute.copyOf;
 %att.global.linking.attribute.next;
 %att.global.linking.attribute.prev;
 %att.global.linking.attribute.exclude;
 %att.global.linking.attribute.select;
 %att.editLike.attribute.cert;
 %att.editLike.attribute.resp;
 %att.editLike.attribute.evidence;
 %att.datable.w3c.attribute.period;
 %att.datable.w3c.attribute.when;
 %att.datable.w3c.attribute.notBefore;
 %att.datable.w3c.attribute.notAfter;
 %att.datable.w3c.attribute.from;
 %att.datable.w3c.attribute.to;>
</eg>
Here the attributes from classes have been expanded into
individual entity references.</p>
</div>

<div>
<head>Generating documentation</head>
<p>In Donald Knuth's terminology of literate programming,
the previous sections have dealt with process of <term>tangle</term>;
to generate documentation, we now turn to the specification of
<term>weave</term>.</p>

<p>An ODD customization may consist largely of general documentation
and examples, which will be processed as normal, but in addition
it will contain a <gi>schemaSpec</gi> and possibly some
<gi>specGrp</gi>
fragments.</p>
<p> The generated documentation may  be of two forms. On the one hand,
we may document the customization itself, ie the elements which
specify the difference between this and the full TEI. Alternatively,
we may generate reference documentation for the complete subset of the
TEI which results from applying the customization. The TEI Roma tools
take the latter approach, and operate on the result of the first
stage processing described in <ptr target="#IM-unified"/>.</p>

<p>Generating reference documentation for <gi>elementSpec</gi>
<gi>classSpec</gi> and <gi>macroSpec</gi> elements is largely
dependent on the design of the preferred output. Some applications
may, for example, want to turn all names of objects into hyperlinks,
show lists of class members, or present lists of attributes as tables,
lists, or inline prose.  Another technique implemented in these
Guidelines is to show lists of potential <soCalled>parents</soCalled>
for each element, by tracing which other elements have them as
possible members of their content models.</p>
<p>One model of display on a web page 
is shown in Figure <ptr target="#ref-faith"/>,
corresponding to the <gi>faith</gi> element shown in section
<ptr target="#IM-makeDTD"/>.</p>
<figure xml:id="ref-faith">
<graphic url="Images/ref-faith.png"/>
<head>Example reference documentation for <gi>faith</gi></head>
</figure>

</div>

<!-- not sure what was intended here -->

<!--
<div>
<head>Validation tools for other processors</head>

</div>
-->

<div xml:id="STPE">
<head>Using TEI parameterized schema fragments</head>
<p>The TEI parameterized DTD and RELAX NG fragments make use parameter
entities and patterns for several purposes. In this section we
describe their interface for the user. In general we recommend use of
ODD instead of this technique.</p>

<div type="div3" xml:id="STPED"><head>Selection of modules</head>

<p>Special-purpose parameter entities are used to specify which
modules are to be combined into a TEI DTD. They take the form
<val>TEI.xxxxx</val> where <code>xxxx</code> is the name of the module
as given in table <ptr target="#tab-mods"/> in <ptr
target="#STMA"/>. For example, the parameter entity <ident
type="pe">TEI.linking</ident> is used to define whether or not to
include the module <ident type="module">linking</ident>. All such
parameter entities are declared by default with the value
<val>IGNORE</val>: to select a module, therefore, the encoder declares
the appropriate parameter entities with the value <val>INCLUDE</val>.
</p>

<p>The parameter entity concerned is used as the keyword controlling a
conditional marked section in the DTD fragment generated by the <ident
type="module">tei</ident> module. The declarations for each DTD
fragment constituting the module are contained within such marked
sections. For example, the parameter entity <ident
type="pe">TEI.linking</ident> appears twice in <ident
type="file">tei.dtd</ident>, once for the <ident
type="frag">linking-decl</ident> schema fragment:
<eg><![CDATA[
<!ENTITY % TEI.linking 'IGNORE' >
<![%TEI.linking;[
<!ENTITY % file.linking-decl PUBLIC '-//TEI P5//ENTITIES Linking, Segmentation, and Alignment//EN' 'linking-decl.dtd' >
%file.linking-decl;
]]&gt;]]></eg>
and once for the <ident type="frag">linking</ident> schema fragment:
<eg><![CDATA[
<![%TEI.linking;[
<!ENTITY % file.linking PUBLIC '-//TEI P5//ELEMENTS Linking, Segmentation, and Alignment//EN' 'linking.dtd' >
%file.linking;
]]&gt;]]></eg>

If TEI.linking has its default value of IGNORE, neither declaration
has any effect. If however it has the value INCLUDE, then the content
of each marked section is acted upon: the parameter entities <ident
type="pe">file.linking</ident> and <ident
type="pe">file.linking-decl</ident> are referenced, which has the
effect of embedding the content of the files they represent at the
appropriate point in the DTD. </p>

<p>The RELAX NG schema fragments can be combined in a wrapper schema
using the standard mechanism of <gi>include</gi> in that language.</p>

</div>


<div type="div3" xml:id="STPEEX">
<head>Inclusion and exclusion of elements</head>

<p>The TEI DTD fragments also use marked sections and parameter entity
references to allow users to exclude the definitions of individual
elements, in order either to make the elements illegal in a document
or to allow the element to be redefined. The parameter entities used
for this purpose have exactly the same name as the generic identifier
of the element concerned.  The default definition for these parameter
entities is <val>INCLUDE</val> but they may be changed to
<val>IGNORE</val> in order to exclude the standard element and
attribute definition list declarations from the DTD.
 </p>

<p>The declarations for the element <gi>p</gi>, for example, are
preceded by a definition for a parameter entity with the name
<ident rend="noindex" type="ge">p</ident> and contained within a marked
section whose keyword is
given as <code>%p;</code>:
<eg><![CDATA[<!ENTITY % p 'INCLUDE' >
<![ %p; [
       <!-- element and attribute list declaration for p here -->
]]]]></eg></p><p>These parameter entities are defined immediately preceding the
element whose declarations they control; because their names are
completely regular, they are not documented further.
 </p>
<p>To define a DTD in which the element <gi>p</gi> is excluded
therefore, the entity <ident rend="noindex" type="pe">p</ident> needs
to be redefined as <val>IGNORE</val> by ensuring that a declaration
such as
<eg><![CDATA[<!ENTITY % p 'IGNORE' >]]></eg>
is added earlier in the DTD than the default (see further <ptr target="#STOVLO"/>). </p>

<p>Similarly, in the parameterized RELAX NG schemas, every element is
defined by a pattern named after the element. To undefine an element
therefore all that is necessary is to add a declaration like the
following:
<eg> p = notAllowed </eg>
</p></div>

<div type="div3" xml:id="STPEGI"><head>Changing the names of 
generic identifiers</head>

<p>In the TEI DTD fragments, elements are not referred to directly by
their generic identifiers; instead, the DTD fragments refer to
parameter entities which expand to the standard generic identifiers.
This allows users to rename elements by redefining the appropriate
parameter entity.  Parameter entities used for this purpose are formed
by taking the standard generic identifier of the element and attaching
the string <val>n.</val> as a prefix.  Thus the standard generic
identifiers for paragraphs, notes, and quotations, <gi>p</gi>,
<gi>note</gi>, and <gi>q</gi> are defined by declarations of the
following form: 
<eg><![CDATA[<!ENTITY % n.p "p">
<!ENTITY % n.pb "pb"> 
<!ENTITY % n.persName "persName">]]></eg>
Since all names in the TEI DTD are case-sensitive, the specific mix of
upper and lower case letters in the standard generic identifier must
be preserved in the entity name.
 </p>

<p>These declarations are generated by an ODD processor
when TEI DTD fragments are created. </p>

<p> In the RELAX NG schemas, all elements normally defined using a
pattern with the same name as the element (as described in <ptr
target="#IM-naming"/>): for example
<eg>
abbr = element abbr { abbr.content, abbr.attributes }
</eg>
The easiest way of renaming the element is thus simply to rewrite
the pattern with a different element name; any references use the
pattern, not the element, name.
<eg>
abbr = element abbrev { abbr.content, abbr.attributes }
</eg>
More complex revisions, such as redefining the content of the element
(defined by the pattern <ident type="rng">abbr.content</ident>) or its
attributes (defined by the pattern <ident
type="rng">abbr.attributes</ident>) can be accomplished in a similar
way, using the features of the RELAX NG language. The recommended
method of carrying out such modifications is however to use the ODD
language as further described in section <ptr target="#TD"/>.</p>
</div>


<div type="div3" xml:id="STOVLO"><head>Embedding local modifications
(DTD only)</head>

<p>Any local modifications to a DTD (i.e. changes to a schema other than simple
inclusion or exclusion of modules) are made by declarations stored in
one of two local extension files, one containing modifications to the
TEI parameter entities, and the other new or changed declarations of
elements and their attributes.  Entity declarations must be made
which associate the names of these two files with the appropriate
parameter entity so that the declarations they contain can be embedded
within the TEI DTD at an appropriate point.</p>

<p>The following entities are referred to by the main
<ident type="file">tei.dtd</ident> file to embed portions of the TEI DTD fragments
or locally developed extensions.
<list type="gloss"><label><ident type="pe">TEI.extensions.ent</ident></label>
<item>identifies a local file containing
extensions to the TEI parameter entities</item>
<label><ident type="pe">TEI.extensions.dtd</ident></label>
<item>identifies a local file containing
extensions to the TEI module</item>
</list></p>
<p>For example, if the relevant files are called <ident rend="noindex" type="file">project.ent</ident> and <ident rend="noindex" type="file">project.dtd</ident>, then declarations like the following
would be appropriate:
<eg><![CDATA[<!ENTITY % TEI.extensions.ent SYSTEM 'project.ent' >
<!ENTITY % TEI.extensions.dtd SYSTEM 'project.dtd' >]]></eg></p>

<p>When an entity is declared more than once, the first declaration is
binding and the others are ignored.  The local modifications to
parameter entities should therefore be handled before the standard
parameter entities themselves are declared in <ident type="file">tei.dtd</ident>.  The entity <ident type="pe">TEI.extensions.ent</ident> is referred to before any TEI
declarations are handled, to allow the user's declarations to take
priority.  If the user does not provide a <ident type="pe">TEI.extensions.ent</ident> entity, the entity will be expanded
to the empty string.</p>
<p>For example the encoder might wish to add two phrase-level elements
<gi>it</gi> and <gi>bd</gi>, perhaps as synonyms for
<tag>hi rend='italics'</tag> and <tag>hi rend='bold'</tag>.  As
described in chapter <ptr target="#MD"/>, this involves two distinct steps:
one to define the new elements, and the other to ensure that they are
placed into the TEI document structure at the right place.  We deal with
the second first, by specifying the element class to which the new
elements should be attached.  To do this, the parameter entity
<ident type="pe">x.phrase</ident> should be modified to include the two
new generic identifiers.  The file containing local declarations of the
standard parameter entities will thus contain a declaration of the
following form:
<eg><![CDATA[<!ENTITY % x.phrase 'it | bd |' >]]></eg></p>
</div>

</div>

</div>

<!-- material excised from elsewhere follows -->

<!-- from SG -->



<!--
<div type="div2" xml:id="SG17"><head>Entities</head>
<p>The aspects of XML discussed so far are all concerned with the
markup of structural elements within a document.  XML also provides a
simple and flexible method of encoding and naming arbitrary parts of
the actual content of a document in a portable way.  In XML the word
<term>entity</term> has a special sense: it means a named part of a
marked up document, irrespective of any structural considerations.  An
entity might be a string of characters or a whole file of text.
Entities can only be declared in a DTD, in the same way as elements or
attributes, and they are included in a document using a construction
known as an <term>entity reference</term>. In the schema, they can
only be declared in a DTD subset (see section <ptr target="#SG182"/>)
in the document itself.</p>

<div type="div3" xml:id="SG-ents"><head>Entity declarations</head>
<p>Like all other declarations, an  entity declaration begins with a special keyword, in this case the word <ident type="kw">ENTITY</ident>, followed by the name of the entity to be declared, and the value to be used when it is referenced in the document. For example, the following declaration
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY tei "Text Encoding Initiative">]]></egXML>
defines an entity whose name is <ident type="ge" rend="noindex">tei</ident> and
whose value is the string <code>Text Encoding Initiative</code>. This is an
instance of an <term>entity declaration</term>, which declares an
<term>internal entity</term>.  The following declaration, by contrast,
declares an <term>external entity</term> (sometimes called, loosely, a
<term>system entity</term>):
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY ChapTwo SYSTEM "p4chap2.xml">]]></egXML>

This defines an external entity whose name is <ident rend="noindex"
type="ge">ChapTwo</ident> and whose value is the text associated with
the system identifier — in this case, the system identifier is the
name of an operating system file and the replacement text of the
entity is the contents of the file.  However, XML does not require
system identifiers to be operating-system file names.<note
place="foot">In general, an external entity can be any data source
available to the XML processor: files, results of database queries,
results of calls to system functions, web pages — anything at
all. System identifiers can use any method to name an entity which the
XML parser's interface to its operating environment can use to elicit
data from the environment.</note> We might define the same entity as
referring to a web page: <egXML
xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY ChapTwo
SYSTEM "http://www.tei-c.org/P4X/p4chap2.xml">]]></egXML>
</p>
<p>System identifiers are, by their nature, system dependent; in the
interests of data portability, therefore, XML provides another way of
declaring external entities, shown here:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY p3.sg PUBLIC
"-//TEI//TEXT Guidelines Chapter on XML//EN" "p4chap2.xml">]]></egXML>
Here, the keyword <code>SYSTEM</code> has been replaced by the keyword
<code>PUBLIC</code>, and the system identifier has been preceded by a
special string known as a <term>formal public identifier</term>.
Although public identifiers can (in principle) take virtually any
form; it is usual to use the form shown above, in which the delimiters
<mentioned>//</mentioned> divide the identifier into the following
parts: <list type="gloss"><label>TEI</label> <item>indicates the owner
of this public identifier (often but not necessarily the owner of the
data in question); the preceding <mentioned>-</mentioned> signals that
this particular owner identifier is not registered with ISO (a
<mentioned>+</mentioned> would imply that one could find out the full
name and address of the owner from the official registry of owner
identifiers)</item> <label>TEXT</label> <item>is a keyword indicating
the nature of the entity: other legal values are <code>DOCUMENT</code>
(for full XML documents), <code>DTD</code> (for document type
declarations), <code>ELEMENTS</code> (for sets of element
declarations), <code>ENTITIES</code> (for sets of entity
declarations), <code>NOTATION</code> (for notation definitions), and a
number of others which are less frequently needed and will not be
discussed here.</item> <label>Guidelines Chapter on XML</label>
<item>gives a descriptive name to the entity.</item><label>EN</label>
<item>is the ISO language code for the human language in which the
entity is written.</item></list>
</p>
<p>Public identifiers help make XML documents less dependent on
particular computer systems, by making it possible to confine the
mapping between entity names and system identifiers to a single
place. As with other such techniques, they require XML systems to
provide mechanisms for mapping from the public identifiers to file
identifiers or other system identifiers: such a mapping is typically
provided by an additional component known as a <term>catalog
file</term> (<ptr target="#SGPATANC"/>).</p>
   </div>
<div type="div3" xml:id="SG-er"><head>Entity references</head>
<p>Once an entity has been declared it may be referenced anywhere
within a document. This is done by supplying its name prefixed with
the ampersand character and followed by the semicolon.</p>
<p>When an XML parser encounters such an <term>entity
reference</term>, it immediately substitutes the value declared for
the entity name. Thus, the passage <code>The work of the &amp;tei; has
only just begun</code> will be interpreted by an XML processor exactly
as if it read <code>The work of the Text Encoding Initiative has only
just begun</code>. In the case of an external entity, it is, of
course, the contents of the operating system file which are
substituted, so that the passage <code>The following text has been
suppressed: &amp;ChapTwo;</code> will be expanded to include the whole
of whatever the system finds in the file <ident rend="noindex" type="file">p4chap2.xml</ident>.</p>
<p>This obviously saves typing, and simplifies the task of maintaining
consistency in a set of documents.  If the printing of a complex
document is to be done at many sites, the document body itself might use
an entity reference, such as <code>&amp;site;</code>, wherever
the name of the site is required.  Different entity declarations could
then be used at different sites to supply the appropriate string to be
substituted for this name, with no need to change the text of the
document itself.</p>
</div>
<div type="div3" xml:id="SG-ue"><head>Unparsed entities and Notations</head>
<p>An XML entity may contain non-textual information such as pictures,
video, or sound in digitized form. Such objects can be embedded in a
document by reference in exactly the same way as any other external
entity. When such entities are declared, however, it is essential to
indicate that they contain data which an XML parser or processor
cannot handle in the same way as the surrounding data — it is no
use trying to process entities contain pictures or sound as if they
contain text! This is accomplished by including an additional keyword
in the declaration of such entities, as in the following example:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY fig1 SYSTEM "figure1.png" NDATA png>]]></egXML>
 </p>
<p>The keyword <ident type="kw">NDATA</ident> indicates that this external entity is
<term>unparsed</term>: it contains non-XML data which an XML parser
should ignore. It is followed by an additional name (<code>png</code>
in the example above) which identifies the <term>notation</term> used
for this data, that is, the set of conventions which a processor must
understand in order to process the data correctly. XML may itself be
thought of as a notation, which is implied for all external entities
not otherwise labelled. Notations should be declared in a DTD along with
everything else: for the DTD in which the above declaration appears, a
notation declaration like the following would also be appropriate:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!NOTATION png PUBLIC
    '-//TEI//NOTATION IETF RFC2083 Portable Network Graphics//EN'>]]></egXML>
This gives a formal public identifier for the place where the notation
<code>png</code> is defined.</p>
<p>More detailed discussion of external unparsed entities and of
recommended graphics notations are given in section <ptr target="#FTGRA"/> of the Guidelines.</p></div>
<div type="div3" xml:id="SG-pe"><head>Parameter entities</head>
<p>A special form of entities, <term>parameter entities</term>, may be
used within XML markup declarations; these differ from the entities
discussed above (which technically are known as <term>general
entities</term>) in two ways:
<list type="bullets">
<item>Parameter entities are used <emph>only</emph> within XML markup
declarations; they may not appear  within the document
itself.</item>
<item>Parameter entity references are delimited by percent sign and semicolon,
rather than by ampersand and semicolon.</item></list>
</p> 
<p>Declarations for parameter entities take the same form as those for
general entities, but insert a percent sign between the keyword
<code>ENTITY</code> and the name of the entity itself.  Whitespace characters
(blanks, tabs, or line breaks) must occur on both sides of the percent
sign.  For example, an internal parameter entity named <ident type="pe">a.global</ident> might be declared with the  expansion
<code>id ID #REQUIRED  rend CDATA #IMPLIED</code> as follows:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % a.global 
         'id ID #REQUIRED  rend CDATA #IMPLIED'>]]></egXML>
</p>
<p>With this declaration at the start of a DTD, the task (for example) of declaring
attributes consistently on all elements within a DTD becomes much
simpler: all that is needed is to reference the parameter entity, as
in this example:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ATTLIST myElement %a.global;
                    another CDATA #IMPLIED >]]></egXML>
since the attribute list  for <tag>myElement</tag> will now be
understood to contain whatever list of attribute definitions was
declared as the value for the parameter entity <ident type="pe">a.global</ident>, followed by the definition for an
attribute called <att>another</att>.</p>
<p>Moreover, if we wish to change the global attributes
or add another, all we need do is provide a new declaration for <ident type="pe">a.global</ident> in the DTD. We do not even need to modify
the existing declaration, but simply ensure that the new one precedes
the old one in the DTD being processed. This is because of one very significant aspect of entity
declarations not mentioned above: if a declaration is given for the
same entity more than once, then only the first declaration is
applicable. If, for example, an XML processor finds the following:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY switch "UP"> 
<! - - several other declarations - ->
<!ENTITY switch "DOWN">
<!ENTITY switch "SIDEWAYS">
<!- - .... - ->
The switch is &switch;]]></egXML>
then the entity reference at the end (assumed to be inside a document)
will be resolved as the string "UP" because that is the first
declaration encountered. This rule applies equally to general entities
and parameter entities, and has important consequences for the TEI
scheme. The TEI DTD makes extensive use of parameter
entities to control the selection of different tag sets. They are also used to control the behaviour of conditional marked sections, as further discussed in section <ptr target="#SG-cond"/> below.</p></div></div>
<div type="div2" xml:id="SG17BIS"><head>Marked sections</head>
<p>It is occasionally necessary to mark some portion of an XML
document for special treatment.  Within the body of a document, it is
often convenient to be able to mark some portion as containing XML
markup which is to be ignored. Within a DTD, it is often convenient to
mark certain parts to be included or excluded in specific
circumstances. To deal with the former situation, XML defines a
construct known as a <term>CDATA marked section</term>; to deal with
the latter, a syntactically similar construct known as a
<term>conditional marked section</term> may be used.</p>
<p>Most users of the TEI encoding scheme will never need to use marked
sections, and may safely skip the remainder of this discussion.  The
TEI DTD makes extensive use of conditional marked sections, however,
and this section should be read carefully by anyone wishing to follow
in detail the discussions in chapter <ptr target="#ST"/> of the
Guidelines.</p>
<div type="div3" xml:id="SG-cond"><head>CDATA marked section</head>
<p>A <code>CDATA</code> marked section is delimited by two rather
arcane sequences of characters: its start is marked by the string
<code>&lt;![CDATA[</code>, and its end by the string
<code>]]&gt;</code>. Note that spaces are not permitted within either
string.</p>
<p>Within a <code>CDATA</code> marked section any strings of characters which look
like XML tags or entity references will not be recognized as such by
the XML parser: they are thus a very useful way of including examples
of XML tagging within a document itself written in XML. For example:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p>The
<gi>term</gi> element may be used to mark any technical
term: <eg>&lt;![CDATA[ This &lt;term&gt;recursion&lt;/term&gt;
is giving me a headache. ]]&gt;</eg></p></egXML>
</p>
<p>In this extract from a document describing the way that an XML
element called <gi>term</gi> may be used, the cited example (tagged
with a <gi>eg</gi> element) includes an instance of the <gi>term</gi>
element which will not be recognised as such, but simply as a string
of characters, because it is contained by a marked section.</p>
<p>A similar effect can be achieved by simply replacing the angle
brackets by entity references, but this makes the text somewhat
unreadable in its native XML form if the example is of any length:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p>The <gi>term</gi> element may
  be used to mark any technical term: <eg>This &amp;lt;term&amp;gt;recursion&amp;lt;/term&amp;gt; is giving me a headache.
</eg></p>
</egXML>
</p>
</div>
<div type="div3" xml:id="SG-cms"><head>Conditional marked section</head>
<p>The <code>CDATA</code> marked section is a special case of the more
general <term>marked section</term> construct. Within the body of a
DTD (but not within the body of a document), two other kinds of marked
section are possible: an <code>IGNORE</code> marked section, and an
<code>INCLUDE</code> marked section. As the names suggest, material
within an <code>IGNORE</code> marked section is ignored during
processing, while material within an <code>INCLUDE</code> marked
section is included. These can be used to include and exclude portions
of a DTD selectively, so as to adjust it to relevant
circumstances.</p>
<p>Suppose, for example, that we want to allow for poems which contain
either only stanzas, or only couplets. A content model to enforce this
rule is easy to define, but it does require us to to declare both
possibilities — we must provide declarations for both
<gi>stanza</gi> and <gi>line</gi> elements, even though in a given
document we know that only one will appear. An alternative approach
might be to provide two different declarations for <gi>poem</gi>, as
follows: <egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[
<![INCLUDE[ <!ELEMENT poem (stanza+)> 
<!ELEMENT stanza (line+)> ]]
<![IGNORE[ <!ELEMENT poem (couplet+)> 
<!ELEMENT couplet (line,line)> ]]
]]></egXML>
The first declaration here will be the one used, since it is within an
<code>INCLUDE</code> marked section. The second one will be ignored. To swap
around, we change <code>INCLUDE</code> to <code>IGNORE</code>, and vice-versa.</p>
<p>The literal keywords <code>INCLUDE</code> and <code>IGNORE</code>,
however, are not much use in adjusting a DTD or a document to a user's
requirements.  If modifying a DTD to match user requirements involves
editing the text manually (changing <code>IGNORE</code> to
<code>INCLUDE</code> as appropriate), it is probably just as easy to
add or delete the affected parts of the DTD directly. However, the
<code>IGNORE</code> and <code>INCLUDE</code> keywords need not be
given as literal values; they can also be represented by a parameter
entity reference.</p>
<p>In the following DTD example, we have replaced the keywords by
references to two parameter entities:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[
<![%stanzas;[
   <!ELEMENT poem (stanza+)> 
   <!ELEMENT stanza (line+)> 
   <!ENTITY couplets "IGNORE">
]]
<![%couplets;[
   <!ELEMENT poem (couplet+)> 
   <!ELEMENT couplet (line,line)> 
]]
]]></egXML>
The exact meaning of this will depend on the values of the parameter
entities <ident type="pe">stanzas</ident> and <ident type="pe">couplets</ident> when the
DTD is processed. When parameter entities are used in this way to
control marked sections in a DTD, the  DTD file must
contain default declarations for them.  If the user wishes to override
any of the
defaults, all that needs to be done is to supply a new declaration and
ensure that it will be processed before the existing default. The
easiest way of doing this is to supply it within a special part of the
DTD known as the <term>DTD subset</term>.<note place="foot">This is
explained in more detail in section <ptr target="#SG182"/> below; the
key point for our present purposes is that declarations in the DTD
subset are always read before those in the external DTD file, and, as
mentioned above in section <ptr target="#SG-pe"/>, the first
declaration of a given entity is the one which counts.</note></p>
<p>With the following default declarations, poems will consist only of
stanzas and the second set of declarations will be ignored:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % stanzas "INCLUDE">
<![%stanzas;[
   <!ELEMENT poem (stanza+)> 
   <!ELEMENT stanza (line+)> 
   <!ENTITY % couplets "IGNORE">
]]<![CDATA[>
<!ENTITY % couplets "INCLUDE">
<![%couplets;[
   <!ELEMENT poem (couplet+)> 
   <!ELEMENT couplet (line,line)> 
]]
]]></egXML>
This works because, although there are two declarations for the
parameter entity <ident type="pe">couplets</ident>, only the first is
effective. It declares the parameter entity <ident type="pe">couplets</ident> to
have the value <code>IGNORE</code>, and so the declarations within the
second conditional marked section are ignored. Suppose however that a
declaration for <ident type="pe">stanzas</ident> giving it the value
<code>IGNORE</code> were processed before this part of the DTD. In
that event, only the second declaration for the entity
<ident type="pe">couplets</ident> would be effective, since all the declarations
within the conditional marked section governed by
<ident type="pe">stanzas</ident> would be ignored.</p>
<p>Variations on this technique are used to control how the various
parts of a TEI DTD are constructed. For example:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[
<!ENTITY % TEI.prose 'INCLUDE'>
<!ENTITY % extensions SYSTEM 'mystuff.dtd'>
]]></egXML>
These declarations have two effects: they activate a section of the
DTD containing declarations relevant to prose and they add into the
DTD whatever additional declarations are held in the external file
<ident type="file">mystuff.dtd</ident>. In the standard DTD files,
there is a marked section controlled by the parameter entity <ident
type="pe">TEI.prose</ident>, the default value of which is
<code>IGNORE</code>, and there is also a reference to the parameter
entity <ident type="pe">extensions</ident>, the default value for
which is the null string. The declarations cited above over-ride both
these defaults: the declarations within the marked section controlled
by the parameter entity <ident type="pe">TEI.prose</ident> are thus
made active; and the reference to the <ident
type="pe">extensions</ident> parameter entity is replaced by the
content of the file <ident
type="file">mystuff.dtd</ident>.</p></div></div>
-->

<!--
<div type="div3"><head>Default value</head> 
<p>The last piece of information in
each attribute declaration specifies how a parser should interpret the
absence of the attribute concerned.  This can be done by supplying one
of the special keywords listed below, or (as in this case) by
supplying a specific value which is then regarded as the value for
every element which does not supply a value for the attribute
concerned.  Using the example above, if a poem is simply tagged
<tag>poem</tag>, the parser will treat it exactly as if it were tagged
<tag>poem status="draft"</tag>.  Alternatively, it is possible to
specify a default value for an attribute. Thus, if the attribute
declaration above were rewritten in DTD language as
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ATTLIST poem   id ID #IMPLIED 
                 status (draft | revised | published) #REQUIRED >]]></egXML>
then poems which appear in the anthology simply tagged <tag>poem</tag>
would be reported as erroneously tagged, as would any for which some
value other than <val>draft,</val> <val>published,</val> or
<val>revised</val> were supplied.</p></div> -->

<!--

<div type="div3" xml:id="SG182"><head>The <code>DOCTYPE</code> declaration</head>
<p>An XML file which is valid (as opposed to simply well-formed) can
specify a schema against which its content is to be validated. This is
the function of the <code>DOCTYPE</code> declaration. If you use
schemas, the particular schema you wish to validate a document against
is usually specified externally.</p>
<p>The <code>DOCTYPE</code> declaration contains, following the
<code>DOCTYPE</code> keyword, at least two parts: the name of the root
element for the associated document, and a set of declarations for all
the elements, attributes, notations, entities, etc. which together
define the document type declaration (schema) of that document. Note,
incidentally, that the root element name (and hence the
<code>DOCTYPE</code> name) may be that of any element whose
declaration is supplied in this set. The declarations may be supplied
explicitly, or by reference to an external entity such as a file, or
by a combination of the two.
</p>
<p>Taking each of these possibilities in turn, we first present a <code>DOCTYPE</code> declaration in which the declarations for all the elements, attributes, etc. required are given explicitly:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!DOCTYPE myDoc [
  <!ELEMENT myDoc (p+) >
  <!ATTLIST myDoc n CDATA #IMPLIED>
  <!ELEMENT p (#PCDATA)>
]>
<myDoc n="1">
  <p>This is an instance of a "my.doc" document</p>
</myDoc>]]></egXML>
Note that the required declarations are enclosed within square brackets inside the <code>DOCTYPE</code> declaration: this part of the declaration is technically known as the <term>schema subset</term>.</p>
<p>More usually, however, the required  declarations  will be held in a
separate entity and invoked by reference, as follows:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!DOCTYPE myDoc SYSTEM "myDoc.dtd" []>
<myDoc>
  <p>This is another instance of a "myDoc" document.</p>
  <p>It has two paragraphs.</p>
</myDoc>]]></egXML>
Note the similarity between the syntax used to reference the external
entity containing the required declarations and that used to define
any other system entity (see <ptr target="#SG-ents"/>). The square
brackets may be supplied even though they enclose nothing, as in this
example, or they may be omitted.</p>
<p>Next, we present a case where declarations are given both within the schema subset and by reference to an external entity:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!DOCTYPE myDoc SYSTEM "myDoc.dtd" [
  <!ENTITY tla "three letter acronym">]>
<myDoc>
  <p>This is yet another instance of a "myDoc" document.</p>
  <p>It is surprisingly free of &tla;s.</p>
</myDoc>]]></egXML>
</p>
<p>Any kind of declaration may be added to a schema subset; as we have
already seen (<ptr target="#SG-cms"/>), this is the mechanism by which the TEI schema is
customized. 
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!DOCTYPE TEI PUBLIC "-//TEI P3//schema Main Document Type//EN" "tei2.dtd" [
  <!ENTITY % TEI.prose 'INCLUDE'>
  <!ENTITY % TEI.XML   'INCLUDE'>
  <!ENTITY tla "Three Letter Acronym">
  <!ENTITY % x.phrase  'myTag|'>	 
  <!ELEMENT myTag (#PCDATA)    >
  <!- - any other special-purpose declarations or
       re-declarations go  here  - ->
  ]>
<TEI>
  <!- - This is an instance of a modified TEI type document, which
       may contain <myTag>my special tags</myTag> and references 
       to my usual entities such as &tla;. - ->
</TEI>]]></egXML>

When, as here, the document type declaration in force includes both
the contents of the schema subset, and the contents of some external
entity (in the case above, whatever file is specified by the
<code>PUBLIC</code> identifier given, <ident
type="file">tei2.dtd</ident> by default), declarations in the schema
subset are always carried out first.  As noted above, (<ptr
target="#SG-pe"/>), the order is important, because in XML only the
first declaration of an entity counts.  In the above example,
therefore, the declaration of the entity <ident type="ge">tla</ident>
in the schema subset takes precedence over any declaration of the same
entity in the file <ident type="file">tei2.dtd</ident>.  Similarly,
the declaration for <ident type="pe">x.phrase</ident> takes precedence
over the existing declaration for that entity in the TEI dtd. It is
perfectly legal for entities to be declared more than once; elements,
by contrast, may not be declared more than once; if a declaration for
<gi>myTag</gi> were already contained in file <ident
type="file">tei.dtd</ident>, the XML parser would signal an
error.</p></div>

<div type="div3" xml:id="SG183"><head>The Document Instance</head>

<p>The document instance is the content of the document itself.  It
contains only text, markup, and entity references, and thus may
not contain any new declarations.
A convenient way of building up large documents in a modular fashion
might be to use the schema subset to declare entities for the individual
pieces or modules, thus:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!DOCTYPE TEI 
          PUBLIC "-//TEI P4//schema Main Document Type//EN"
		         "tei2.dtd" [
   <!ENTITY % TEI.prose "INCLUDE">
   <!ENTITY % TEI.XML "INCLUDE">
   <!ENTITY chap1 SYSTEM "chap1.txt">
   <!ENTITY chap2 SYSTEM "chap2.txt">
   <!ENTITY chap3 "- - not yet written - -">
   ]>
<TEI>
  <teiHeader> <!- - ... - -> </teiHeader>
    <text>
      <body>
        &chap1;
        &chap2;
        &chap3;
        <!- - ... - ->
     </body>
  </text>
</TEI>]]></egXML></p>

<p>In this example, the TEI schema has been extended by entity
declarations for each chapter of some document.  The first two are
external entities referring to the file in which the text of
particular chapters is to be found; the third a dummy, indicating that
the text does not yet exist (alternatively, an entity with a null
value could be used).  In the document instance, the entity references
<code>&amp;chap1;</code>, etc. will be resolved by the parser to give
the required contents.  The chapter files themselves will not, of
course, contain any element, attribute list, or entity declarations –
just tagged text.</p></div>






<div type="div3" xml:id="SGPATANC"><head>Ancillary Files</head>

<p>A working XML system is likely to use a number of ancillary files
to hold configuration information.  These may include stylesheets,
specialized processing instructions, collections of relevant entity
declarations, setup information for specific programs, and many other
components. In general, the ways in which such components are to be
assembled or configured vary with the system and cannot readily be
described here.</p>

<p>To assist in this process many systems take advantage of an
additional <term>catalog file</term>, the chief function of which is
to associate the formal public identifiers used in a document or schema
with specific system entities, over-riding any default
association. One widely used format for such catalog files was defined
by an industry group originally known as SGML Open, and such files are
therefore known as SGML Open catalogs, even though they may also be
used by XML processors. The group has more recently redefined itself
under the name of the Organization for the Advancement of Structured
Information Standards (OASIS), and in August 2001 published a
specification for catalog files in XML form. <note place="foot">The
SGML Open catalog format is documented in <bibl>SGML Open Technical
Resolution 9401:1997, <title>Entity Management</title></bibl>, which
is available from <ptr
target="http://xml.coverpages.org/sotr9401-a2.html"/>; the XML Catalog
specification, also produced by OASIS is available from their site at
<ptr
target="http://www.oasis-open.org/committees/entity/spec.html"/>.</note>
Catalog files in both SGML Open and XML formats are distributed along
with the current TEI schemas.</p>
</div></div>
</div>


-->


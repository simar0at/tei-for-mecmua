<div xml:id="IM" xmlns="http://www.tei-c.org/ns/1.0">
<head>Implementation of an ODD System</head>
<p>This chapter specifies how a processing system may take advantage
of the markup specification elements documented in chapter <ptr
target="#TD"/> of these Guidelines in order to produce
<list type="ordered">
<item>project specific user documentation</item>
<item>schemas in one or more schema languages</item>
<item>validation tools for other processors</item>
</list>
</p>
<p>The specifications in this chapter are illustrative but not
normative. Its function is to further illustrate the intended scope
and application of the elements documented in chapter <ptr
target="#TD"/>, since it is believed that these may have application
beyond the areas directly addressed by the TEI.</p>

<div>
  <head>Process stages</head>
<p>The processing tools used to generate these guidelines
operate in two stages:
<list type="ordered">
  <item>application of changes and additions in an ODD schema specification
(as described in <ptr target="#MD"/>) to the main TEI Guidelines
through a process of selection,  merging and deletion</item>
<item>conversion of the resulting unified ODD to the desired output</item>
</list>
An ODD processor is not mandated to work in this way, but it is a
convenient way to simplify the second part of the work.</p>
</div>
<div>
<head>Generating documentation</head>
</div>

<div>
<head>Generating schemas</head>
</div>

<div>
<head>Validation tools for other processors</head>

</div>

</div>

<!-- material excised from elsewhere follows -->

<!-- from SG -->



<!--
<div type="div2" xml:id="SG17"><head>Entities</head>
<p>The aspects of XML discussed so far are all concerned with the
markup of structural elements within a document.  XML also provides a
simple and flexible method of encoding and naming arbitrary parts of
the actual content of a document in a portable way.  In XML the word
<term>entity</term> has a special sense: it means a named part of a
marked up document, irrespective of any structural considerations.  An
entity might be a string of characters or a whole file of text.
Entities can only be declared in a DTD, in the same way as elements or
attributes, and they are included in a document using a construction
known as an <term>entity reference</term>. In the schema, they can
only be declared in a DTD subset (see section <ptr target="#SG182"/>)
in the document itself.</p>

<div type="div3" xml:id="SG-ents"><head>Entity declarations</head>
<p>Like all other declarations, an  entity declaration begins with a special keyword, in this case the word <ident type="kw">ENTITY</ident>, followed by the name of the entity to be declared, and the value to be used when it is referenced in the document. For example, the following declaration
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY tei "Text Encoding Initiative">]]></egXML>
defines an entity whose name is <ident type="ge" rend="noindex">tei</ident> and
whose value is the string <code>Text Encoding Initiative</code>. This is an
instance of an <term>entity declaration</term>, which declares an
<term>internal entity</term>.  The following declaration, by contrast,
declares an <term>external entity</term> (sometimes called, loosely, a
<term>system entity</term>):
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY ChapTwo SYSTEM "p4chap2.xml">]]></egXML>

This defines an external entity whose name is <ident rend="noindex"
type="ge">ChapTwo</ident> and whose value is the text associated with
the system identifier — in this case, the system identifier is the
name of an operating system file and the replacement text of the
entity is the contents of the file.  However, XML does not require
system identifiers to be operating-system file names.<note
place="foot">In general, an external entity can be any data source
available to the XML processor: files, results of database queries,
results of calls to system functions, web pages — anything at
all. System identifiers can use any method to name an entity which the
XML parser's interface to its operating environment can use to elicit
data from the environment.</note> We might define the same entity as
referring to a web page: <egXML
xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY ChapTwo
SYSTEM "http://www.tei-c.org/P4X/p4chap2.xml">]]></egXML>
</p>
<p>System identifiers are, by their nature, system dependent; in the
interests of data portability, therefore, XML provides another way of
declaring external entities, shown here:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY p3.sg PUBLIC
"-//TEI//TEXT Guidelines Chapter on XML//EN" "p4chap2.xml">]]></egXML>
Here, the keyword <code>SYSTEM</code> has been replaced by the keyword
<code>PUBLIC</code>, and the system identifier has been preceded by a
special string known as a <term>formal public identifier</term>.
Although public identifiers can (in principle) take virtually any
form; it is usual to use the form shown above, in which the delimiters
<mentioned>//</mentioned> divide the identifier into the following
parts: <list type="gloss"><label>TEI</label> <item>indicates the owner
of this public identifier (often but not necessarily the owner of the
data in question); the preceding <mentioned>-</mentioned> signals that
this particular owner identifier is not registered with ISO (a
<mentioned>+</mentioned> would imply that one could find out the full
name and address of the owner from the official registry of owner
identifiers)</item> <label>TEXT</label> <item>is a keyword indicating
the nature of the entity: other legal values are <code>DOCUMENT</code>
(for full XML documents), <code>DTD</code> (for document type
declarations), <code>ELEMENTS</code> (for sets of element
declarations), <code>ENTITIES</code> (for sets of entity
declarations), <code>NOTATION</code> (for notation definitions), and a
number of others which are less frequently needed and will not be
discussed here.</item> <label>Guidelines Chapter on XML</label>
<item>gives a descriptive name to the entity.</item><label>EN</label>
<item>is the ISO language code for the human language in which the
entity is written.</item></list>
</p>
<p>Public identifiers help make XML documents less dependent on
particular computer systems, by making it possible to confine the
mapping between entity names and system identifiers to a single
place. As with other such techniques, they require XML systems to
provide mechanisms for mapping from the public identifiers to file
identifiers or other system identifiers: such a mapping is typically
provided by an additional component known as a <term>catalog
file</term> (<ptr target="#SGPATANC"/>).</p>
   </div>
<div type="div3" xml:id="SG-er"><head>Entity references</head>
<p>Once an entity has been declared it may be referenced anywhere
within a document. This is done by supplying its name prefixed with
the ampersand character and followed by the semicolon.</p>
<p>When an XML parser encounters such an <term>entity
reference</term>, it immediately substitutes the value declared for
the entity name. Thus, the passage <code>The work of the &amp;tei; has
only just begun</code> will be interpreted by an XML processor exactly
as if it read <code>The work of the Text Encoding Initiative has only
just begun</code>. In the case of an external entity, it is, of
course, the contents of the operating system file which are
substituted, so that the passage <code>The following text has been
suppressed: &amp;ChapTwo;</code> will be expanded to include the whole
of whatever the system finds in the file <ident rend="noindex" type="file">p4chap2.xml</ident>.</p>
<p>This obviously saves typing, and simplifies the task of maintaining
consistency in a set of documents.  If the printing of a complex
document is to be done at many sites, the document body itself might use
an entity reference, such as <code>&amp;site;</code>, wherever
the name of the site is required.  Different entity declarations could
then be used at different sites to supply the appropriate string to be
substituted for this name, with no need to change the text of the
document itself.</p>
</div>
<div type="div3" xml:id="SG-ue"><head>Unparsed entities and Notations</head>
<p>An XML entity may contain non-textual information such as pictures,
video, or sound in digitized form. Such objects can be embedded in a
document by reference in exactly the same way as any other external
entity. When such entities are declared, however, it is essential to
indicate that they contain data which an XML parser or processor
cannot handle in the same way as the surrounding data — it is no
use trying to process entities contain pictures or sound as if they
contain text! This is accomplished by including an additional keyword
in the declaration of such entities, as in the following example:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY fig1 SYSTEM "figure1.png" NDATA png>]]></egXML>
 </p>
<p>The keyword <ident type="kw">NDATA</ident> indicates that this external entity is
<term>unparsed</term>: it contains non-XML data which an XML parser
should ignore. It is followed by an additional name (<code>png</code>
in the example above) which identifies the <term>notation</term> used
for this data, that is, the set of conventions which a processor must
understand in order to process the data correctly. XML may itself be
thought of as a notation, which is implied for all external entities
not otherwise labelled. Notations should be declared in a DTD along with
everything else: for the DTD in which the above declaration appears, a
notation declaration like the following would also be appropriate:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!NOTATION png PUBLIC
    '-//TEI//NOTATION IETF RFC2083 Portable Network Graphics//EN'>]]></egXML>
This gives a formal public identifier for the place where the notation
<code>png</code> is defined.</p>
<p>More detailed discussion of external unparsed entities and of
recommended graphics notations are given in section <ptr target="#FTGRA"/> of the Guidelines.</p></div>
<div type="div3" xml:id="SG-pe"><head>Parameter entities</head>
<p>A special form of entities, <term>parameter entities</term>, may be
used within XML markup declarations; these differ from the entities
discussed above (which technically are known as <term>general
entities</term>) in two ways:
<list type="bullets">
<item>Parameter entities are used <emph>only</emph> within XML markup
declarations; they may not appear  within the document
itself.</item>
<item>Parameter entity references are delimited by percent sign and semicolon,
rather than by ampersand and semicolon.</item></list>
</p> 
<p>Declarations for parameter entities take the same form as those for
general entities, but insert a percent sign between the keyword
<code>ENTITY</code> and the name of the entity itself.  Whitespace characters
(blanks, tabs, or line breaks) must occur on both sides of the percent
sign.  For example, an internal parameter entity named <ident type="pe">a.global</ident> might be declared with the  expansion
<code>id ID #REQUIRED  rend CDATA #IMPLIED</code> as follows:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % a.global 
         'id ID #REQUIRED  rend CDATA #IMPLIED'>]]></egXML>
</p>
<p>With this declaration at the start of a DTD, the task (for example) of declaring
attributes consistently on all elements within a DTD becomes much
simpler: all that is needed is to reference the parameter entity, as
in this example:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ATTLIST myElement %a.global;
                    another CDATA #IMPLIED >]]></egXML>
since the attribute list  for <tag>myElement</tag> will now be
understood to contain whatever list of attribute definitions was
declared as the value for the parameter entity <ident type="pe">a.global</ident>, followed by the definition for an
attribute called <att>another</att>.</p>
<p>Moreover, if we wish to change the global attributes
or add another, all we need do is provide a new declaration for <ident type="pe">a.global</ident> in the DTD. We do not even need to modify
the existing declaration, but simply ensure that the new one precedes
the old one in the DTD being processed. This is because of one very significant aspect of entity
declarations not mentioned above: if a declaration is given for the
same entity more than once, then only the first declaration is
applicable. If, for example, an XML processor finds the following:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY switch "UP"> 
<! - - several other declarations - ->
<!ENTITY switch "DOWN">
<!ENTITY switch "SIDEWAYS">
<!- - .... - ->
The switch is &switch;]]></egXML>
then the entity reference at the end (assumed to be inside a document)
will be resolved as the string "UP" because that is the first
declaration encountered. This rule applies equally to general entities
and parameter entities, and has important consequences for the TEI
scheme. The TEI DTD makes extensive use of parameter
entities to control the selection of different tag sets. They are also used to control the behaviour of conditional marked sections, as further discussed in section <ptr target="#SG-cond"/> below.</p></div></div>
<div type="div2" xml:id="SG17BIS"><head>Marked sections</head>
<p>It is occasionally necessary to mark some portion of an XML
document for special treatment.  Within the body of a document, it is
often convenient to be able to mark some portion as containing XML
markup which is to be ignored. Within a DTD, it is often convenient to
mark certain parts to be included or excluded in specific
circumstances. To deal with the former situation, XML defines a
construct known as a <term>CDATA marked section</term>; to deal with
the latter, a syntactically similar construct known as a
<term>conditional marked section</term> may be used.</p>
<p>Most users of the TEI encoding scheme will never need to use marked
sections, and may safely skip the remainder of this discussion.  The
TEI DTD makes extensive use of conditional marked sections, however,
and this section should be read carefully by anyone wishing to follow
in detail the discussions in chapter <ptr target="#ST"/> of the
Guidelines.</p>
<div type="div3" xml:id="SG-cond"><head>CDATA marked section</head>
<p>A <code>CDATA</code> marked section is delimited by two rather
arcane sequences of characters: its start is marked by the string
<code>&lt;![CDATA[</code>, and its end by the string
<code>]]&gt;</code>. Note that spaces are not permitted within either
string.</p>
<p>Within a <code>CDATA</code> marked section any strings of characters which look
like XML tags or entity references will not be recognized as such by
the XML parser: they are thus a very useful way of including examples
of XML tagging within a document itself written in XML. For example:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p>The
<gi>term</gi> element may be used to mark any technical
term: <eg>&lt;![CDATA[ This &lt;term&gt;recursion&lt;/term&gt;
is giving me a headache. ]]&gt;</eg></p></egXML>
</p>
<p>In this extract from a document describing the way that an XML
element called <gi>term</gi> may be used, the cited example (tagged
with a <gi>eg</gi> element) includes an instance of the <gi>term</gi>
element which will not be recognised as such, but simply as a string
of characters, because it is contained by a marked section.</p>
<p>A similar effect can be achieved by simply replacing the angle
brackets by entity references, but this makes the text somewhat
unreadable in its native XML form if the example is of any length:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p>The <gi>term</gi> element may
  be used to mark any technical term: <eg>This &amp;lt;term&amp;gt;recursion&amp;lt;/term&amp;gt; is giving me a headache.
</eg></p>
</egXML>
</p>
</div>
<div type="div3" xml:id="SG-cms"><head>Conditional marked section</head>
<p>The <code>CDATA</code> marked section is a special case of the more
general <term>marked section</term> construct. Within the body of a
DTD (but not within the body of a document), two other kinds of marked
section are possible: an <code>IGNORE</code> marked section, and an
<code>INCLUDE</code> marked section. As the names suggest, material
within an <code>IGNORE</code> marked section is ignored during
processing, while material within an <code>INCLUDE</code> marked
section is included. These can be used to include and exclude portions
of a DTD selectively, so as to adjust it to relevant
circumstances.</p>
<p>Suppose, for example, that we want to allow for poems which contain
either only stanzas, or only couplets. A content model to enforce this
rule is easy to define, but it does require us to to declare both
possibilities — we must provide declarations for both
<gi>stanza</gi> and <gi>line</gi> elements, even though in a given
document we know that only one will appear. An alternative approach
might be to provide two different declarations for <gi>poem</gi>, as
follows: <egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[
<![INCLUDE[ <!ELEMENT poem (stanza+)> 
<!ELEMENT stanza (line+)> ]]
<![IGNORE[ <!ELEMENT poem (couplet+)> 
<!ELEMENT couplet (line,line)> ]]
]]></egXML>
The first declaration here will be the one used, since it is within an
<code>INCLUDE</code> marked section. The second one will be ignored. To swap
around, we change <code>INCLUDE</code> to <code>IGNORE</code>, and vice-versa.</p>
<p>The literal keywords <code>INCLUDE</code> and <code>IGNORE</code>,
however, are not much use in adjusting a DTD or a document to a user's
requirements.  If modifying a DTD to match user requirements involves
editing the text manually (changing <code>IGNORE</code> to
<code>INCLUDE</code> as appropriate), it is probably just as easy to
add or delete the affected parts of the DTD directly. However, the
<code>IGNORE</code> and <code>INCLUDE</code> keywords need not be
given as literal values; they can also be represented by a parameter
entity reference.</p>
<p>In the following DTD example, we have replaced the keywords by
references to two parameter entities:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[
<![%stanzas;[
   <!ELEMENT poem (stanza+)> 
   <!ELEMENT stanza (line+)> 
   <!ENTITY couplets "IGNORE">
]]
<![%couplets;[
   <!ELEMENT poem (couplet+)> 
   <!ELEMENT couplet (line,line)> 
]]
]]></egXML>
The exact meaning of this will depend on the values of the parameter
entities <ident type="pe">stanzas</ident> and <ident type="pe">couplets</ident> when the
DTD is processed. When parameter entities are used in this way to
control marked sections in a DTD, the  DTD file must
contain default declarations for them.  If the user wishes to override
any of the
defaults, all that needs to be done is to supply a new declaration and
ensure that it will be processed before the existing default. The
easiest way of doing this is to supply it within a special part of the
DTD known as the <term>DTD subset</term>.<note place="foot">This is
explained in more detail in section <ptr target="#SG182"/> below; the
key point for our present purposes is that declarations in the DTD
subset are always read before those in the external DTD file, and, as
mentioned above in section <ptr target="#SG-pe"/>, the first
declaration of a given entity is the one which counts.</note></p>
<p>With the following default declarations, poems will consist only of
stanzas and the second set of declarations will be ignored:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % stanzas "INCLUDE">
<![%stanzas;[
   <!ELEMENT poem (stanza+)> 
   <!ELEMENT stanza (line+)> 
   <!ENTITY % couplets "IGNORE">
]]<![CDATA[>
<!ENTITY % couplets "INCLUDE">
<![%couplets;[
   <!ELEMENT poem (couplet+)> 
   <!ELEMENT couplet (line,line)> 
]]
]]></egXML>
This works because, although there are two declarations for the
parameter entity <ident type="pe">couplets</ident>, only the first is
effective. It declares the parameter entity <ident type="pe">couplets</ident> to
have the value <code>IGNORE</code>, and so the declarations within the
second conditional marked section are ignored. Suppose however that a
declaration for <ident type="pe">stanzas</ident> giving it the value
<code>IGNORE</code> were processed before this part of the DTD. In
that event, only the second declaration for the entity
<ident type="pe">couplets</ident> would be effective, since all the declarations
within the conditional marked section governed by
<ident type="pe">stanzas</ident> would be ignored.</p>
<p>Variations on this technique are used to control how the various
parts of a TEI DTD are constructed. For example:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[
<!ENTITY % TEI.prose 'INCLUDE'>
<!ENTITY % extensions SYSTEM 'mystuff.dtd'>
]]></egXML>
These declarations have two effects: they activate a section of the
DTD containing declarations relevant to prose and they add into the
DTD whatever additional declarations are held in the external file
<ident type="file">mystuff.dtd</ident>. In the standard DTD files,
there is a marked section controlled by the parameter entity <ident
type="pe">TEI.prose</ident>, the default value of which is
<code>IGNORE</code>, and there is also a reference to the parameter
entity <ident type="pe">extensions</ident>, the default value for
which is the null string. The declarations cited above over-ride both
these defaults: the declarations within the marked section controlled
by the parameter entity <ident type="pe">TEI.prose</ident> are thus
made active; and the reference to the <ident
type="pe">extensions</ident> parameter entity is replaced by the
content of the file <ident
type="file">mystuff.dtd</ident>.</p></div></div>
-->

<!--
<div type="div3"><head>Default value</head> 
<p>The last piece of information in
each attribute declaration specifies how a parser should interpret the
absence of the attribute concerned.  This can be done by supplying one
of the special keywords listed below, or (as in this case) by
supplying a specific value which is then regarded as the value for
every element which does not supply a value for the attribute
concerned.  Using the example above, if a poem is simply tagged
<tag>poem</tag>, the parser will treat it exactly as if it were tagged
<tag>poem status="draft"</tag>.  Alternatively, it is possible to
specify a default value for an attribute. Thus, if the attribute
declaration above were rewritten in DTD language as
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ATTLIST poem   id ID #IMPLIED 
                 status (draft | revised | published) #REQUIRED >]]></egXML>
then poems which appear in the anthology simply tagged <tag>poem</tag>
would be reported as erroneously tagged, as would any for which some
value other than <val>draft,</val> <val>published,</val> or
<val>revised</val> were supplied.</p></div> -->

<!--

<div type="div3" xml:id="SG182"><head>The <code>DOCTYPE</code> declaration</head>
<p>An XML file which is valid (as opposed to simply well-formed) can
specify a schema against which its content is to be validated. This is
the function of the <code>DOCTYPE</code> declaration. If you use
schemas, the particular schema you wish to validate a document against
is usually specified externally.</p>
<p>The <code>DOCTYPE</code> declaration contains, following the
<code>DOCTYPE</code> keyword, at least two parts: the name of the root
element for the associated document, and a set of declarations for all
the elements, attributes, notations, entities, etc. which together
define the document type declaration (schema) of that document. Note,
incidentally, that the root element name (and hence the
<code>DOCTYPE</code> name) may be that of any element whose
declaration is supplied in this set. The declarations may be supplied
explicitly, or by reference to an external entity such as a file, or
by a combination of the two.
</p>
<p>Taking each of these possibilities in turn, we first present a <code>DOCTYPE</code> declaration in which the declarations for all the elements, attributes, etc. required are given explicitly:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!DOCTYPE myDoc [
  <!ELEMENT myDoc (p+) >
  <!ATTLIST myDoc n CDATA #IMPLIED>
  <!ELEMENT p (#PCDATA)>
]>
<myDoc n="1">
  <p>This is an instance of a "my.doc" document</p>
</myDoc>]]></egXML>
Note that the required declarations are enclosed within square brackets inside the <code>DOCTYPE</code> declaration: this part of the declaration is technically known as the <term>schema subset</term>.</p>
<p>More usually, however, the required  declarations  will be held in a
separate entity and invoked by reference, as follows:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!DOCTYPE myDoc SYSTEM "myDoc.dtd" []>
<myDoc>
  <p>This is another instance of a "myDoc" document.</p>
  <p>It has two paragraphs.</p>
</myDoc>]]></egXML>
Note the similarity between the syntax used to reference the external
entity containing the required declarations and that used to define
any other system entity (see <ptr target="#SG-ents"/>). The square
brackets may be supplied even though they enclose nothing, as in this
example, or they may be omitted.</p>
<p>Next, we present a case where declarations are given both within the schema subset and by reference to an external entity:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!DOCTYPE myDoc SYSTEM "myDoc.dtd" [
  <!ENTITY tla "three letter acronym">]>
<myDoc>
  <p>This is yet another instance of a "myDoc" document.</p>
  <p>It is surprisingly free of &tla;s.</p>
</myDoc>]]></egXML>
</p>
<p>Any kind of declaration may be added to a schema subset; as we have
already seen (<ptr target="#SG-cms"/>), this is the mechanism by which the TEI schema is
customized. 
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!DOCTYPE TEI PUBLIC "-//TEI P3//schema Main Document Type//EN" "tei2.dtd" [
  <!ENTITY % TEI.prose 'INCLUDE'>
  <!ENTITY % TEI.XML   'INCLUDE'>
  <!ENTITY tla "Three Letter Acronym">
  <!ENTITY % x.phrase  'myTag|'>	 
  <!ELEMENT myTag (#PCDATA)    >
  <!- - any other special-purpose declarations or
       re-declarations go  here  - ->
  ]>
<TEI>
  <!- - This is an instance of a modified TEI type document, which
       may contain <myTag>my special tags</myTag> and references 
       to my usual entities such as &tla;. - ->
</TEI>]]></egXML>

When, as here, the document type declaration in force includes both
the contents of the schema subset, and the contents of some external
entity (in the case above, whatever file is specified by the
<code>PUBLIC</code> identifier given, <ident
type="file">tei2.dtd</ident> by default), declarations in the schema
subset are always carried out first.  As noted above, (<ptr
target="#SG-pe"/>), the order is important, because in XML only the
first declaration of an entity counts.  In the above example,
therefore, the declaration of the entity <ident type="ge">tla</ident>
in the schema subset takes precedence over any declaration of the same
entity in the file <ident type="file">tei2.dtd</ident>.  Similarly,
the declaration for <ident type="pe">x.phrase</ident> takes precedence
over the existing declaration for that entity in the TEI dtd. It is
perfectly legal for entities to be declared more than once; elements,
by contrast, may not be declared more than once; if a declaration for
<gi>myTag</gi> were already contained in file <ident
type="file">tei.dtd</ident>, the XML parser would signal an
error.</p></div>

<div type="div3" xml:id="SG183"><head>The Document Instance</head>

<p>The document instance is the content of the document itself.  It
contains only text, markup, and entity references, and thus may
not contain any new declarations.
A convenient way of building up large documents in a modular fashion
might be to use the schema subset to declare entities for the individual
pieces or modules, thus:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!DOCTYPE TEI 
          PUBLIC "-//TEI P4//schema Main Document Type//EN"
		         "tei2.dtd" [
   <!ENTITY % TEI.prose "INCLUDE">
   <!ENTITY % TEI.XML "INCLUDE">
   <!ENTITY chap1 SYSTEM "chap1.txt">
   <!ENTITY chap2 SYSTEM "chap2.txt">
   <!ENTITY chap3 "- - not yet written - -">
   ]>
<TEI>
  <teiHeader> <!- - ... - -> </teiHeader>
    <text>
      <body>
        &chap1;
        &chap2;
        &chap3;
        <!- - ... - ->
     </body>
  </text>
</TEI>]]></egXML></p>

<p>In this example, the TEI schema has been extended by entity
declarations for each chapter of some document.  The first two are
external entities referring to the file in which the text of
particular chapters is to be found; the third a dummy, indicating that
the text does not yet exist (alternatively, an entity with a null
value could be used).  In the document instance, the entity references
<code>&amp;chap1;</code>, etc. will be resolved by the parser to give
the required contents.  The chapter files themselves will not, of
course, contain any element, attribute list, or entity declarations –
just tagged text.</p></div>






<div type="div3" xml:id="SGPATANC"><head>Ancillary Files</head>

<p>A working XML system is likely to use a number of ancillary files
to hold configuration information.  These may include stylesheets,
specialized processing instructions, collections of relevant entity
declarations, setup information for specific programs, and many other
components. In general, the ways in which such components are to be
assembled or configured vary with the system and cannot readily be
described here.</p>

<p>To assist in this process many systems take advantage of an
additional <term>catalog file</term>, the chief function of which is
to associate the formal public identifiers used in a document or schema
with specific system entities, over-riding any default
association. One widely used format for such catalog files was defined
by an industry group originally known as SGML Open, and such files are
therefore known as SGML Open catalogs, even though they may also be
used by XML processors. The group has more recently redefined itself
under the name of the Organization for the Advancement of Structured
Information Standards (OASIS), and in August 2001 published a
specification for catalog files in XML form. <note place="foot">The
SGML Open catalog format is documented in <bibl>SGML Open Technical
Resolution 9401:1997, <title>Entity Management</title></bibl>, which
is available from <ptr
target="http://xml.coverpages.org/sotr9401-a2.html"/>; the XML Catalog
specification, also produced by OASIS is available from their site at
<ptr
target="http://www.oasis-open.org/committees/entity/spec.html"/>.</note>
Catalog files in both SGML Open and XML formats are distributed along
with the current TEI schemas.</p>
</div></div>
</div>


-->


<!--
Copyright TEI Consortium. 
Licensed under the GNU General Public License. 
See the file COPYING for details.
$Date$
$Author$
-->
<div1 xmlns="http://www.tei-c.org/ns/1.0" type="Chapter" xml:id="ST" n="3">

<head>The TEI infrastructure</head>

<p>This chapter describes the infrastructure for the encoding scheme
defined by these Guidelines.  It introduces the conceptual framework
within which the following chapters are to be understood, and
describes the technical means by which that conceptual framework is
implemented.  It assumes some familiarity with XML and XML schemas
(see chapter <ptr target="#SG"/>) but is intended to be accessible to
any user of these Guidelines. </p>

<p>The TEI encoding scheme consists of a number of
<term>modules</term>, each of which declares particular XML elements
and their attributes. Part of an element's declaration includes its
assignment to one or more element <term>classes</term>. Modules, and
their contents, may be combined more less freely to form a
<term>schema</term> appropriate to a particular set of
requirements. It is also possible to add new elements which reference
existing classes or elements to a schema, as it is to remove existing
elements from a schema.
	</p>

<p>In principle, a TEI schema may be constructed using any combination
of modules. However, certain TEI modules are of particular importance,
and should always be included in all but exceptional circumstances:
the module <ident type="module">tei</ident> described in the present
chapter is of this kind because it defines classes, macros, and
datatypes which are used by all other modules. The <ident
type="module">core</ident> module, defined in chapter <ptr
target="#CO"/> contains declarations for elements and attributes which
are likely to be needed in almost any kind of documents, and is
therefore recommended for global use. The <ident
type="module">header</ident> module defined in chapter <ptr
target="#HD"/> provides declarations for metadata elements and
attributes required for TEI conformance, while the <ident
type="module">text-structure</ident> module defined in chapter <ptr
target="#DS"/> declares basic structural elements needed for the
encoding of almost any text-like object. Most schemas will therefore
need to include these four modules, but are free to mix and match them
with others.</p>

<p>The specification for a TEI schema is itself a TEI document, using
elements from the module described in chapter <ptr target="#TD"/>: we
refer to such a document informally as an <term>ODD</term> document,
from the abbreviation <q>One Document Does it all</q>. Stylesheets for
maintaining and processing ODD documents are maintained by the TEI,
and these Guidelines are also maintained as an ODD. An ODD document
can be processed to generate a schema expressed using any of the three
schema languages currently in wide use: the XML DTD language, the ISO
RelaxNG language, or the W3C Schema language. </p>

<p>This chapter begins by briefly characterizing each of the modules
available in the TEI scheme. Section <ptr target="#STIN" type="div2"/>
describes in general terms the method of constructing  a TEI schema
in a specific schema language such as XML DTD language, RelaxNG, or
W3C Schema. </p>

<p>The <term>global attributes</term>, characteristics postulated of
every element  in the encoding scheme, are discussed in section 
<ptr target="#STGA" type="div2"/>.</p>

<p>The bulk of the chapter describes the TEI infrastructure
module itself. Although it may be skipped at a first reading, an
understanding of the topics addressed here is essential for anyone
planning to take full advantage of the TEI customization techniques
described in chapter <ptr target="#MD"/>. </p>

<p>In particular, the infrastructure module provides the following
components of the TEI encoding scheme:
<list>
<item>definition of all <term>datatypes</term> used to constrain the
range of legal values for TEI attributes (section <ptr
target="#DTYPES"/>)</item>
<item>declarations for all 
<term>element classes</term> used to define groups of elements and
their characteristics (section <ptr target="#STEC"/>)</item>
<item>definition of all <term>macros</term> used to express some
commonly used content models (section <ptr target="#STmacros"/>)</item>
</list>
</p>

<p>Finally, in section <ptr target="#STPE"/>, the chapter describes
the implementation methods used to generate TEI conformant schema
fragments, in particular for XML DTDs. </p>


<div2 xml:id="STMA"><head>TEI modules</head>

<p>These Guidelines define a large number of elements and attributes
for marking up documents of any kind. Each definition combines a prose
description, provided within a chapter of the Guidelines and in the
reference lists, with a formal declaration, expressed for reference by
means of the ISO schema language RelaxNG. For convenience, each
element is assigned to a single module: the declaration file for each
module thus contains a set of related element declarations, typically
for use in some specific application area, or to support a particular
kind of usage.
 </p>

<p>Corresponding with each module, the TEI provides a <term>schema
fragment</term> in each of three supported schema languages. A TEI
schema is made by combining these fragments, each of which contains
sets of declarations, as further described in section <ptr
target="#STIN"/> below. </p>
<p>For RelaxNG and W3C each module generates a single schema
fragment with the same name as the module. For XML DTD fragments,
however, some  modules generates two fragments: for example
the <ident type="module">analysis</ident> module generates fragments
called <ident type="schemafrag">analysis-decl</ident> and <ident
type="schemafrag">analysis</ident>. This is because the declarations
they contain are needed at different points in the creation of
an XML DTD. The fragment suffixed <ident>-decls</ident> will
typically contain additional class or macro declarations that
complement those provided by the present chapter; for technical
reasons, these must be available separately from the additional
element and attribute declarations contained by the main fragment.  </p>
<p>The following table lists the modules defined by the
current release of the Guidelines:

<!-- table can be re-autogenerated from modules.xsl LB 20-xii-05 -->


<table>
<row role="label">
<cell>Schema fragment</cell>
<cell>Formal public identifier</cell>
<cell>Where defined</cell>
</row>
<row><cell>analysis-decl</cell><cell>Class declarations for Analysis and Interpretation</cell><cell><ptr target="#AI"/></cell></row>
<row><cell>analysis</cell><cell>Analysis and Interpretation</cell><cell><ptr target="#AI"/></cell></row>
<row><cell>certainty</cell><cell>Certainty and Uncertainty</cell><cell><ptr target="#CE"/></cell></row>
<row><cell>concurrent-decl</cell><cell>Concurrent Document Type for Page and Line References</cell><cell><ptr target="#CO"/></cell></row>
<row><cell>core</cell><cell>Common Core</cell><cell><ptr target="#CO"/></cell></row>
<row><cell>corpus</cell><cell>Metadata for Language Corpora</cell><cell><ptr target="#CC"/></cell></row>
<row><cell>declarefs</cell><cell>Feature System Declaration</cell><cell><ptr target="#FD"/></cell></row>
<row><cell>dictionaries-decl</cell><cell>Class declarations for Print Dictionaries</cell><cell><ptr target="#DI"/></cell></row>
<row><cell>dictionaries</cell><cell>Print Dictionaries</cell><cell><ptr target="#DI"/></cell></row>
<row><cell>drama-decl</cell><cell>Class declarations for Performance Texts</cell><cell><ptr target="#DR"/></cell></row>
<row><cell>drama</cell><cell>Performance Texts</cell><cell><ptr target="#DR"/></cell></row>
<row><cell>figures</cell><cell>Tables, Formulae, Figures</cell><cell><ptr target="#FT"/></cell></row>
<row><cell>gaiji</cell><cell>Character and Glyph documentation</cell><cell><ptr target="#WD"/></cell></row>
<row><cell>header</cell><cell>Common Metadata</cell><cell><ptr target="#HD"/></cell></row>
<row><cell>iso-fs</cell><cell>Feature Structures</cell><cell><ptr target="#FS"/></cell></row>
<row><cell>linking-decl</cell><cell>Class declarations for Linking, Segmentation, and Alignment</cell><cell><ptr target="#SA"/></cell></row>
<row><cell>linking</cell><cell>Linking, Segmentation, and Alignment</cell><cell><ptr target="#SA"/></cell></row>
<row><cell>msdescription</cell><cell>Manuscript Description</cell><cell><ptr target="#MS"/></cell></row>
<row><cell>namesdates-decl</cell><cell>Class declarations for Names and Dates</cell><cell><ptr target="#ND"/></cell></row>
<row><cell>namesdates</cell><cell>Names and Dates</cell><cell><ptr target="#ND"/></cell></row>
<row><cell>nets</cell><cell>Graphs, Networks and Trees</cell><cell><ptr target="#GD"/></cell></row>
<row><cell>spoken-decl</cell><cell>Class declarations for Transcribed Speech</cell><cell><ptr target="#TS"/></cell></row>
<row><cell>spoken</cell><cell>Transcribed Speech</cell><cell><ptr target="#TS"/></cell></row>
<row><cell>tagdocs-decl</cell><cell>Class declarations for Documentation Elements</cell><cell><ptr target="#TD"/></cell></row>
<row><cell>tagdocs</cell><cell> Documentation Elements</cell><cell><ptr target="#TD"/></cell></row>
<row><cell>tei</cell><cell>TEI Infrastructure</cell><cell><ptr target="#ST"/></cell></row>
<row><cell>textcrit-decl</cell><cell>Class declarations for Text Criticism</cell><cell><ptr target="#TC"/></cell></row>
<row><cell>textcrit</cell><cell>Text Criticism</cell><cell><ptr target="#TC"/></cell></row>
<row><cell>textstructure</cell><cell>Default Text Structure</cell><cell><ptr target="#DS"/></cell></row>
<row><cell>transcr</cell><cell>Transcription of Primary Sources</cell><cell><ptr target="#PH"/></cell></row>
<row><cell>verse-decl</cell><cell>Class declarations for Verse</cell><cell><ptr target="#VE"/></cell></row>
<row><cell>verse</cell><cell>Verse</cell><cell><ptr target="#VE"/></cell></row>
</table>
</p></div2>

<div2 xml:id="STIN"><head>Defining a TEI schema</head>

<p>To determine that an XML document is valid (as opposed to
merely well-formed), its structure must be checked against a
schema. For a valid TEI document, this schema must be a conformant TEI
schema, as further defined in chapter <ptr target="#CF"/>.  Local
systems may allow their schema or DTD to be implicit, but for
interchange purposes the schema associated with a document
<emph>must</emph> be made explicit. </p>

<p>As previously noted, the TEI provides an application independent
way of specifying the components of a TEI schema by means of the
<gi>schemaSpec</gi> element defined in chapter <ptr target="#TD"/>
element. A running XML system, such as a validating editor, may use
this specification in several different ways:

<list>
<item>the ODD specification may be automatically processed to generate
a schema document in whichever schema language the editor
supports</item>
<item>for an editor using DTD language, a DTD subset declaration
invoking the DTD fragments corresponding with the schema specification
may be produced, together with XML DTD code for any additional
modifications</item>
<item>for an editor using RelaxNG language, a schema referencing the
appropriate predefined RelaxNG patterns may be produced, together
with any additional definitions required to support
modifications</item>
</list>
</p>
<p>The schema fragments produced by the TEI are delivered in a
parameterised form which facilitates the second and third options
listed above. The recommended method of customization is however the
first. For blind interchange of TEI documents, it should be necessary
to supply no more than a complete ODD specification along with the
documents.
</p>

<p>The simplest customization of the TEI scheme combines just the
four recommended modules mentioned above. In ODD format, this would
look like this:
<egXML xmlns="http://www.tei-c.org/ns/Examples">
<schemaSpec ident="TEI-minimal" start="TEI">
  <moduleRef key="tei"/>
  <moduleRef key="header"/>
  <moduleRef key="core"/>
  <moduleRef key="structure"/>
</schemaSpec>
</egXML></p>
<p>This schema specification contains references to each of the four
modules, identified by the <att>key</att> attribute on the
<gi>moduleRef</gi> element. The schema specification itself is also
given an identifier (<ident>TEI-minimal</ident>) and its start point, or
root element, is specified by means of the <att>start</att> attribute.
An ODD processor will generate an appropriate XML DTD, or relaxNG
or W3C schema from this set of declarations, which would then be
associated with the document instance by one of a number of different
mechanisms, as further described in chapter <ptr target="#SG"/><!-- somewhere --> </p>

<p>The same effect might be obtained by means of a RelaxNG
schema like the following:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[
namespace ns1 = "http://www.tei-c.org/ns/1.0"
include "tei.rnc" inherit = ns1
include "core.rnc" inherit = ns1
include "header.rnc" inherit = ns1
include "textstructure.rnc" inherit = ns1
start = TEI 
]>]]></egXML>
which combines the declarations from the filenames specified to form a
schema with the given start point using the nominated namespace. </p>
<p>The same effect might be obtained in a DTD processing environment
by prefixing the document with a <term>DOCTYPE declaration</term> like the following:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!DOCTYPE TEI
PUBLIC "-//TEI P5//DTD Main Document Type//EN" "tei2.dtd" [
      <!ENTITY % TEI.header 'INCLUDE' >
      <!ENTITY % TEI.core 'INCLUDE' >
      <!ENTITY % TEI.structure 'INCLUDE' >
]>]]></egXML>
This uses an indirect method of nominating the DTD schema fragments
from which the DTD is to be constructed, based on the use of parameter
entities, as further discussed in section <ptr target="#STPE"/>.
</p>

<!-- does this belong here? -->
<p>In much of the discussion elsewhere in these Guidelines, it is
generally assumed for clarity of exposition that a text is a unitary
object for which only one module is necessary.  It is not uncommon,
however, for a text to combine different kinds of object, or for an
encoder to wish to enrich their encoding with elements drawn from many
different modules.  Examples include:

<list type="bullets">
<item>when the text is a collection of other texts, which do not all use
the same module:  e.g. an anthology of prose, verse, and drama</item>
<item>when the text contains other smaller, embedded texts:  e.g. a poem
or song included in a prose narrative</item>
<item>when some sections of the text are written in one form, and others
in a different form:  e.g. a novel where some chapters are in prose,
others take the form of dictionary entries, and still others the form of
scenes in a play</item>
<item>when the text moves back and forth among forms not between
sections but within a single section:  e.g. mixed prose-and-verse forms
like many pastorals or like some portions of the Poetic Edda</item></list></p>
<p>The TEI DTD provides the following mechanisms to handle these cases:
<list type="bullets">
<item>a definition of a corpus or collection as a series of
<gi>TEI</gi>
documents, sharing a common TEI header (see chapter <ptr target="#CC"/>)</item>
<item>a definition of composite texts which comprise front matter, a
group or several possibly nested groups of collected texts,
themselves possibly composite (see section <ptr target="#DSGRP"/>)</item>
<item>a notion of <term>embedded text</term>
which allows one text to be embedded within another (that is,
<gi>text</gi> is defined as a component-level element, as described
briefly at the conclusion of section <ptr target="#DSGRP"/>)</item></list></p>
<p>The following element specification for example allows for any mixture of
the low level structural tags defined in the prose, drama and dictionary
 modules:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><schemaSpec ident="TEI-Moby" start="TEI">
  <moduleRef key="tei"/>
  <moduleRef key="header"/>
  <moduleRef key="core"/>
  <moduleRef key="structure"/>
  <moduleRef key="drama"/>
  <moduleRef key="dictionaries"/>
  <!-- Structurally, Moby Dick is not your
       everyday common or garden variety novel ... -->
</schemaSpec></egXML></p>
</div2>

<div2 xml:id="STGA"><head>Global Attributes</head>
<p>The following attributes are defined for every TEI element.<note
place="foot">More exactly, these are the attributes of the attribute
class <ident type="class">att.global</ident>, to which all elements
belong; for further discussion of attribute classes and ways in which
attributes may be inherited and over-ridden, see section <ptr
target="#STECAT"/>.</note> <specList><specDesc key="att.global"
atts="xml:id n xml:lang rend"/></specList>
 </p>
<p>Some modules (e.g. those for terminology, linking, and analysis)
define other global attributes; these are documented in the appropriate
chapters of Part III and Part IV.  See also section <ptr target="#STECAT"/>.
 </p>
<p>Any TEI element may be given values for <att>xml:id</att>, <att>n</att>,
<att>xml:lang</att>, <att>rend</att>, or <att>TEIform</att>, simply by
specifying values for these attributes.
The following two examples convey the same information about the text:
that the material transcribed occurs within a <gi>p</gi> element
(paragraph).  They differ only in that the second provides an identifier
for the paragraph, to which other elements (e.g. notes or hypertext
links) can conveniently refer.
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p>If to do were as easy as to know what were
good to do, chapels had been churches and poor men's cottages
princes' palaces.  It is a good divine that follows his own
instructions ...</p></egXML>
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p xml:id="mv1.2.5">If to do were as easy as to know what were
good to do, chapels had been churches and poor men's cottages
princes' palaces.  It is a good divine that follows his own
instructions ...</p></egXML>
<!-- Merchant of Venice, I.ii, speech 5 (Portia)              -->
</p>
  <p>The values of <att>xml:id</att> attributes must be legal
	<ident type="kw">names</ident> with respect to the SGML declaration in
	force. For XML documents this means that an <att>xml:id</att> value
	must begin with a letter (as defined in the World Wide Web
	Consortium's XML Recommendation) or the underscore charcter
	(<q>_</q>), and contain no characters other than letters, digits,
	hyphens, underscores, full
	stops, and certain combining and extension characters.<note place="foot">The colon is also by default a
	valid name character; however, it is reserved for a specific
	purpose in XML (to indicate namespace prefixes), and is not
	therefore generally recommended by these Guidelines, for
	compatability reasons.</note></p>
  <p>In XML names (and thus the values of <att>xml:id</att> in an XML TEI
	document) upper and lower case letters are distinguished, and
	thus <mentioned>partTime</mentioned> and
	<mentioned>parttime</mentioned> are two distinctly different
	names, and could (perhaps unwisely) be used to denote two
	different element types.</p>
  <p>If two elements are given the same identifier,a validating XML parser will
	signal a syntax error. The following example, therefore, is
	<emph>not</emph> valid:
<egXML xmlns="http://www.tei-c.org/ns/Examples">&lt;p xml:id="PAGE1"><q>What's it going to be then, eh?</q>&lt;/p>
<p xml:id="PAGE1">There was me, that is Alex, and my three droogs,
that is Pete, Georgie, and Dim, ... </p></egXML>
<!-- Clockwork Orange, opening -->
</p>
<p>For a discussion of methods of providing unique identifiers for
elements, see section <ptr target="#CORS2"/>.</p>
<p>The <att>n</att> attribute allows identifying information (e.g.
chapter numbers, etc.) to be encoded even if it would not be a legal
<att>xml:id</att> value.  Its value may be any string of characters;
typically it is a number or other similar enumerator or label.  For
example, the numbers given to the items of a numbered list may be
recorded with the <att>n</att> attribute; this would make it possible to
record errors in the numeration of the original, as in this list of
chapters, transcribed from a faulty original in which the number 10 is
used twice, and 11 is omitted:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><list type="ordered">
  <item n="1">About These Guidelines</item>
  <item n="2">A Gentle Introduction to SGML</item>
  <item n="9">Verse</item>
  <item n="10">Drama</item>
  <item n="10">Spoken Materials </item>
  <item n="12">Printed Dictionaries</item>
</list></egXML>
The <att>n</att> attribute may also be used to record non-unique names
associated with elements in a text, possibly together with a unique
identifier as in the following example start-tags:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><div type='chap' n='One' xml:id='TXT0101'/></egXML>
<egXML xmlns="http://www.tei-c.org/ns/Examples"><div type='stanza' n='xlii'/></egXML>
 </p>
<p>The <att>xml:lang</att> attribute indicates the language, writing system,
and character set associated with a given element and all its contents.
If it is not specified, the value is inherited from that of the
immediately enclosing element.  As a rule, therefore, it is simplest to
specify the base language of the text on the <gi>TEI</gi> element, and
allow most elements to take the default value for <att>xml:lang</att>; the
language of an element then need be explicitly specified only for
elements in languages other than the base language.
 </p>
<p>The values used for the <att>xml:lang</att> attribute must be
constructed in a particular way, using values from standard lists. See
further <ptr target="#CHSH"/>.</p>
<p>The following two encodings convey the same information about the
language of the text, since in the first the <att>xml:lang</att> attributes
on the <gi>emph</gi> elements specify the same value as that on the
parent <gi>p</gi> element, while in the second they inherit that value
without specifying it.
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p xml:lang="en"> ... Both parties deprecated war, but one of
 them would <emph xml:lang="en">make</emph> war rather than let
 the nation survive, and the other would <emph xml:lang="en">accept
 </emph> war rather than let it perish, and the war came.</p></egXML>
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p xml:lang="en"> ... Both parties deprecated war, but one of
 them would <emph>make</emph> war rather than let
 the nation survive, and the other would <emph>accept</emph>
 war rather than let it perish, and the war came.</p></egXML>
<!-- Lincoln's Second Inaugural Address, 4 March 1865, rpt.   -->
	<!-- (from Richardson, ed., Messages and Papers, 6:276ff) in  -->
	<!-- H. S. Commager, ed., Documents of American History, 5th  -->
	<!-- ed.  (New York:  Appleton-Century-Crofts, 1949), p.      -->
	<!-- 442.                                                     -->
 </p>
<p>In the following example, by contrast, the <att>xml:lang</att> attribute
on the <gi>term</gi> element must be given if we wish to record the fact
that the technical terms used are Latin rather than English; no
<att>xml:lang</att> attribute is needed on the <gi>q</gi> element, by
contrast, because it is in the same language as its parent.  It is
strongly recommended that all language shifts in the source be
explicitly identified by use of the <att>xml:lang</att> attribute, as
described in chapter <ptr target="#CH"/>.
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p xml:lang="en">The constitution declares <q>that no bill of attainder
or <term xml:lang="la">ex post facto</term> law shall be passed.</q> ... </p></egXML>
<!-- Marbury v. Madison, 1 Cranch, 137 (1803), rpt. in H. S.  -->
	<!-- Commager, ed., Documents of American History, 5th ed.    -->
	<!-- (New York:  Appleton-Century-Crofts, 1949), p. 192.      -->
</p>
<p>As further discussed in section <ptr target="#CHSH"/>, additional
information  about a particular language
may be supplied in the <gi>language</gi> element within the header (see
section <ptr target="#HD41"/>).</p>
<p>The <att>rend</att> attribute is used to give information about the
physical presentation of the text in the source.  In the following
example, it is used to indicate that both the emphasized word and the
proper name are printed in italics:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p> ... Their motives <emph rend="italics">might</emph> be
 pure and pious; but he was equally alarmed by his knowledge
 of the ambitious <name rend="italics">Bohemond</name>, and
 his ignorance of the Transalpine chiefs: ...</p></egXML>
<!-- Gibbon, Decline and Fall, chapter 58, para beginning     -->
	<!-- 'In some Oriental tale I have read ...', p. 391 of       -->
	<!-- Britannica edition.                                      -->
	<!--  ... played fast and loose with by LB for pedagogic purposes -->
	<!-- Shame, shame.                                            -->
If all or most <gi>emph</gi> and <gi>name</gi> elements are rendered in
the text by italics, it will be more convenient to register that fact in
the TEI header once and for all and specify a <att>rend</att> value
only for any elements which deviate from the usual rendition.
 </p>
<p>The contents of the <att>rend</att> attribute are free text.  In any
given project, encoders are advised to settle on a standard vocabulary
with which to describe typographic or manuscript rendition of the text,
and to document their usage of that vocabulary in the <gi>rendition</gi>
element of the TEI header. </p>
</div2>


<div2 xml:id="STOV"><head>The TEI infrastructure module</head>

<p>The TEI infrastructure module is a required component of any TEI
schema. It provides declarations for all datatypes, and for the
attribute classes, model classes, and macros used by other modules in
the TEI scheme. Its components are listed below in alphabetical order:
<!-- only they aren't-->
<moduleSpec xml:id="DSTTEI2"  ident="tei" type="core">
<altIdent type="FPI">TEI Infrastructure</altIdent>
<desc>Declarations for datatypes, classes, and macros available to all
TEI modules</desc>
</moduleSpec>
</p>

<p>The order in which declarations are provided within the
infrastructure module is critical, since several declarations refer to
others, which must therefore precede them. Other constraints on the
order of declarations derive from the way in which the modularity of
the TEI scheme is implemented in different schema languages. The XML
DTD fragment implementing this TEI module make extensive use of
<term>parameter entities</term> and <term>marked sections</term> to
effect a kind of conditional construction; the RelaxNG schema fragment
similarly predeclares a number of patterns with null
(<soCalled>notAllowed</soCalled>) values. These techniques are further
explained in chapter <ptr target="#SG"/>. </p>

<p>The ODD processor which generates schema fragments from the text of
the present chapter operates as follows:

<!-- to be supplied -->

components of the infrastructure module are automatically
generated by the ODD processor. Most of these are needed only for the XML
DTD implementation; they are noted below with the phrase <soCalled>DTD
only</soCalled>. </p>

<p>The overall structure of the infrastructure module is as follows:
<list>
<item>Initialisation: 
<list>
<item>Declare TEI.XML marked section to permit SGML support (see
further <ptr target="#STXML"/>). DTD only.</item>
<item>Declare naming entities for all elements to permit renaming. DTD
only.</item>
<item> 
Embed any user-supplied entity declarations. DTD
only.</item><!-- only it doesnt happen -->
</list></item>
<item>Declare all available datatype macros (see <ptr
target="#DTYPES"/>)</item>
<item>Declare all globally available attribute classes (see <ptr
target="#STECAT"/>)</item>
<item>Declare all globally available model classes (see <ptr
target="#STECCM"/>)</item>
<item>Declare and embed any user-supplied element declarations. DTD
only. </item>
<item>Declare and embed conditionally each TEI-defined module (see <ptr
target="#STPE"/>)  DTD only</item>
</list>
</p>


</div2>

<div2 xml:id="DTYPES"><head>Datatype macros</head>
<p>The values which attributes may take in a TEI schema are defined,
for the most part, by reference to a TEI <term>datatype</term>. Each
such datatype is defined in terms of other primitive datatypes (for
the most part defined by the W3C Schema language <!-- need proper
reference-->), literal values, or other datatypes. This indirection
makes it possible for a TEI application to set constraints either
globally or in individual cases, by redefining the datatype definition
or the reference to it respectively. In some cases, the TEI datatype
includes additional usage constraints which cannot be enforced by
existing schema languages, although a TEI-compliant processor should
attempt to validate them (see further discussion in chapter <ptr
target="#CF"/>). </p>
<p>Where literal values or name tokens are used in a datatype
definition, an associated value list supplies definitions for the
significance of suggested or (in the case of closed lists) all
possible values.</p>
<!-- but can we put a valList in a macroSpec ? -->
<p>TEI-defined datatypes may be grouped into those which define
normalised values for numeric quantities or probabilities, those which
define various kinds of short-hand codes or keys, and those which
define pointers or links. </p>
<p>The following datatypes are used for attributes which are intended
to hold normalized values of various kinds. First, expressions of quantity:
<specList>
<specDesc key="data.certainty"/> 
<specDesc key="data.probability"/>
<specDesc key="data.numeric"/>
<specDesc key="data.count"/>
</specList>
</p>
<p>Examples of attributes using the data.probability datatype include
<att>degree</att> on <gi>damage</gi> or <gi>certainty</gi>;  <att>scale</att> on
<gi>graphic</gi>; examples of  data.numeric include
<att>quantity</att> on  members of the <ident
type="class">att.measurement</ident> class or <att>value</att> on
<gi>numeric</gi>; examples of data.count include <att>cols</att> on
<gi>cell</gi> and <gi>table</gi>.</p>

<p>
They are formally defined as follows:
<specGrp xmlns:rng="http://relaxng.org/ns/structure/1.0"
	 xml:id="DTYPES-1" n="Numeric Datatypes">
&data.certainty; 
&data.probability;
&data.numeric;
&data.count;
</specGrp>
</p>
<p>Next, the datatypes used for attributes which are intended to hold
normalized dates or times, durations, or truth values:
<specList>
<specDesc key="data.duration"/> <!-- only one usage! -->
<specDesc key="data.temporal"/>
<specDesc key="data.truthValue"/>
<specDesc key="data.xTruthValue"/>
<specDesc key="data.language"/>
<specDesc key="data.sex"/>
</specList>
</p>
<p>Note that in each of these cases the values used are those
recommended by existing international standards: ISO 8601 in the case
of time, date, and duration; RelaxNG in the case of truth values; RFC
1766 in the case of language; and ISO 5218 in the case of sex.</p>
<p>Examples of attributes using these datatypes include
...They are formally defined as follows:
<specGrp xmlns:rng="http://relaxng.org/ns/structure/1.0"
	 xml:id="DTYPES-2" n="Normalised Datatypes">
&data.temporal;
&data.duration;
&data.truthvalue;
&data.xtruthvalue;
&data.language;
&data.sex;
</specGrp>
</p>
<p>The following datatypes have more specialised uses:
<specList>
<specDesc key="data.outputMeasurement"/>
<specDesc key="data.namespace"/>
<specDesc key="data.pattern"/> <!-- only one usage -->
<specDesc key="data.pointer"/>
<specDesc key="data.pointers"/>
</specList>
</p>
<p>Examples of attributes using these datatypes include
...They are formally defined as follows:
<specGrp xmlns:rng="http://relaxng.org/ns/structure/1.0"
	 xml:id="DTYPES-3" n="Notation and pointer datatypes">
&data.namespace;
&data.outputmeasurement;
&data.pattern;
&data.pointer;
&data.pointers;
</specGrp>
</p>
<p>By far the largest number of TEI attributes have values which are
coded values or names of some kind. These values may be constrained or
defined in a number of different ways, each of which is given a
different name, as follows:
<specList>
<specDesc key="data.key"/> <!-- 2 uses -->
<specDesc key="data.word"/>
<specDesc key="data.words"/>
<specDesc key="data.name"/>
<specDesc key="data.names"/>
<specDesc key="data.enumerated"/>
<specDesc key="data.code"/>
</specList>
</p>

<p>Attributes such as <att>key</att> of <gi>persName</gi> and other
members of the <ident type="class">att.naming</ident> class are of type
<ident type="datatype">data.key</ident>. They are used to supply an externally-defined
identifier, such as a database key or filename. Because such
identifiers are externally-defined, no constraints are placed on their
possible values: and any string of Unicode characters may be used. If
constraints on their values are known to the encoder such as the rules
for constructing a valid database key in a particular system, this may
be documented within the TEI Header but cannot be enforced.</p>

<p>Attributes of type <ident type="datatype">data.word</ident>, such as
<att>age</att> on <gi>person</gi> are used to supply an identifier
expressed as any kind of single token or word. The TEI places a few
constraints on the characters which may be used for this purpose:
only Unicode characters classified as letters, digits,  punctuation
characters, or symbols can appear in an attribute value of this
kind. Note in particular that such values cannot  cannot include
whitespace name. Legal values include
<val>cholmondeley</val>, <val>été</val>, <val>1234</val>, <val>e_content</val>, or
<val>xml:id</val>, but not  <val>grand
wazoo</val>. Attributes of this kind are sometimes used to associate (by
co-reference) elements of different types.</p>

<p>Attributes of type <ident type="datatype">data.name</ident> are also words in
this sense, but they have the additional constraint that they must be
legal XML identifiers, as defined by the XML 1.0 specification. As
such, they may not begin with digits or punctuation characters. Legal
identifiers include <val>cholmondeley</val>, <val>été</val>,
<val>e_content</val>, or <val>xml:id</val>, but not <val>grand
wazoo</val> or <val>1234</val>. Attributes of this kind are typically used to
represent XML element or attribute names.</p>

<p>Corresponding with these two datatypes, the TEI provides
<soCalled>list</soCalled> valued datatypes <ident type="datatype">data.words</ident>
and <ident type="datatype">data.names</ident>. These may be used to supply a list of
words or names (as defined above), each being separated by a single space. </p>

<p>Attributes of type <ident type="datatype">data.enumerated</ident>, such as
<att>zone</att> on <gi>time</gi> have the same definition as
<ident type="datatype">data.word</ident> above, with the added semantics that the word
supplied is taken from a specific list of possibilities. In each case,
the element or class specification which includes the definition for
the attribute will also contain a list of possible values, together
with a prose description of their intended significance. This list may
be open (in which case the list is advisory), or closed (in which
case, it determines the range of legal values).</p>

<p>Attributes of type <ident type="datatype">data.code</ident> such as <att>new</att>
and <att>old</att> on <gi>handShift</gi> are similar in function, in
that they also supply encoded names for values which are defined in
more detail elsewhere. In this case, however, the full definition is
supplied as content of another XML element, typically but not
necessarily in the same document, and it is referenced by means of a
pointer. </p>

<p>Here are the specifications for these datatypes:
<specGrp xmlns:rng="http://relaxng.org/ns/structure/1.0"
	 xml:id="DTYPES-4" n="Coded value datatypes">
&data.code;
&data.enumerated;
&data.key;
&data.word;
&data.names;
&data.words;
&data.name;
</specGrp>
</p>
</div2>

<div2 xml:id="STEC"><head>The TEI Class System</head>

<p>The TEI scheme distinguishes over four hundred different elements.
To aid comprehension, modularity, and modification, the majority of
these elements are formally classified in some way.  Classes are used
to express two distinct kinds of commonality among elements.  The
elements of a class may share some set of attributes, or they may
appear in the same locations in a content model.  A class is known as
an <term>attribute class</term> if its members share attributes, and
as an <term>model class</term> if its members appear at the same
locations in the content models of other TEI elements. In either case,
an element is said to <term>inherit</term> properties from any classes
of which it is a member.  Classes may have subclasses and
superclasses, and the properties of a superclass are inherited by
all members of its subclasses.
 </p>

<p>In the RelaxNG fragments which express the TEI scheme, attribute
and model classes are represented by patterns whose names begin with
<ident>att.</ident> or <ident>model.</ident> respectively. The same
names are used in the XML DTD fragments for the parameter entities
used to implement the class system.
 </p>

<p>In both cases, the <ident type="module">tei</ident> module provides
an appropriate initial declaration for the class, so that it can
subsequently be referenced, either by a subclass, or by someone
wishing to extend the class with a new element. </p>

<p>This section describes the major element classes of each type.
 </p>

<div3 xml:id="STECAT"><head>Attribute Classes</head>

<p>An attribute class groups together elements which share some set of
common attributes.  Attribute classes are given names beginning
<code>att.</code> and are usually adjectival. For example, the members
of the class <ident type="class">att.naming</ident> have in common a
<att>key</att> attribute, which is inherited from their membership in
the class rather than individually defined for each element.  This
attribute is said to be defined by (or inherited from) the <ident
type="class">att.naming</ident> class. If another element were to be
added to the TEI scheme for which a similar <att>key</att> attribute
was considered useful, the simplest way to add it would be to make the
new element a member of the <ident type="class">att.naming</ident>
class. </p>

<p>The attributes provided by an attribute class are generally only
those specified by the class itself. However, one attribute class may
itself inherit attributes from another. For example, the attribute
class <ident type="class">att.pointing.group</ident> provides
attributes <att>domains</att> and <att>targFunc</att> to all of its
members. This class is however a subclass of the <ident
type="class">att.pointing</ident> class, from which its members also
inherit the attributes <att>type</att> and <att>evaluate</att>.
Members of the class <ident type="class">att.pointing</ident> will
thus have these two attributes, while members of the class <ident
type="class">att.pointing.group</ident> will have all four.</p>

<p>Most attribute classes are defined within the present module and
are thus globally available. Some classes are specific to particular
modules and thus defined in other chapters. Attributes defined by such
classes will not be available unless the module concerned is included
in a schema. </p>

<p>Note that some modules define classes which are superclasses of a
globally-defined class (typically <ident
type="class">att.global</ident>).  For example, the global attribute
class <ident type="class">att.divLike</ident> makes attributes
<att>org</att>, <att>uniform</att>, and <att>sample</att> available,
while the <ident type="class">att.metrical</ident> class, which is
specific to the <ident type="module">verse</ident> module, provides
attributes <att>met</att>, <att>real</att>, and
<att>rhyme</att>. Because <ident type="class">att.metrical</ident> is
defined as a superclass of <ident type="class">att.divLike</ident>,
all six of these attributes are available to <ident
type="class">att.metrical</ident> elements; the att.metrical
declaration adds its three attributes to the three already defined by
att.divLike when the <ident type="module">verse</ident> module is
included in a schema. If, however, this module is not included in a
schema the <ident type="class">att.divLike</ident> elements supplies
only the three attributes first mentioned. </p>

<p>The following lists all declared attribute classes:

<!-- shd be generated -->

<list type="gloss">

<label><ident type="class">att.global</ident></label>
<item>provides attributes which are available for all TEI elements</item>
<label><ident type="class">att.measurement</ident></label>
<item>provides attributes for describing or regularizing a measurement</item>
<label><ident type="class">att.measured</ident></label>
<item>provides attributes for describing a measurement</item>
  <label><ident type="class">att.declaring</ident> </label>
<item>elements which have a
<att>decls</att> attribute for specifying which declarations in the
header apply to the element, as described in section <ptr target="#CCAS"/>
 </item><label><ident type="class">att.declarable</ident> </label>
<item>header elements containing declarations, which can be pointed at by the <att>decls</att>
attribute, as described in section <ptr target="#CCAS"/>
 </item><label><ident type="class">att.divLike</ident> </label>
<item>structural elements which
behave in the same way as divisions, as described in section <ptr target="#DSDIV"/>
 </item><label><ident type="class">att.enjamb</ident> </label>
<item>elements which carry the
<att>enjamb</att> attribute for indicating metrical enjambement
 </item><label><ident type="class">att.interpLike</ident> </label>
<item>elements which contain
overtly interpretive or extra-textual analysis or commentary on a text
or some portion of it
 </item><label><ident type="class">att.metrical</ident> </label>
<item>elements which carry
metrical information (metrical pattern, realization of the pattern,
rhyme)
 </item><label><ident type="class">att.names</ident> </label>
<item>elements which contain
proper nouns and share attributes for identifying their referents and
regularizing their spelling (section <ptr target="#CONARS"/>)
 </item><label><ident type="class">att.personal</ident> </label>
<item>elements which contain
personal names or parts of them
</item>
<label><ident type="class">att.pointing</ident> </label>
<item>elements which point from
one location in the document to another (section <ptr target="#COXR"/>)
 </item><label><ident type="class">att.segLike</ident> </label>
<item>elements for the systematic
or arbitrary segmentation of the text
 </item><label><ident type="class">att.datePart</ident> </label>
<item>elements which
contain temporal expressions
 </item><label><ident type="class">att.timed</ident> </label>
<item>elements (in the base tag
set for spoken texts) which have a duration in time expressible with the
attributes, as described in section <ptr target="#TSBATI"/>
</item><label><ident type="class">att.typed</ident> </label>
<item>elements which carry
an additional semantic or functional classification
 </item>
<label>att.spanning</label><item>elements which delimit a span of text running from the
content of the element to a point indicated by the spanTo attribute</item>
<label>att.intervention</label><item>elements which carry attributes describing editorial interventions.</item>
<label>ascribed</label><item>elements representing speech ascribed to a speaker</item>
</list>
 </p>
<p>The following attribute classes, although defined in other modules,
are referenced by attributes defined here:
<list type="gloss">	
<label><ident type="pe">att.analysis.attributes</ident> </label>
<item>additional global attributes for the analysis module
 </item><label><ident type="pe">att.linking.attributes</ident> </label>
<item>additional global attributes for the linking module
 </item></list>
 </p>


<specGrp xml:id="DSTECAT" n="Attribute classes">
&global.odd;
&measurement.odd;
&decling.odd;
&declabl.odd;
&typed.odd;
&clinterp.odd;
&divn.odd;
&names.odd;
&agent.odd;
&namelike.odd;
&clseg.odd;
&clsegatts.odd;
&timed.odd;
<!-- the following classes are not yet documented here -->
&spanning.odd;
&intervention.odd;
&ascribed.odd;
&datable.odd;
&measured.odd;
</specGrp>


<p>In RelaxNG schema fragments, attribute classes are defined as named
patterns, as shown above. For each class, one pattern combining the
class name with the suffix <code>.attributes</code> is defined, and
for each attribute which membership in the class supplies a further
pattern is defined combining the class name, the string
<code>attribute</code> and the attribute name. Thus, the class <ident
type="class">att.naming</ident> is implemented using the pattern
<ident type="pattern">att.naming.attributes</ident>, which is in turn
a reference to the pattern <ident
type="pattern">att.naming.attribute.key</ident>. The attribute
<att>key</att> supplied by the class is declared using this
pattern. </p>
<p>Members of the class inherit its definition by referring to this
pattern:
<eg><![CDATA[
name =
  element name { name.content, name.attributes }
name.content = macro.phraseSeq
name.attributes =
  att.global.attributes,
  att.naming.attributes,
  attribute type { data.enumerated }?,
  empty
]]></eg></p>
 
<p>Superclasses are implemented using the same patterns. For example,
the class <ident type="class">att.divLike</ident>, as noted above, is
a subclass of the module-specific class <ident
type="class">att.metrical</ident>. The corresponding RelaxNG pattern
for the subclass therefore includes a reference to the superclass, as
shown above. In the <ident type="module">tei</ident> module, the
superclass has a default definition which, in the <ident
type="module">verse</ident> module, is expanded to include the
verse-specific attributes discussed above.</p> 


<p>In XML DTD fragments, the attributes shared by the members of an
attribute class are defined by a parameter entity; member elements
inherit the attributes by referring to this parameter entity within
their attribute-list declaration. The parameter entities used for this
purpose are named in the same way as the corresponding RelaxNG
patterns: they take the name of the class they define
(including the <code>att.</code> prefix), suffixed the string
<mentioned>attributes</mentioned>.  For example, the declaration for
the <ident type="class">att.naming</ident> class in the XML DTD
fragment is :

<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % att.naming.attributes '
      key  CDATA #IMPLIED> 
]]></egXML> 
Members of the class inherit the definition by referring to this
parameter entity:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % name 'INCLUDE' >
<!ELEMENT %n.name; %om.RR;  %phrase.seq;> 
<!ATTLIST %n.name;
      %att.global.attributes;
      %att.naming.attributes;
      type CDATA #IMPLIED  >
]]></egXML>
 </p>

<p>Superclasses are also implemented using parameter entities. For
example, the parameter entity corresponding with the <ident
type="class">att.divLike</ident>  attribute class is defined as
follows:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % att.divlike.attributes '
	%att.metrical.attributes;
 type  %data.enumerated;  #IMPLIED
 org  (composite|uniform) "uniform" 
 sample  (initial|medial|final|unknown|complete) "complete" 
 part  (Y|N|I|M|F) "N" '> 
]]></egXML> 
Note the reference to <ident
type="pe">att.metrical.attributes</ident>. This parameter entity is
defined by the <ident type="module">tei</ident> module as a null
string and therefore has no effect by default. However, if
the verse module is included in a schema, the same parameter entity
will have been already declared with the following values:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % att.metrical.attributes '
 met  CDATA #IMPLIED
 real  CDATA #IMPLIED
 rhyme  CDATA #IMPLIED'> ]]></egXML>
in such a way as to over-ride this default (see further <ptr
target="#STPE"/>), thus extending the definition for <ident
type="class">att.divLike"</ident>. </p>




</div3>
<div3 xml:id="STECCM"><head>Model Classes</head>

<p>When the members of a class are structurally similar and can appear
at the same kinds of structural locations in the document, they are
said to constitute a
<soCalled>model-class</soCalled>. Like attribute classes, model classes may have
subclasses or superclasses.  Just as elements inherit from a class the
ability to appear in certain locations of a document (wherever the
class can appear), so all members of a subclass inherit the ability to
appear wherever any superclass can appear. </p>

<!-- <p>Model classes are implemented by
defining a parameter entity for use in the formal declaration of element
content models.  The parameter entity takes the name of the class it
defines, and prefixes the string <mentioned>m.</mentioned>, which can be
interpreted as <gloss>model</gloss> or as <gloss>members</gloss>.  The
replacement text of the entity is a list of the members of the class,
separated by <mentioned>|</mentioned>, the content model symbol for alternation.</p>

<p>For each class an additional entity is defined, which also takes
the name of the class, this time prefixed by the string
<mentioned>x.</mentioned> (for extension); the default value of these
<term>x-dot entities</term> is always an empty string.  A reference to
the corresponding x-dot entity is always included within the
replacement string for each m-dot entity.  This enables an encoder to
add new members to a class simply by declaring a new value for an
x-dot entity.
 </p>
<p>For example, the class <ident type="class">model.biblLike</ident> has the three
members <gi>bibl</gi>, <gi>biblFull</gi>, and <gi>biblStruct</gi>.
Its content-model entity is defined thus:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % x.bibl '' >
<!ENTITY % model.biblLike '%x.bibl; bibl | biblFull | biblStruct' >]]></egXML>
With the default value of the x-dot entity, this is the same as defining
<ident type="pe">model.biblLike</ident> with the replacement text <code>bibl | biblFull | biblStruct</code>.  If an encoder wishes
to add a new bibliographic element called <gi>my.bib</gi>, it can
be added to the <ident type="class">model.biblLike</ident> class by redefining the
x-dot entity thus:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % x.bibl 'my.bib |' >]]></egXML>
This changes the replacement text of <ident type="pe">model.biblLike</ident> from
its default value to <code>my.bib | bibl | biblFull |
biblStruct</code>.  If more than one element is to be added to a class,
the x-dot entity for the class should be redefined as a list of the new
generic identifiers, each one <emph>(including the last)</emph> followed
by a vertical bar.  The same effect could be achieved simply by
redefining the whole of the new <ident type="pe">model.biblLike</ident> entity
directly, but the x-dot method requires no repetition of the already
existing members of the class and thus minimizes the chance of error.
 </p>
<p> Superclasses transmit their location characteristics to their
subclasses by referring, in declaring their m-dot entity, to the m-dot
entities of the subclasses.
 </p>
<p>For example, the class <ident type="class">model.phrase</ident> includes the
classes <ident type="class">model.pPart.data</ident>, <ident type="class">model.pPart.edit</ident>,
<ident type="class">model.hiLike</ident>, <ident type="class">model.ptrLike</ident>, and
<ident type="class">model.segLike</ident> as members, as can be seen in the
declaration for its m-dot entity:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % class.phrase "%x.class.phrase; %class.data; | %class.edit;
 | %class.formPointers; | %class.hqphrase; | %class.loc; 
 | %class.oddPhr; | %class.phrase.verse; | %class.seg; | %n.formula; 
 | %n.handShift;">]]></egXML>
 When the entity <ident type="pe">model.phrase</ident> is referred to in
content models, all members of all subclasses are included in the model.
 </p>-->


</div3>


<div3 xml:id="STECOV"><head>High-level structural element classes</head>

<p>The TEI class system is structured around the following threefold
division of elements:
<list type="gloss"><label><term>chunks</term> </label>
<item>elements such as paragraphs and other
paragraph-level elements, which can appear directly within texts or
within text subdivisions (i.e. <gi>div</gi> elements), but not within
other chunks</item><label><term>phrase-level elements</term> </label>
<item>elements such as
highlighted phrases, book titles, or editorial corrections which can
occur only within chunks (paragraphs or paragraph-level elements), but
not between them (and thus cannot appear directly within a
<gi>div</gi>)<note place="foot">Note that in this context, <term>phrase</term> means
any string of characters, and can apply to individual words, parts of
words, and groups of words indifferently; it does not refer only to
linguistically motivated phrasal units.  This may cause confusion for
readers accustomed to applying the word in a more restrictive sense.</note></item>
<label><term>inter-level elements</term></label>
<item>elements such as lists,
notes, quotations, etc. which can appear either between chunks (as
children of a <gi>div</gi>) or within them</item></list>
 </p>
<p>Together the two sets of <term>chunks</term> and <term>inter-level
elements</term> make up the set of:
<list type="gloss"><label><term>text components</term> </label>
<item>elements which can appear
directly within texts or text divisions; also called simply
<term>components</term> or <soCalled>component-level elements</soCalled></item></list>
In general, the body of any text comprises a series of components,
optionally grouped into <gi>div</gi> elements.
 </p>
<p>Some elements belong to none of these classes; these include
high-level structural elements like <gi>TEI</gi> and
<gi>group</gi> as well as some specialized elements which appear only
within particular structures (like <gi>analytic</gi>,
<gi>monographic</gi>, and <gi>series</gi>).  The majority of elements
found in normal running text, however, are assigned  to
one or the other of these classes.
 </p>
<p>Some <term>macro.component</term> elements (e.g. <gi>p</gi> or
<gi>note</gi>) are common to all base modules, while others are unique
to individual modules.  
</p>
</div3>
<div3 xml:id="STECLO"><head>Low-Level Element Classes</head>
<p>The following low-level classes group together sets of semantically
or structurally similar elements.  These classes may include both
elements in the core and elements declared in particular modules; a
reference is given at least to the relevant section on the core tags.
 </p>
<p>The following are phrase-level element classes:
<list type="gloss">
  <label><ident type="class">model.hiLike</ident> </label>
<item>elements for highlighted
phrases or material marked by quotation marks, including those defined
in section <ptr target="#COHQ"/>
 </item><label><ident type="class">model.pPart.data</ident> </label>
<item>elements for recording
information about the referents of a text, including those defined in
section <ptr target="#CONA"/>
 </item><label><ident type="class">model.dateLike</ident> </label>
<item>elements for recording
dates, including those defined in
section <ptr target="#CONADA"/>
 </item>
 <label><ident type="class">model.timeLike</ident> </label>
<item>elements for recording
times, including those defined in
section <ptr target="#CONADA"/>
 </item>
<label><ident type="class">model.measureLike</ident> </label>
<item>elements for numbers and measures</item>
<label><ident type="class">model.pPart.msdesc</ident></label>
<item>elements for describing manuscripts</item>
<label><ident type="class">model.graphicLike</ident></label>
<item>elements for indicating images, formulae, examples, etc.</item>
<label><ident type="class">model.pPart.edit</ident> </label>
<item>elements for recording
simple editorial interventions in a text, including those defined in
section <ptr target="#COED"/>
 </item><label><ident type="class">model.ptrLike</ident> </label>
<item>elements for recording
location information in a text, including those defined in section <ptr target="#CORS"/>
 </item><label><ident type="class">model.segLike</ident></label>
<item>elements for marking arbitrary
segments at the level of individual characters or phrases, including
those documented in section <ptr target="#SASE"/> and <ptr target="#AILC"/>
 </item><label><ident type="class">tei.sgmlKeywords</ident></label>
<item>elements for marking
generic identifiers, attribute names, tags, and sample attribute
values, when they occur in the text (used in module documentation, for
which see chapter <ptr target="#TD"/>)
 </item><label><ident type="class">tei.versePhrases</ident></label>
<item>phrase-level elements
specific to verse, documented in section <ptr target="#VESE"/>
 </item><label><ident type="class">model.ptrLike.form</ident></label>
<item>elements for
referring, within a dictionary entry, to the orthographic form or
pronunciation of the headword, documented in section <ptr target="#DIHW"/>
 </item></list>
 </p>
<p>The following are inter-level element classes:
<list type="gloss">
  <label><ident type="class">model.qLike</ident></label>
  <item>elements for highlighted
  phrases or material marked by quotation marks, including those defined
  in section <ptr target="#COHQ"/></item>
  <label><ident type="class">model.biblLike</ident></label>
  <item>elements for bibliographic
  citations; see section <ptr target="#COBI"/></item>
  <label><ident type="class">model.listLike</ident></label>
  <item>elements for lists; see
  section <ptr target="#COLI"/></item>
  <label><ident type="class">model.noteLike</ident></label>
  <item>general-purpose annotation
  elements; see section <ptr target="#CONO"/></item>
</list>
 </p>
<p>The following classes of elements may appear anywhere within the
<gi>text</gi> element:
<list type="gloss"><label>metadata</label>
<item>elements which convey non-textual
information about the text (meta-information, as it were)</item><label>refsys</label>
<item>milestone elements used in
reference systems</item><label>editincl</label>
<item>elements marking arbitrary  spans
of text which has been added, deleted, or omitted from a
transcription</item>
</list>
These three classes together make up the <ident type="class">model.global</ident>
class, comprising elements which may appear anywhere within
a <gi>text</gi> element. In earlier versions of the Guidelines, this
was implemented as an SGML inclusion
exception on the <gi>text</gi> element. In the current version,
members of this class are explicitly added to relevant content
models only.
</p>
<p>Here are the formal  declarations for the generally-available model classes:
<specGrp xml:id="DSTECLO" n="Lowlevel classes">
&hqphrase.odd;
&datelike.odd;
&timelike.odd;
&measurelike.odd;
&graphiclike.odd;
&ppartmsdesc.odd;
&data.odd;
&edit.odd;
&clloc.odd;
&lpart.odd;
&metadata.odd;
&refsys.odd;
&editincl.odd;
&globincl.odd;
&glike.odd;
&odddecl.odd;
&oddref.odd;
&oddphr.odd;
 <p>Inter-level classes</p>
&hqinter.odd;
&clbibl.odd;
&lists.odd;
&notes.odd;
&stagedir.odd;
&cplxval.odd;
&singval.odd;
&featval.odd;
&ditoplev.odd;
</specGrp>
</p>
</div3>
<div3 xml:id="STECHI"><head>High-Level Element Classes</head>
<p>The following element classes are used to implement the threefold
structural distinction among phrases, chunks, and intermediate elements
discussed above in section <ptr target="#STECOV"/>.  In this terminology,
<term>chunk</term>s (or <term>chunk elements</term>) are elements which
can occur only in chunk-level sequences (e.g. between but not within
paragraphs); <term>inter-level elements</term> can occur either within
chunks (at phrase-level) or between chunks (e.g. at paragraph-level),
and <term>phrase-level elements</term> can occur only at phrase level,
within chunks (e.g. within but not between paragraphs).
 </p>
<p>The element class <ident type="class">model.common</ident> includes all
component-level (chunk- and inter-level) elements <!-- common to more than
one base.  It is used in implementing the combined bases described in
section <ptr target="#STECMX"/>.-->
  </p>
<p>The relevant portion of the DTD looks like this:
<specGrp xml:id="DSTECHI" n="Common high-level classes">
&phrase.odd;
&inter.odd;
&chunk.odd;
&segment.odd;
&paragraph.odd;
<p>This class isolates all the common component-level elements.</p>
&common.odd;
</specGrp>
</p></div3>
<div3 xml:id="STECMK"><head>Elements Marked for Text Type</head>
<p>The following element classes are used to group together
component-level elements which are allowed only in texts of a particular
type (i.e. texts using a specific module).
<list type="gloss"><label><ident type="class">model.divPart.verse</ident> </label>
<item>elements unique to
verse
 </item><label><ident type="class">model.divPart.stage</ident> </label>
<item>elements unique to
drama
 </item><label><ident type="class">model.divPart.spoken</ident> </label>
<item>elements unique to
spoken texts
 </item><label><ident type="class">model.entryLike</ident> </label>
<item>elements unique
to dictionaries
 </item><label><ident type="class">tei.comp.terminology</ident> </label>
<item>elements unique
to terminological data
 </item></list>
 </p>
<p>Declarations for these module-specific element classes are included
in a separate <ident type="module">-decls</ident> schema fragment when
XML DTDs are used. In  RelaxNG  schema fragments, the corresponding
declarations are given at the start of the same schema fragment as the
other declarations. </p></div3>


<div3 xml:id="STECMX"><head>Components in Mixed and General Bases</head>
<p>When the mixed base is in use, the definitions of the
entities <ident type="pe">macro.component</ident> and 
<ident type="pe">macro.componentSeq</ident> are rather more complex.
The relevant portion of the DTD is this:
<specGrp xml:id="DSTECMX" n="Definition of components for combined bases">
<p>Default declarations for the 'mix.' entities used for mixed
and general bases.</p>
&drmixxx.odd; 
&tsmixxx.odd;
&dimixxx.odd;
<p>These declarations are needed for arcane reasons which I have only
managed to understand fleetingly.</p>
</specGrp>
</p>
</div3>

</div2>

<div2 xml:id="STmacros"><head>Macros for commonly occurring content
models</head>

<div3 xml:id="STECST"><head>Standard Content Models</head>
<p>As far as possible, the TEI schemas use the following set of
frequently-encountered content models to help achieve consistency among
different elements.
<list type="gloss"><label><ident type="pe">phrase</ident> </label>
<item>a single sequence of
character data or single phrase-level element</item>
<label><ident type="pe">macro.phraseSeq</ident> </label>
<item>sequence of character
data and phrase-level elements</item>
<label><ident type="pe">macro.component</ident> </label>
<item>a single chunk- or
inter-level element</item>
<label><ident type="pe">macro.componentSeq</ident> </label>
<item>sequence of chunk- and
inter-level elements; this is the usual content of a <gi>div</gi>
element</item>
<label><ident type="pe">macro.glossseq</ident> </label>
<item>sequence of identifying and glossing
elements</item>
<label><ident type="pe">macro.paraContent</ident> </label>
<item>sequence of character
data, phrase-level elements, and inter-level elements; this is the usual
content of chunks (including, most prominently, paragraphs)</item>
<label><ident type="pe">macro.specialPara</ident> </label>
<item>specialized content
model, allowing <emph>either</emph> a sequence of chunks <emph>or</emph>
the same content as <ident type="pe">macro.paraContent</ident>; this is used for
elements such as notes and list items, which can behave either as
chunk-level elements, or else as containers for groups of
component-level elements.
 </item>
</list>
 </p>
<p>These macros are declared as follows:
<specGrp xml:id="DSTECST" n="Standard Content Models">
&macroxtext.odd;
&cbcomp.odd;
&pephrase.odd;
&phrseq.odd;
&glossseq.odd;

<p>The actual meaning of  <ident type="macro">macro.component</ident> will
differ, depending on which modules are in use. This is because its
value refers to other, module-specific, macros. 
</p>
&compseq.odd;
<p>The following macros are module independent.</p>
&peparac.odd;
&pespecp.odd;
</specGrp>
 </p></div3>

<div3 xml:id="STECMI"><head>Miscellaneous Content-Model Classes</head>
<p>The following element classes occupy specific places in content
models; most are relevant only when certain modules are selected
<list type="gloss"><label><ident type="class">model.nameLike.agent</ident> </label>
<item>elements which denote an
individual or organization to whom or to which responsibility for an action
can be assigned</item>
<label><ident type="class">model.addrPart</ident> </label>
<item>elements which can occur
as part of an address</item>
<label><ident type="class">model.biblPart</ident> </label>
<item>elements which can occur in bibliographic citations</item>
<label><ident type="class">model.choicePart</ident></label>
<item>elements which can be used as part  of a
<gi>choice</gi> alternation</item>
<label><ident type="class">model.publicationStmtPart</ident></label>
<item>elements which can occur inside the <gi>publicationStmt</gi></item>
<label><ident type="class">macro.fileDescPart</ident></label>
<item>elements that are used inside the <gi>fileDesc</gi> or a <gi>biblFull</gi></item>
<label><ident type="class">macro.bodyPart.div</ident></label>
<item>elemnts used in the declaration of <ident type="class">macro.bodyPart.main</ident></item>
<label><ident type="class">macro.bodyPart.div0</ident></label>
<item>elemnts used in the declaration of <ident type="class">macro.bodyPart.main</ident></item>
<label><ident type="class">macro.bodyPart.div1</ident></label>
<item>elemnts used in the declaration of <ident type="class">macro.bodyPart.main</ident></item>
<label><ident type="class">macro.bodyPart.pre</ident></label>
<item>elemnts used in the declaration of <ident type="class">macro.bodyPart.main</ident></item>
<label><ident type="class">macro.bodyPart.main</ident></label>
<item>elemnts used in the declaration of <gi>body</gi></item>
<label><ident type="class">model.glossLike</ident></label>
<item>elements which provide an alternative name,
  explanation, or description for any markup construct</item>
<label><ident type="class">model.quoteLike</ident> </label>
<item>elements which indicate a quotation of some sort, particularly
those that indicate a passage attributed to some agency external to
the text </item>
<label><ident type="class">model.respLike</ident> </label>
<item>elements which  indicate intellectual
  responsibility, for example within a bibliographic element</item>
<label><ident type="class">model.persPart</ident> </label>
<item>elements which describe characteristics of the people referenced by a text, or
participating in a language interaction</item>
<label><ident type="class">model.divWrapper.bottom</ident> </label>
<item>elements which can occur
as part of the closing material of a text division or body</item>
<label><ident type="class">model.divWrapper</ident> </label>
<item>elements which can occur
as part of the opening material of a text division or body</item>
<label><ident type="class">model.frontPart.drama</ident> </label>
<item>elements which can
occur in the front matter of drama and other performance texts</item>
<label><ident type="class">model.pLike.front</ident> </label>
<item>elements which can
occur in place of a title page in front matter only </item>
<label><ident type="class">model.frontPart</ident> </label>
<item>elements which can occur
(at the level of text divisions) in front matter only</item>
<label><ident type="class">model.msItemPart</ident></label>
<item>elements which can appear within the description of an
individual title or item in a manuscript description</item>
<label><ident type="class">model.persNamePart</ident> </label>
<item>elements which contain
parts of a personal name</item>
<label><ident type="class">model.placeNamePart</ident> </label>
<item>elements which contain
parts of a place name</item>
<label><ident type="class">model.titlepagePart</ident> </label>
<item>elements which occur within title pages</item>
  <label><ident type="class">model.lLike</ident></label>
<item>elements such as <gi>l</gi> used to mark metrical components
  such as verse lines
</item>
  <label><ident type="class">model.recordingPart</ident></label>
<item>elements used to describe the details of an audio or video
recording event</item>
  <label><ident type="class">model.stageLike</ident></label>
<item>elements such as <gi>stage</gi> which can appear within
representations of speech, but are not themselves spoken
</item>
<label><ident type="class">model.imprintPart</ident></label>
<item>bibliographic elements typically found in an imprint</item>
</list>
 </p>
<p>They are declared in the following module:
<specGrp xml:id="DSTECMI" n="Misc. Element Class Models">
&addrpart.odd;
&publicationstmtpart.odd;
&filedescpart.odd;
&bodypartdiv.odd;
&bodypartdiv0.odd;
&bodypartdiv1.odd;
&bodypartpre.odd;
&bodypartmain.odd;
&glosslike.odd;
&quotelike.odd;
&resplike.odd;
&demog.odd;
&divbot.odd;
&divtop.odd;
&drfront.odd;
&clfront.odd;
&fmchunk.odd;
&tpparts.odd;
&msitempart.odd;
&chooseable.odd;
&cllines.odd;
&recordingpart.odd;
&imprintpart.odd;
&biblpart.odd;
<!-- &clstage.odd;-->
    </specGrp>
</p></div3>

</div2>



<div2 xml:id="STPE"><head>TEI DTD-specific mechanisms</head>

<p>The TEI DTD fragments use parameter entities for several purposes:
<list type="bullets">
<item>to define sets of attributes shared by given classes of elements</item>
<item>to define classes of elements which can occur at the same
locations in content models</item>
<item>to identify what base module should be used for a document</item>
<item>to identify what additional modules should be included</item>
<item>to include or exclude the declaration of each element</item>
<item>to specify the name of each element</item>
<item>to specify tag omissibility information within
a DTD, or alternatively to omit such information in an XML DTD</item>
</list>
The first two applications of parameter entities are described above in
section <ptr target="#STEC"/>.  This chapter describes the other uses of
parameter entities in the TEI DTD fragments.
 </p>
<p>Special purpose parameter entities are used to specify which
modules are to be used in a combined into a TEI DTD. They take the
form <val>TEI.xxxxx</val> where <code>xxxx</code> is the name of the
module as given in the table above (<ptr target="#STMA"/>): for
example, the
parameter entity <ident type="pe">TEI.linking</ident> is used to
define whether or not to include the module <ident
type="module">linking</ident>. All such parameter entities are
declared by default with the value <val>IGNORE</val>:  to select a
module, therefore, the encoder declares the appropriate parameter entities with the
value <val>INCLUDE</val>. <!-- Note that the three basic modules
(<ident>tei</ident>, <ident>header</ident>, and <ident>core</ident>)
are already included in the TEI main DTD, and therefore do not need to
be included in this way. --><!-- not any more they're not -->
</p>
<p>Any local modifications (i.e. changes to a schema other than
simple inclusion or exclusion of modules) are 
made by declarations stored in one of two local extension
files. Entity declarations must be made associating the names of these
two files with the appropriate parameter entity so that the
declarations they contain can be embedded within the TEI DTD at the
appropriate point.</p>

<p>The following entities are referred to by the main
<ident type="file">tei.dtd</ident> file to embed portions of the TEI DTD fragments
or locally developed extensions.
<list type="gloss"><label><ident type="pe">TEI.extensions.ent</ident></label>
<item>identifies a local file containing
extensions to the TEI parameter entities; see section <ptr target="#STOVLO"/></item><label><ident type="pe">TEI.extensions.dtd</ident></label>
<item>identifies a local file containing
extensions to the TEI module; see section <ptr
target="#STOVLO"/></item>
<!--<label><ident type="pe">TEI.elementNames</ident></label>
<item>identifies a file containing parameter
entity declarations for names of TEI elements; see section <ptr target="#STPEGI"/></item><label><ident type="pe">TEI.keywords</ident></label>
<item>identifies a file containing parameter
entity declarations for TEI keywords, including the default
declaration (<val>IGNORE</val>) of the marked-section keyword for
each module; see section <ptr target="#STPE"/></item><label><ident type="pe">teiclasses</ident> </label>
<item>identifies a file
containing definitions of parameter entities used in content models; see
section <ptr target="#STECOV"/></item>-->
<label>TEI.XML</label>
<item>indicates whether the target DTD is to be expressed in SGML or
XML. By default, this parameter entity has the value <val>INCLUDE</val>; the
user should therefore declare it with the <val>IGNORE</val> in order
to use an SGML DTD; see
<ptr target="#STXML"/>.</item>
</list>
 </p>

<div3 xml:id="STPEEX"><head>Inclusion and Exclusion of Elements</head>

<p>The TEI DTD fragments use marked sections and parameter entity references to
allow users to exclude the definitions of individual elements, in order
either to make the elements illegal in a document or to allow the
element to be redefined, as further described in chapter <ptr target="#MD"/>.</p>
<p>Parameter entities used for this purpose have exactly the same name
as the generic identifier of the element concerned.  The default
definition for these parameter entities is <val>INCLUDE</val> but they may
be changed to <val>IGNORE</val> in order to exclude the standard element and
attribute definition list declarations from the DTD.
 </p>

<p>The declarations for the element <gi>p</gi>, for example, are
preceded by a definition for a parameter entity with the name
<ident rend="noindex" type="ge">p</ident> and contained within a marked
section whose keyword is
given as <code>%p;</code>:
<eg><![CDATA[<!ENTITY % p 'INCLUDE' >
<![ %p; [
       <!-- element and attlist declaration for p here -->
]]]]></eg></p><p>These parameter entities are defined immediately preceding the
element whose declarations they control; because their names are
completely regular, they are not documented further.
 </p>

<p>In relaxng you say p = notAllowed </p></div3>

<div3 xml:id="STPEGI"><head>Parameter Entities for Element Generic Identifiers</head>

<p>In the TEI DTD fragments, elements are not referred to directly by their
generic identifiers; instead, the DTD fragments refer to parameter entities which
expand to the standard generic identifiers.
This allows users to rename elements by redefining the appropriate
parameter entity (as described more fully in chapter <ptr target="#MD"/>).
Parameter entities used for this purpose are formed
by taking the standard generic identifier of the element and
attaching the string <q>n.</q> as a prefix.  Thus the standard generic
identifiers for paragraphs, notes, and quotations, <gi>p</gi>,
<gi>note</gi>, and <gi>q</gi> are defined by declarations of the
following form:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % n.p "p">
<!ENTITY % n.pb "pb">
<!ENTITY % n.persName "persName">]]></egXML>
Since all names in the TEI DTD are case-sensitive, the specific
mix of upper and lower case letters in the standard generic identifier must be
preserved in the entity name.
 </p>
<p>These declarations are automatically generated by an ODD processor
when  TEI DTD fragments are being created. </p>
<p> In the RelaxNG schemas, all elements are defined using a pattern
with the same name as the element: for example
<eg><![CDATA[
abbr = element abbr { abbr.content, abbr.attributes }
]]></eg>
The easiest way of renaming the element is thus simply to declare a
new pattern:
<eg><![CDATA[
abbrev = element abbr { abbr.content, abbr.attributes }
]]></eg>
More complex revisions, such as redefining the content of the element
(defined by the pattern <ident type="rng">abbr.content</ident>) or its
attributes (defined by the pattern <ident
type="rng">abbr.attributes</ident>) can be accomplished in a similar
way, using the features of the RelaxNG language. The recommended
method of carrying out such modifications is however to use the ODD
language as further described in section <ptr target="#TD"/>.</p>
</div3>


<div3 xml:id="STOVLO"><head>Embedding Local Modifications</head>

<p>As noted above in section <ptr target="#STPE"/>, local modifications
to the DTD are most conveniently grouped into two files, one containing
modifications to the TEI parameter entities, and the other new or
changed declarations of elements and their attributes.  These files
should be associated with the parameter entities
<ident type="pe">extensions-decl</ident> and
<ident type="pe">extensions</ident> by declarations included in
the document's DTD subset.</p>

<p>For example, if the relevant files are called <ident rend="noindex"
type="file">project.ent</ident> and <ident rend="noindex"
type="file">project.dtd</ident>, then declarations like the following
would be appropriate:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % TEI.extensions.ent SYSTEM 'project.ent' >
<!ENTITY % TEI.extensions.dtd SYSTEM 'project.dtd' >]]></egXML></p>
<p>When an entity is declared more than once, the first declaration is
binding and the others are ignored.  The local modifications to
parameter entities should therefore be handled before the standard
parameter entities themselves are declared in <ident
type="file">tei.dtd</ident>.  The entity <ident
type="pe">TEI.extensions.ent</ident> is referred to before any TEI
declarations are handled, to allow the user's declarations to take
priority.  If the user does not provide a <ident
type="pe">TEI.extensions.ent</ident> entity, the entity will be expanded
to the empty string.</p>
<p>For example the encoder might wish to add two phrase-level elements
<gi>it</gi> and <gi>bd</gi>, perhaps as synonyms for
<tag>hi rend='italics'</tag> and <tag>hi rend='bold'</tag>.  As
described in chapter <ptr target="#MD"/>, this involves two distinct steps:
one to define the new elements, and the other to ensure that they are
placed into the TEI document structure at the right place.  We deal with
the second first, by specifying the element class to which the new
elements should be attached.  To do this, the standard parameter entity
<ident type="pe">x.phrase</ident> should be modified to include the two
new generic identifiers.  The file containing local declarations of the
standard parameter entities will thus contain a declaration of the
following form:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY % x.phrase 'it | bd |' >]]></egXML></p>

<!-- 
<p>The relevant fragment of the DTD is this:<specGrp xml:id="DSTOVLE" n="Local modifications to parameter entities">
&teiexte.odd;
</specGrp>
-->
</div3>

<div3 xml:id="STXML"><head>Generation of SGML or XML DTD fragments </head>

<p>The TEI Guidelines can generate DTD fragments which are both
SGML and XML compliant.</p>

<p>Only two SGML tag omissibility indicators are used in the TEI
Guidelines: <code>- O</code> (i.e., the end-tag may be omitted but not
the start-tag); and <code>- -</code> (i.e. neither start- nor end-tag
may be omitted). Two parameter entities are defined, one called
<ident type="pe">om.RO</ident> (<q>omissibility-required-optional</q>), and the
other called <ident type="pe">om.RR</ident>
(<q>omissibility-required-required</q>). In SGML mode, the value for each of these
parameter entities is the appropriate indicator. Content models in the
text of the Guidelines and in generated DTD fragments always reference the
omissibility information by means of one or the other of these
parameter entities. </p>
<p>In  XML mode (the default) tags are never omissible and omissibility
indicators are syntactically invalid. Thus 
these parameter entities are redefined as the null string, by
means of a second set of declarations contained within the file
<ident type="file">keywords.ent</ident> and controlled by a marked section
guarded by the <ident type="pe">TEI.XML</ident> parameter entity. 
If the user declares a parameter
entity TEI.XML with the value IGNORE in the DTD subset, then the 
parameter entities representing tag omissibility indicators will
be redefined as null strings, so that the resulting DTD is SGML
conformant.</p>
</div3>
</div2>
</div1>

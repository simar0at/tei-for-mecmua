<!--
Copyright TEI Consortium. 
Licensed under the GNU General Public License. 
See the file COPYING for details.
$Date$
$Author$
-->
<div1 xmlns="http://www.tei-c.org/ns/1.0" xml:id="WD">
    <head>Representation of non-standard characters and glyphs</head>
    <p>Despite the availability of Unicode, text encoders still
    sometimes find that the published repertoire of available
    characters is inadequate to their needs. This is particularly the
    case when dealing with ancient languages, for which encoding
    standards do not yet exist, or where an encoder wishes to
    represent variant forms of a character or <term>glyphs</term>.
    The module defined by this chapter provides a mechanism to satisfy
    that need, while retaining compatibility with standards.
</p>
<div2><head>Is your journey really necessary?</head>
    <p>When encoders encounter some graphical unit in a document which
    is to be represented electronically, the first issue to be
    resolved should be <q>Is this really a different character?</q> To determine
    whether a particular graphical unit <emph>is</emph> a character or
    not, see <ptr target="#D4-42"/>. </p>
    <p>If the unit is indeed determined to be a character, the next
    question should be <q>Has this character been encoded already?</q>
    In order to determine whether a character has been encoded,
    encoders should follow the following steps:
<list type="ordered">
      <item><p>Check the Unicode
      website at <ptr target="http://www.unicode.org"/>, in particular the page <ref target="http://unicode.org/standard/where/">"Where is my
      Character?"</ref>, and the associated character code charts.
      Alternatively, users can check the latest published version of
      <title>The Unicode Standard</title> , though the website is
      often more up to date than the printed version, and should be
      checked for preference.</p> 
<p>The pictures (<soCalled>glyphs</soCalled>) in the Unicode code
charts are only meant to be representative, not definitive. If a
specific form of an already encoded character is required for a
project, refer to the guidelines contained below under <ref target="#D25-30">Annotating Characters</ref>. Remember that your
encoded document may be rendered on a system which has different fonts
from yours: if the specific form of a character is important to you,
then you should document it. </p></item>
      <item>Check the Proposed New Characters webpage (<ptr target="http://unicode.org/alloc/Pipeline.html"/>) to see whether
      the character is in line for approval.</item>
<item>Ask on the Unicode email list (<ptr target="http://www.unicode.org/consortium/distlist.html"/>) to determine if a proposal is
pending, or whether this is indeed a new character (or if this not a
character at all, in which case it would not be eligible for addition
to the Unicode Standard).  </item> </list> </p>
    <p>Since there are now close to 100,000 characters in Unicode,
    chances are good that what you need is already there, but it might
    not be easy to find, since it might have a different name in
    Unicode.  Look again, this time at other sites, for example <ptr target="http://www.eki.ee/letter"/>, which also provide searches
    based on scripts and languages. Take care, however, that all the
    properties of what seems to be a relevant character are consistent
    with those of the character you are looking for. For example, if
    your character is definitely a digit, but the properties of the
    best match you can find for it say that it is a letter, you may
    have a character not yet defined in Unicode.  </p>
<p>In general, it is advisable to avoid Unicode characters generally
described as presentation forms<note place="foot">Specifically,
characters in the Unicode blocks Alphabetic Presentation Forms, Arabic
Presentation Forms-A, Arabic Presentation Forms-B, Letterlike Symbols,
and Number Forms.</note> However, if the character you are looking for
is being used in a notation (rather than as part of the orthography of
a language) then it is quite acceptable to select characters from the
Mathematical Operators block, provided that they have the appropriate
properties (i.e. <code>So</code>: Symbol, Other; or <code>Sm</code>:
Symbol, Math).</p>
    <p>An encoded character may be precomposed or it may be formed
    from base characters and combining diacritical marks. Either will
    suffice for a character to be "found" as an encoded character. </p>
<p>If there are several possible Unicode characters to choose amongst,
it is good practice to consult other colleagues and practitioners to
see whether a consensus has emerged in favour of one or other of
them. </p>
<p>If, however, no suitable form of your character seems to exist,
    the next question will be: <q>Does the graphical unit in question
    represent a variant form of a known character, or does it
    represent a completely unencoded character?</q> If the character
    is determined to be missing from the Unicode Standard, it would be helpful to
    submit the new character for inclusion (see <ptr target="http://unicode.org/pending/proposals.html"/>).  </p>
    <p>These guidelines will help you proceed once you have
     identified a given graphical unit as either a variant or an
     unencoded character. Determining this will require knowledge of
     the contents of the document that you have. The first case will
     be called <emph>annotation</emph> of a character, while the
     second case will be called <emph>adding</emph> of a new
     character. How to handle graphical units that represent variants
     will be discussed below (<ptr target="#D25-30"/>)
     while the problem of representing new characters will be dealt
     with in section <ptr target="#D25-40"/>.    </p>
    <p>While there is some overlap between these requirements,
    distinct specialized markup constructs have been created for each
    of these cases as explained in section <ptr target="#D25-20"/>
    below.  The following section will then proceed to discuss how to
    apply them to the problems at hand, discussing annotation of
    existing characters in section <ptr target="#D25-30"/> and finally
    creation of new ones in <ptr target="#D25-40"/>.</p>
   </div2>
   <div2 xml:id="D25-20">
<!--
    <head>Markup constructs for representing non-standard characters</head>
    <p>The gaiji module provides a mechanism to declare characters
    additional to those available from the document character set. XML
    allows for a document (or document component) to declare its
    encoding, thus restricting the characters that can be encoded
    directly within it without using numeric character references. For
    example, an XML document which begins <code>&lt;?xml version="1.0"
    encoding="iso-8859-1"?&gt;</code> can include non-ISO-8859-1
    characters only by representing them as numeric character
    references. In such a case, it might be convenient to declare as
    additional characters some characters already defined by
    the Unicode Standard. Generally speaking, however, the document character set
    will be Unicode, and this mechanism will be needed only for
    characters not defined by the Unicode Standard. </p>
-->
<head>Markup constructs for representation of characters and glyphs</head>
<p>An XML document can, in principle, contain any defined Unicode
character. The standard allows these characters to be represented
either directly, using an appropriate encoding (UTF-8 by defaut), or
indirectly by means of numeric character references (NCR), such as
<code>&amp;#1234;</code> (A-umlaut). The encoder can also restrict the
range of characters which are represented directly in a document (or
part of it) by adding a suitable encoding declaration. For example, if
a document begins with the declaration <code>&lt;?xml
encoding="iso-8859-1"?&gt;</code> any Unicode characters which are not
in the ISO-8859-1 character set must be represented by NCRs. </p>
<p>The gaiji module defined by this chapter adds a further way of
representing specific characters and glyphs in a document. This allows
the encoder to distinguish characters and glyphs which Unicode regards
as identical, to add new nonstandard characters or glyphs, and to
represent Unicode characters not available in the document encoding by
an alternative means.</p>
    <p>The mechanism provided here consists functionally of two parts:
     <list>
      <item>an element <gi>g</gi>, which serves as a proxy for new
       characters or glyphs</item>
      <item>an element <gi>charDesc</gi>, which serves as a container
       for information about this character. Such information is
       needed to identify and process this character
       properly. </item>
     </list>
    </p>
<p>When the gaiji module is included in a schema, the
<gi>charDesc</gi> element is added to the <ident type="class">model.encodingPart</ident>
class, and the <gi>g</gi> element is added to the phrase class. These
elements and their components are documented in the rest of this
section. </p>
<p>The Unicode standard defines properties for all the characters it
defines in the Unicode Character Database, knowledge of which is
usually built into text processing systems.  If the character
represented by the <gi>g</gi> element does not exist in Unicode at
all, its properties are not available. If the character represented is
an existing Unicode character, but is not available in the document
character set recognized by a given text processing system, it may
also be convenient to have access to its properties in the same way.
The <gi>charDesc</gi> element makes it possible to store properties
for use by such applications in a standard way.</p>
<p> The list of attributes (properties) for characters is modelled on
those in the Unicode Character Database, which distinguishes
<term>normative</term> and <term>informative</term> character
properties. Additional, non-Unicode, properties may also be supplied.
Since the list of properties will vary with different versions of
the Unicode Standard, there may not be an exact correspondence between them and the
list of properties defined in these Guidelines.</p>
<p>Usage examples for  these elements are given below at <ptr target="#D25-30"/>
     and  <ptr target="#D25-40"/>.
The gaiji module itself is formally defined in section <ptr target="#WSD-DEF"/> below. It defines the following  additional
     elements:
<specList>
<specDesc key="charDesc"/>
<specDesc key="g" atts="ref"/>
</specList>
</p>
<p>The following elements may appear within a <gi>charDesc</gi>
     element:
<specList>
<specDesc key="desc"/>
<specDesc key="char"/>
<specDesc key="glyph"/>
     </specList>
    </p>
<p>The <gi>char</gi> and <gi>glyph</gi> elements have similar contents
and are used in similar ways, but their functions are different.  The
<gi>char</gi> element is provided to define a character which is not
available in the current document character set, for whatever reason,
as stated above.  The <gi>glyph</gi> element is used to annotate an
existing character, usually by providing a specific glyph that shows
how a character appeared in the original document.  Unicode codepoints
refer to a very general abstract character, which can be rendered by a
very large number of possible representations.  The <gi>glyph</gi>
element is provided for cases where the encoder wants to specify a
specific glyph (or family of glyphs) out of all possible glyphs.</p>
<!--
<p>As noted above, the <att>ucs</att> attribute specifies the Unicode
codepoint corresponding with the character or glyph under
discussion. Its value must match the pattern
<ident>datatype.ucs</ident>, which is also defined by this
module. Values matching this pattern take the form
<code>U+xxxx</code>, where <code>xxxx</code> is the hexadecimal
representation of any valid Unicode code point, including values taken
from the <soCalled>Private Use Area</soCalled> (see further <ptr
target="D25-50"/>).</p>
-->
<p>The Unicode Standard recommends naming conventions which must be followed strictly
where the intention is to annotate an existing Unicode character, and
which should also be used as a model when creating new names for
characters or glyphs. For convenience of processing, the following
distinct elements are proposed for naming characters and glyphs:
<specList>
<specDesc key="charName"/>
<specDesc key="glyphName"/>
</specList></p>
<p>Within both <gi>char</gi> and <gi>glyph</gi>, the following elements are available:
<specList>
<specDesc key="gloss"/>
<specDesc key="charProp"/>
<specDesc key="desc"/>
<specDesc key="mapping"/>
<specDesc key="graphic"/>
<specDesc key="remarks"/>
     </specList>
</p>
<p>Four of these elements (<gi>gloss</gi>, <gi>desc</gi>,
<gi>graphic</gi> and <gi>remarks</gi>) are defined by other TEI
modules, and their usage here is no different from their usage
elsewhere. The <gi>graphic</gi> element, however, is used here only to
link to an image of the character or glyph under discussion, or to
contain a representation of it in SVG. Several <gi>graphic</gi>
elements may be given, for example to provide images with different
resolution, or in different formats. The <att>type</att> attribute may
be used to specify the type of image.</p>
<p>The <gi>mapping</gi> element is similar to the standard TEI
<gi>equiv</gi> element. While the latter is used to express correspondence 
relationships between TEI concepts or elements and those in other
systems or ontologies, the former is used to express any kind of
relationship between the character or glyph under discussion and
characters or glyphs defined elsewhere. It may contain any Unicode
character, or a <gi>g</gi> element linked to some other <gi>char</gi> or
<gi>glyph</gi> element, if, for example, the intention is to express an association
between two non-standard characters. The type of association is
indicated by the <att>type</att> attribute, which may take such values
as <code>exact</code> for exact equivalences, <code>uppercase</code>
for uppercase equivalences, <code>lowercase</code>  for lowercase equivalences,
<code>standardized</code> for standardized forms,  and
<code>simplified</code>  for simplified characters, etc., as in the following example:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><charDesc>
<char xml:id="aenl">
<charName>LATIN LETTER ENLARGED SMALL A</charName>
<charProp>
<localName>entity</localName>
<value>aenl</value>
</charProp>
<mapping type="standardized">a</mapping>
</char>
</charDesc>
</egXML> 
</p>
<p>The mapping element may also be used to represent a mapping of the
character or (more likely) glyph under discussion onto a character
from the private use area as in this example:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><charDesc>
<glyph xml:id="z103">
<glyphName>LATIN LETTER Z WITH TWO STROKES</glyphName>
<mapping type="standardized">Z</mapping>
<mapping type="PUA">U+E304</mapping>
</glyph>
</charDesc>
</egXML> 
</p>
<p>A more precise documentation of the properties of any character or
glyph may be supplied using the generic <gi>charProp</gi> element
described in the next section. Despite its name, this element may be
used for either characters or glyphs.
</p>
<div3 xml:id="ucsprops"><head>Character Properties</head>
<p>The Unicode Standard documents <soCalled>ideal</soCalled> characters, defined by reference
to a number of <term>properties</term> (or attribute-value pairs)
which they are said to possess. For example, a lower case letter is
said to have the value <code>Ll</code> for the property
<code>general-category</code>. The Standard distinguishes between
<term>normative</term> properties (i.e. properties which form part of
the definition of a given character), and <term>informative</term> or
<term>additional</term> properties which are not normative. It
also allows for the addition of new properties, and (in some
circumstances) alteration of the values currently assigned to certain
properties. When making such modifications however, great care should
be taken not to over-ride standard informative properties for
characters which exist in the Unicode Standard.<note place="foot">See further the
Unicode technical report TR23 <ref target="http://www.unicode.org/reports/tr23/"><title>Character Property Model</title></ref></note></p>
<p>The <gi>charProp</gi> element allows an encoder to supply information
about a character or glyph. Where the information concerned relates to
a property which has already been identified in the Unicode Standard, encoders are
urged to use the appropriate Unicode property name. </p>
<p>The following elements are used to record character properties:
<specList>
<specDesc key="unicodeName"/>
<specDesc key="localName"/>
<specDesc key="value"/>
</specList>
For each property, the encoder must supply either a
<gi>unicodeName</gi> or a <gi>localName</gi>, followed by a
<gi>value</gi>. </p>
<p>For convenience, we list here some of the normative character
properties and their values. For full information, refer to chapter 4 of
<title>The Unicode Standard</title>, or the online documentation of the Unicode Character Database.
<list type="gloss">
	 <label>general-category</label> <item>The general
	  category (described in the Unicode Standard chapter 4 section 5) is an assignment to some
	  major classes and subclasses of characters.  Suggested
	  values for this property are listed here:
<list type="gloss">
<label>Ll</label><item>Letter, lowercase</item>
<label>Lu</label><item>Letter, uppercase</item>
<label>Lt</label><item>Letter, titlecase</item>
<label>Lm </label><item>Letter, modifier</item>
<label>Lo</label><item>Letter, other</item>
<label>Mn</label><item>Mark, nonspacing</item>
<label>Mc</label><item>Mark, spacing combining</item>
<label>Me</label><item>Mark, enclosing</item>
<label>Nd</label><item>Number, decimal digit</item>
<label>Nl</label><item>Number, letter</item>
<label>No</label><item>Number, other</item>
<label>Pc</label><item>Punctuation, connector</item>
<label>Pd</label><item>Punctuation, dash</item>
<label>Ps</label><item>Punctuation, open</item>
<label>Pe</label><item>Punctuation, close</item>
<label>Pi</label><item>Punctuation, initial quote</item>
<label>Pf</label><item>Punctuation, final quote</item>
<label>Po</label><item>Punctuation, other</item>
<label>Sm</label><item>Symbol, math</item>
<label>Sc</label><item>Symbol, currency</item>
<label>Sk</label><item>Symbol, modifier</item>
<label>So</label><item>Symbol, other</item>
<label>Zs</label><item>Separator, space</item>
<label>Zl</label><item>Separator, line</item>
<label>Zp</label><item>Separator, paragraph</item>
<label>Cc</label><item>Other, control</item>
<label>Cf</label><item>Other, format</item>
<label>Cs</label><item>Other, surrogate</item>
<label>Co</label><item>Other, private use</item>
<label>Cn</label><item>Other, not assigned</item>
</list>
	 </item>
	 <label>directional-category</label> 
<item>This property applies to all Unicode characters. It governs the
application of the algorithm for bi-directional behaviour, as further
specified in Unicode Annex 9, <title>The Bidirectional
Algorithm</title>. The following 19 different values are currently
defined for this property in the <ref target="http://www.unicode.org/Public/UNIDATA/UCD.html">Unicode Character
Database</ref>:<list type="gloss">
<label>AL</label><item>right to left Arabic</item>
<label>AN</label><item>Arabic Number</item>
<label>B</label><item>Paragraph separator</item>
<label>BN</label><item>Boundary Neutral</item>
<label>CS</label><item>Common Number Separator</item>
<label>EN</label><item>European Number</item>
<label>ES</label><item>European Number Separator</item>
<label>ET</label><item>European Number Terminator</item>
<label>L</label><item>left to right</item>
<label>LRE</label><item>left to right embedding</item>
<label>LRO</label><item>left to right override</item>
<label>NSM</label><item>Non-spacing Mark</item>
<label>ON</label><item>Other neutrals</item>
<label>PDF</label><item>Pop Directional Format</item>
<label>R</label><item>right to left</item>
<label>RLE</label><item>right to left embedding</item>
<label>RLO</label><item>right to left override</item>
<label>S</label><item>Segment separator</item>
<label>WS</label><item>Whitespace</item>
</list></item>
	 <label>canonical-combining-class</label> <item>This
	  property exists for characters that are not used
	  independently, but in combination with other characters, for
	  example the strokes making up CJK characters.  It
	  records a class for these characters, which is used to
	  determine how they interact typographically.  The following
	  values are defined in  the Unicode Standard 4.2:<list type="gloss">
<label>0</label><item>Spacing, split, enclosing, reordrant, and Tibetan subjoined </item>
<label>1</label><item>Overlays and interior </item>
<label>7</label><item>Nuktas </item>
<label>8</label><item>Hiragana/Katakana voicing marks </item>
<label>9</label><item>Viramas </item>
<label>10</label><item>Start of fixed position classes </item>
<label>199</label><item>End of fixed position classes </item>
<label>200</label><item>Below left attached </item>
<label>202</label><item>Below attached </item>
<label>204</label><item>Below right attached </item>
<label>208</label><item>Left attached (reordrant around single base character) </item>
<label>210</label><item>Right attached </item>
<label>212</label><item>Above left attached </item>
<label>214</label><item>Above attached </item>
<label>216</label><item>Above right attached </item>
<label>218</label><item>Below left </item>
<label>220</label><item>Below </item>
<label>222</label><item>Below right </item>
<label>224</label><item>Left (reordrant around single base character) </item>
<label>226</label><item>Right </item>
<label>228</label><item>Above left </item>
<label>230</label><item>Above </item>
<label>232</label><item>Above right </item>
<label>233</label><item>Double below </item>
<label>234</label><item>Double above </item>
<label>240</label><item>Below (iota subscript) </item>
</list>	  </item>
<label>character-decomposition-mapping</label> 
          <item>This property is defined for characters,
	  which may be decomposed, for example to a canonical form
	  plus a typographic variation of some kind. For such characters the Unicode standard  specifies both
	  a decomposition type and a decomposition mapping
	  (i.e. another Unicode character to which this one may be
	  mapped in the way specified by the decomposition type). The
	  following types of mapping are defined in the Unicode Standard:
<list type="gloss">
<label>font</label><item>   A font variant (e.g. a blackletter form)</item>
<label>noBreak</label><item>   A no-break version of a space or hyphen</item>
<label>initial</label><item>   An initial presentation form (Arabic)</item>
<label>medial</label><item>   A medial presentation form (Arabic)</item>
<label>final</label><item>   A final presentation form (Arabic)</item>
<label>isolated</label><item>   An isolated presentation form (Arabic)</item>
<label>circle</label><item>   An encircled form</item>
<label>super</label><item>   A superscript form</item>
<label>sub</label><item>   A subscript form</item>
<label>vertical</label><item>   A vertical layout presentation form</item>
<label>wide</label><item>   A wide (or zenkaku) compatibility character</item>
<label>narrow</label><item>   A narrow (or hankaku) compatibility character</item>
<label>small</label><item>   A small variant form (CNS compatibility)</item>
<label>square</label><item>   A CJK squared font variant</item>
<label>fraction</label><item>   A vulgar fraction form</item>
<label>compat</label><item>   Otherwise unspecified compatibility character</item>
</list>
</item>
	 <label>numeric-value</label> <item>This property applies for
	 any character which expresses any kind of numeric value. Its
	 value is the intended value in decimal notation.</item>
<label>mirrored</label> <item>The mirrored
	 character property is used to properly render characters such
	   as U+0028, <code>OPENING PARENTHESIS</code> independent of
	 the text direction: it has the value <code>Y</code>
(character is mirrored) or <code>N</code> (code is not mirrored).</item>
	</list></p>
<p>the Unicode Standard also defines a set of informative (but non-normative)
properties for Unicode characters.  If encoders want to provide such
properties, they may be included using the suggested Unicode name,
tagged using the <gi>unicodeName</gi> element. However, encoders may
also supply other locally-defined properties, which must be named using
the <gi>localName</gi> element to distinguish them. If a Unicode name
exists for a given property, it should however always be preferred to
a locally defined name. Locally defined names should be used only for   properties
which are not specified by the Unicode Standard.</p>
</div3>
   </div2>
   <div2 xml:id="D25-30">
    <head>Annotating characters</head>
    <p>Annotation of a character becomes necessary when it is desired
    to distinguish it on the basis of certain aspects (typically, its
    graphical appearance) only.  In a manuscript, for example, where
    distinctly different forms of the letter "r" can be recognized, it
    might be useful to distinguish them for analytic purposes, quite
    distinct from the need to provide a accurate representation of the
    page. A digital facsimile, particularly one linked to a
    transcribed and encoded version of the text, will always provide a
    superior visual representation, but cannot be used to support
    arguments based on the distribution of such different
    forms. Character annotation as described here provides a solution
    to this problem.<note place="foot"> It should be kept in mind that
    any kind of text encoding is an abstraction and an interpretation of
    the text at hand, which will not necessarily  be useful in reproducing an exact
    facsimile of the appearance of a manuscript.</note> </p>
<p>Assuming that we wish to distinguish the variant glyphs from the standard representation for the character
concerned, we will need to define distinct <gi>glyph</gi> elements, one for
each of the forms of the letter we wish to distinguish:
     <egXML xmlns="http://www.tei-c.org/ns/Examples"><charDesc>
  <glyph xml:id="r1">
  <glyphName>LATIN SMALL LETTER R WITH ONE FUNNY STROKE</glyphName>
   <charProp>
      <localName>entity</localName>
       <value>r1</value>
   </charProp>
   <graphic url="r1img.png"/>
 </glyph>
  <glyph xml:id="r2">
  <glyphName>LATIN SMALL LETTER R WITH TWO FUNNY STROKES</glyphName>
   <charProp>
      <localName>entity</localName>
       <value>r2</value>
   </charProp>
   <graphic url="r2img.png"/>
 </glyph>
</charDesc> </egXML>
     With these definitions in place, occurrences of these two special
     "r"s in the text can be annotated using the element <gi>g</gi>:
     <egXML xmlns="http://www.tei-c.org/ns/Examples">
    <p>Wo<g ref="#r1">r</g>ds in this 
      manusc<g ref="#r2">r</g>ipt are sometimes
      written in a funny way.</p> </egXML></p>
    <p>
     As can be seen in this example, the <gi>glyph</gi> element pointed
     to from the <gi>g</gi> element will be interpreted as an
     annotation on the content of the element <gi>g</gi>.  This mechanism
     can also be used to indicate ligatures, as in the
     following example:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p> ... <g ref="#Filig">Fi</g>lthy riches...</p>
<!-- in the chardesc -->
  <glyph xml:id="Filig">
   <glyphName>LATIN UPPER F AND LATIN LOWER I LIGATURE</glyphName>  
   <graphic url="Filig.png"/>
 </glyph>
</egXML>
(In fact the Unicode Standard does provide a character to represent the
      <code>Fi</code> ligature; the encoder may however prefer not to
      use it in order to simplify other text processing  operations,
      such as indexing).    </p>
<p>With this
     markup in place, it will be possible to write programs to analyze
     the distribution of the different letters "r" as well as produce
     more <soCalled>faithful</soCalled> renderings of the original. It
     will also be possible to produce normalized versions by simple ignoring
     the annotation pointed to by the element <gi>g</gi>.  <!-- To make
     this kind of processing more efficient, the "type" attribute on
     <gi>g</gi> can be used, with an enumeration of different
     types and their usage documented in the TEIHeader.-->
    </p>
    <p>For brevity of encoding, it may be preferred to pre-define
    internal entities such as the following:
     <egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!ENTITY r1 '<g ref="#r1">r</g>' >
<!ENTITY r2 '<g ref="#r2">r</g>' > ]]></egXML>
which would enable the same material to be encoded as follows:
     <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>Wo&amp;r1;ds in this manusc&amp;r2;ipt are 
      sometimes written in a funny way.</p> </egXML>
    </p>
<p>The same technique may be used to represent particular
abbreviation marks as well as to represent other characters or
glyphs. For example, if we believe that the r-with-one-funny-stroke is
being used as an abbreviation for <code>receipt</code>, this might be
represented as follows:<egXML
xmlns="http://www.tei-c.org/ns/Examples">
 <abbr>&amp;r1;</abbr></egXML></p>
<!-- should become a choice element some time -->
    <p>Note however that this technique employs markup objects to
    provide a link between a character in the document and some
    annotation on that character. It cannot therefore be used in
    places where such markup constructs are not allowed, notably in
    attribute values. 
    </p>   </div2>
   <div2 xml:id="D25-40">
    <head>Adding new characters</head>
    <p>The creation of additional characters for use in text encoding
    is similar to the annotation of an existing character.  The same
    element <gi>g</gi> is used to provide a link from the character
    instance in the text to the character definition in
    <gi>charDesc</gi> element. The main difference is that the
    <gi>g</gi> element now points to a <gi>char</gi> element.  The
    element <gi>g</gi> itself will generally be empty, but could
    contain a codepoint from the Private Use Area (PUA) of the Unicode Standard,
    which is an area set aside for the very purpose of privately
    adding new characters to a document.  Recommendations on how to
    use such PUA characters are given in the following section.  </p>
<p>In some circumstances, it may be desirable to provide a single
precomposed form of a character that is encoded in Unicode only as a
sequence of codepoints. For example, in Medieval
Nordic material, a character looking like a lower case letter Y with a
dot and an acute-accent above it may be encountered so frequently that
the encoder wishes to treat it as a distinct character. In the
transcription concerned, the encoder enters this letter as
<code>&amp;ydotacute;</code>, which  when the
transcription is processed can then be expanded in one of three ways,
depending on the DTD in force. It might simply be translated into the
sequence of corrsponding Unicode codepoints: this has the drawback
that the sequence cannot be treated as a unit of any kind once entity
translation has taken place.  It may be translated directly into a
locally-defined PUA character (say <code>&amp;#xE0A4</code>) for local
processing only; the more
portable representation <egXML xmlns="http://www.tei-c.org/ns/Examples"><g ref="#ydotacute"/></egXML>. In
either case, the following new character definition should be supplied:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><char xml:id="ydotacute">
       <charName>LATIN SMALL LETTER Y WITH DOT ABOVE AND ACUTE</charName>
     <charProp>
       <localName>entity</localName>
       <value>ydotacute</value>
     </charProp>
     <mapping type="composed">&amp;#x0079;&amp;#x0307;&amp;#x0301;</mapping>
     <mapping type="PUA">U+E0A4</mapping>
   </char></egXML>
This definition  specifies the mapping between this composed
character and the individual Unicode-defined characters which make it
up. It also supplies a single locally-defined property (<soCalled>entity</soCalled>)for the
character concerned, the purpose of which is
to supply a recommended character entity name for the character. 
</p>
<p>Under certain circumstances, Han characters can be written
    within a circle.  Rather than considering this as simply an aspect of the
    rendering, an encoder may wish to treat such circled characters as
    entirely distinct  derived characters. For a given character
    (say that represented by the numeric-character reference <code>&amp;#x4EBA;</code>)
    the circled variant might conveniently be represented as
    <egXML xmlns="http://www.tei-c.org/ns/Examples"> <g ref="#U4EBA-circled"/></egXML>, which references a
    definition such as the following:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><char xml:id="U4EBA-circled">
  <charName>CIRCLED IDEOGRAPH</charName>
  <charProp>
    <unicodeName>character-decomposition-mapping</unicodeName>
    <value>circle</value>
  </charProp>
  <charProp>
   <localName>daikanwa</localName>
   <value>36</value>
  </charProp>
  <mapping type="standard">
   &amp;U+4EBA;
  </mapping>
  <mapping type="PUA">
   &amp;U+E000;
  </mapping>
 </char></egXML></p>
<p>In this example, the <soCalled>circled ideograph</soCalled>
character has been defined with two mappings, and with two
properties. The two properties are the Unicode-defined
character-decomposition which specifies that this is a circled
character, using the appropriate terminology (see <ptr target="#ucsprops"/> above) and a locally defined property known as
<soCalled>daikanwa</soCalled> <!-- whatever that means -->. The two
mappings indicate firstly that the standard form of this character is
the character <code>&amp;#x4EBA;</code>, and secondly that the
character used to represent this character locally is the PUA
character  <code>&amp;#xE000;</code>. For convenience of local
processing this PUA character may in fact appear  as content of
the <gi>g</gi> element. In general, however, the <gi>g</gi> element
will be empty.</p>
   </div2>
   <div2 xml:id="D25-50">
    <head>How to use codepoints from the Private Use Area</head>
    <p>The developers of the Unicode Standard have set aside an
    area of the codespace for the private use of software vendors,
    user groups or individuals.  As of this writing (Unicode 4.0),
    there are around 137,000 codepoints available in this area, which
    should be enough for most needs. No codepoint assignments will be made
    to this area by standard bodies and only some very basic default
    properties have been assigned (which may be overwritten where
    necessary by the mechanism outlined in this chapter). Therefore,
    unlike all other codepoints defined by the Unicode Standard, PUA codepoints should
    <emph>not</emph> be used directly in documents intended for blind interchange.
    Instead of using PUA codepoints directly in the document content,
    entity references should be used.  This will make it easier for
    receiving parties to find out what PUA characters are used in a
    document and where possible codepoint clashes with local use on
    the receiving side occurs.</p>
<p>In the two previous examples, we mentioned that the variant
characters concerned might well be assigned specific codepoints from
the PUA. This might, for example, facilitate the use of a particular
font which displays the desired character at this codepoint in the
local processing environment.  Since however this assignment would be
valid only on the local site, documents containing such codepoints are
unsuitable for blind interchange.  During the process of preparing
such documents for interchange, any PUA codepoints must be changed
either to an encoding such as <gi>c ref="#xxxx"</gi> or to an
equivalent character entity reference, thus associating the character
with an explicitly defined <gi>char</gi> element.  The PUA character
used during the preparation of the document might be recorded in the
<gi>char</gi> element, as shown in the example in <ptr target="#D25-40"/>; however there is no requirement that the same PUA
character be used to represent it at the receiving site. Indeed, it
may well be the case that this other site has already made an
assignment of some other character to the original PUA codepoint. For
that reason, it is to be expected that a further translation into the
local processing environment at the receiving site will be necessary
to handle such characters, during which variant letters can be
converted to hitherto unused codepoints on the basis of the
information provided in the <gi>charDesc</gi> element.</p>
    <p>This mechanism is rather weak in cases where DOM trees or
    parsed XML fragments are exchanged, which may increasingly be the
    case.  The best an application can do here is to treat any
    occurrence of a PUA character only in the context of the local
    document and use the properties provided through the <gi>char</gi>
    element as a handle to the character in other contexts.  </p>
<p>In the fullness of time, a character may become standardized, and
thus assigned a specific code point outside the PUA. Documents which
have been encoded using the mechanism must at the least ensure that
this changed code point is recorded within the relevant <gi>char</gi>
element; it will however normally be simpler to remove the
<gi>char</gi> element and replace all occurrences of <gi>g</gi>
elements which reference it by occurrences of the specific coded
character. </p>
   </div2>
<div2 xml:id="WSD-DEF"><head>Additional module defined by this section</head>
<p>The module described in this chapter makes available the following
components:
<moduleSpec xml:id="DWD" ident="gaiji">
<altIdent type="FPI">Character and Glyph Documentation</altIdent><desc>Character and glyph documentation</desc></moduleSpec>

The selection and combination of modules to form a TEI schema is described in
<ptr target="#STIN"/>.
</p>
<p>The module is organized as follows:
<specGrp>
&g.odd;
&char.odd;
&charname.odd;
&charprop.odd;
&chardesc.odd;
&glyph.odd;
&glyphname.odd;
&localname.odd;
&mapping.odd;
&unicodename.odd;
&value.odd;
</specGrp>
    </p></div2>
</div1>

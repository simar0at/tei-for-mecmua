<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<TEI
  xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:svg="http://www.w3.org/2000/svg"
  xmlns:math="http://www.w3.org/1998/Math/MathML"
  xmlns="http://www.tei-c.org/ns/1.0">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>Prefix Definition Proposal</title>
      </titleStmt>
      <publicationStmt>
        <p>Intended only for discussion by TEI Council</p>
      </publicationStmt>
      <sourceDesc>
        <p>Born-digital</p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <body>
      <p>This document contains a draft of a new section for the TEI Guidelines.</p>
      <p>Location for the new section: between the current 16.2.2 (Pointing locally) and 16.2.3 (W3C element() Scheme).</p>
      
      <div type="div3" xml:id="SAPU">
        <head>Using abbreviated pointers</head>
        
        <p><att>xml:base</att> is a useful way of handling the repeated use of long external URIs. However, it is less convenient when your text contain many references to a variety of different sources in different locations. Even in the case of relative links on the local file system, <att>ref</att> or <att>target</att> attributes may become quite lengthy and make XML code difficult to read. To deal with this problem, the TEI provides a useful method of using abbreviated pointers and documenting a way to dereference them automatically.</p>
        
        <p>Imagine a project which has a large collection of XML documents organized like this:</p>
        
        <list>
          <item>anthology
            <list>
              <item>poetry
                <list>
                  <item>poem.xml</item>
                </list>
              </item>
              <item>prose
                <list>
                  <item>novel.xml</item>
                </list>
              </item>
            </list>
          </item>
          <item>references
            <list>
              <item>people
              <list>
                <item>personography.xml</item>
              </list>
              </item>
            </list>
          </item>
        </list>
        
        
        <p>If you want to link a <gi>name</gi> in the novel.xml file to a <gi>person</gi> in the personography.xml file, the link will look like this:
        
        <egXML xmlns="http://www.tei-c.org/ns/Examples">
          <name ref="../../references/people/personography.xml#fred">Fred</name>
        </egXML>
          
          If there are many names to tag in a single paragraph, the XML encoding will be congested, and such lengthy links are prone to typographical error. In addition, if the project organization is changed, every relative link will have to be found and altered.</p>
        
        <p>One way to deal with this is to use what is often referred to as a "magic token". You could make such links using the <att>key</att> attribute:
          <egXML xmlns="http://www.tei-c.org/ns/Examples">
            <name key="fred">Fred</name>
          </egXML>
        
        and document the meaning of the key using (for instance) a <gi>taxonomy</gi> element in the TEI header, as described in <ptr target="#CONARS"/>. However, such a link cannot be mechanically processed by an external system that does not know how to interpret it; a human will have to read the header explanation and write code explicitly to reconstruct the intended link.</p>
        
        <p>A more robust alternative is to use a <term>private URI scheme</term>. This is a method of constructing a simple, key-like token which functions as a <val>data.pointer</val>, and can therefore be used as the value of any attribute which has that datatype, such as <att>ref</att> and <att>target</att>. Such a scheme consists of a prefix with a colon, and then a value. You might, for example, use the prefix <val>psn</val> (for "person"), and structure your name tags like this:
        
          <egXML xmlns="http://www.tei-c.org/ns/Examples">
            <name ref="psn:fred">Fred</name>
          </egXML>
        
        How is this different from a <soCalled>magic token</soCalled>? Essentially, it isn't, except that TEI provides a structured method of dereferencing it (turning it into a computable path, such as <val>../../references/people/personography.xml#fred</val>) by means of a declaration inside <gi>encodingDesc</gi> in the TEI header. This is how you might document a Private URI Scheme using the <val>psn:</val> prefix:
          
          <egXML xmlns="http://www.tei-c.org/ns/Examples">
            <listPrefixDefs>
              <prefixDef ident="psn" matchPattern="([a-z]+)" replacementPattern="../../references/people/personography.xml#$1">
                <p>In the context of this project, private URIs with the prefix "psn" point to <gi>person</gi> elements in the project's personography.xml file.</p>
              </prefixDef>
            </listPrefixDefs>
          </egXML>
          
          This specifies that where a <val>data.pointer</val> value is constructed with a <val>psn:</val> prefix, a regular expression operation can be performed on it to construct the full or relative URI to the target document or fragment. The following elements and attributes are used:
          
          <specList>
            <specDesc key="listPrefixDefs"/>
            <specDesc key="prefixDef"/>
            <specDesc key="att.patternReplacement" atts="ident matchPattern replacementPattern"/>
          </specList>
        
          <gi>listPrefixDefs</gi> is a child of <gi>encodingDesc</gi>, and it contains any number of <gi>prefixDef</gi> elements. Each <gi>prefixDef</gi> element provides a method of dereferencing or expanding an abbreviated pointer, based on a regular expression. The <att>ident</att> attribute specifies the prefix to which the expansion applies (without the colon). The <att>matchPattern</att> attribute contains a regular expression which is matched against the component of the pointer following the first colon, and the <att>replacementPattern</att> provides the string which will be used as a replacement. In this example, using <val>psn:fred</val>, the value <val>fred</val> would be matched by the <att>matchPattern</att>, and also captured (through the parentheses in the regular expression); it would then be replaced by the value <val>../../references/people/personography.xml#fred</val> (with the the <val>$1</val> in the <att>replacementPattern</att> being replaced by the captured value). The <gi>p</gi> element inside the <gi>prefixDef</gi> can be used to provide a human-readable explanation of the usage of this prefix.</p>
        
        <p>Through this mechanism, any processor which encounters a <val>data.pointer</val> with a protocol unknown to it can check the <gi>listPrefixDefs</gi> in the header to see if there is an available expansion for it, and if there is, it can automatically provide the expansion and generate a full or relative URI.</p>
        
        <p>For any given prefix, it may be useful to supply more than one expansion. For instance, in addition to pointing at the <gi>person</gi> element in the personography file, it might also be useful to point to an external source which is available on the network, representing the same information in a different way. So there might be a second <gi>prefixDef</gi> like this:
        
          <egXML xmlns="http://www.tei-c.org/ns/Examples">
              <prefixDef ident="psn" matchPattern="([a-z]+)" replacementPattern="http://www.example.com/personography.html#$1">
                <p>Private URIs with the prefix "psn" can be converted to point to a fragment on the Personography page of the project Website.</p>
              </prefixDef>
          </egXML>
        
        Any number of <gi>prefixDef</gi> elements may be provided for the same prefix. A processor may decide to process one or all of them; if it processes only one, it should choose the first one with the correct <att>ident</att> value, so the primary or most important <gi>prefixDef</gi> for any given prefix should appear first in its parent <gi>listPrefixDefs</gi>.</p>
        
        <p>When creating private URI schemes, it is recommended that you avoid using any existing registered prefix. A list of registered prefixes is maintained by IANA at <ref target="http://www.iana.org/assignments/uri-schemes.html">http://www.iana.org/assignments/uri-schemes.html</ref>.</p>
      
      <p>Note that this mechanism can also be used to dereference other abbreviated pointing systems which are based on prefixes, such as Tag URIs.</p>
      
      </div>
      
      
    </body>
  </text>
</TEI>
<?xml version="1.0" encoding="UTF-8"?>
<div xml:id="tb" xmlns="http://www.tei-c.org/ns/1.0">
    <head>Technical background</head>
    <div xml:id="tbxml">
        <!-- XML: explain a few basics (including namespaces), then refer to gentle XML introduction: 5p -->
        <head>Text Encoding and XML</head>
        <p>Strictly speaking, one doesn't need a markup language to share or even analyze digitized
            text. Computer programs can and have been written to take as input plain text and
            to analyze or transform it in various ways. Suppose, for example, you have the entire
            text of James Joyce's <title>Ulysses</title> stored in an ASCII computer file:</p>
        <quote>
            <p>Stately, plump Buck Mulligan came from the stairhead, bearing a bowl of
                lather on which a mirror and a razor lay crossed. A yellow dressinggown,
                ungirdled, was sustained gently behind him on the mild morning air. He
                held the bowl aloft and intoned:</p>
            <p>—Introibo ad altare Dei.</p>
            <p>[etc.]</p>
        </quote>
        <p>You can do a reasonably good job of breaking the text into its component paragraphs,
            sentences, and words based on line breaks, punctuation, and spacing. So you can produce
            word counts and concordances, calculate the average length of sentences, find
            interesting patterns of word collocation, or even generate a Joyce pastiche by stringing
            together random sentences from the text. But with only the bare text itself as data,
            there are many more things you can't easily do: search for references to people, places,
            or titles; distinguish reliably between primary text and quoted text, or direct and
            indirect speech; search for passages in a particular language, such as Latin; find text
            that is in verse rather than prose; indicate that text is in italics or boldface. For
            these tasks it is necessary to add something to the bare text, to mark it up: hence the
            need for a <soCalled>markup language</soCalled>. Using a markup language you can
            identify "Buck Mulligan" as a personal name, and perhaps associate it with a standard
            identifier. You can indicate that the second paragraph represents a quotation, spoken by
            Buck Mulligan, in the Latin language, quoted from the Tridentine Mass, and
            typographically rendered in italics in the source text.</p>
        <p>Various markup languages have been developed in the past to accomplish this kind of
            identification, but the Text Encoding Initiative and the wider computing world have
            settled on a single standard: XML, the Extensible Markup Language.</p>
        <div xml:id="tbxml.what">
            <head>What Is XML?</head>
            <p>XML is popularly known as an <soCalled>angle-bracket language</soCalled>. If you have
                ever looked at or edited HTML source code, you have worked with a near cousin of
                XML—or with pure XML, if your code was in the HTML version known as XHTML
                (Extensible HyperText Markup Language).</p>
            <p>The most basic fact about XML is that XML is not a single markup standard, but rather
            a specification for creating markup languages, each with its own vocabulary and rules.
            Moreover, XML can be used to encode nearly any sort of material, from poems
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <NurseryRhyme ID="mary_lamb">
                    <title>Mary Had a Little Lamb</title>
                    <stanza>
                        <verse>Mary had a little lamb,</verse>
                        <verse>its fleece was white as snow;</verse>
                        <verse>and everywhere that Mary went</verse>
                        <verse>the lamb was sure to go.</verse>
                    </stanza>
                </NurseryRhyme>
            </egXML>
            to regular <soCalled>data</soCalled> of the sort that could be stored in a formal
                database:
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <place>
                    <name>London</name>
                    <latitude hemisphere="N">51.507778</latitude>
                    <longitude hemisphere="W">0.128056</longitude>
                </place>
            </egXML>
            Nearly anything can be encoded and expressed in XML, within the constraints of its
            syntax. There are XML languages for musical notation [ref
            http://xml.coverpages.org/xmlMusic.html], for mathematical equations (MathML), for
            representing vector graphics (SVG), for library catalog records (MARCXML)
            .&#160;.&#160;. [ref to Wikipedia
            http://en.wikipedia.org/wiki/List_of_XML_markup_languages?]</p>
        </div>
        <div xml:id="tbxml.nutshell">
            <head>XML Syntax in a Nutshell</head>
            <p>The basic grammar of XML is simple enough that it can be expressed in four brief
            rules. (They are oversimplifications, strictly, but the exceptions are not important
            enough to matter at this stage.)</p>
            <list type="ordered">
                <item>An XML file must have a single outermost <term rend="italic">root element</term> that
                contains everything else.
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                    <document>
                        . . . contents . . .
                    </document>
                </egXML>
                </item>
                <item>An XML element must always have a <term rend="italic">start tag</term> and an <term rend="italic">end tag</term>.
                    Both start and end tags are denoted by angle brackets preceding the name of the
                    element; the end tag must have a solidus (/) preceding the name: <eg>&lt;tag&gt; … &lt;/tag&gt;</eg> 
                    The two main things that an element can contain are text and other
                    elements.
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <document>
                            <para>This is a paragraph with text only.</para>
                            <para>This is <emph>another</emph> paragraph with a child element.</para>
                        </document>
                        
                    </egXML>
                </item>
                <item>An XML element may qualified by <term rend="italic">attributes</term>,
                    contained within the start tag. The value of each attribute is contained within
                    quotation marks (single or double):
                    <egXML xmlns="http://www.tei-c.org/ns/Examples"><document type="legal"
                        xml:id="DOC-2008-07-11-0003"> … </document></egXML>
                    Within running text, attributes are referred to by prefixing an at-sign (@) to
                    their name: <att>type</att>, <att>xml:id</att>.
                </item>
                <item>XML elements must be nested; they cannot overlap. This syntax is illegal:
                    <eg><![CDATA[<line><clause>April is the cruelest month</clause>, <clause>breeding</line>
<line>Lilacs out of the dead land</clause>, <clause>mixing</line>
<line>Memory and desire</clause>, <clause>stirring</line>
<line>Dull roots with spring rain</clause>.</line>]]></eg>
                    (The inability to capture "overlapping hierarchies" in this way is a fundamental
                    limitation of XML.)
                </item>
            </list>
            <p>Any XML document that correctly follows these syntax rules is said to be
                <soCalled>well formed</soCalled>. So long as XML is well formed, it can be parsed,
                edited, transformed, or otherwise processed by software tools. (Conversely, an
                ill-formed XML document will usually generate one or more error messages when opened
                by such tools, prompting the user to correct its syntax.)</p>
            <p>Well-formedness by itself is not usually enough to make XML particularly useful to
            humans, however. For example, the following XML document is well-formed:</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <NurseryRhyme>
                    <verse>
                        <stanza>Mary had a little lamb,</stanza>
                        its fleece was white as snow;
                        <stanza>and everywhere that Mary went</stanza>
                        <stanza>the lamb was sure to go.</stanza>
                    </verse>                    
                </NurseryRhyme>
            </egXML>
            <p>This attempts to encode a nursery rhyme, but it is lacking a title and
            switches the <gi>stanza</gi> and <gi>verse</gi> elements—we want the former to contain the
                latter, not vice-versa. And it has a verse line that lacks a tag entirely.</p>
        </div>
        <div xml:id="tbxml.valid">
            <head>Rules for Structuring an XML Vocabulary</head>
            <p>Fortunately, there are several ways of specifying rules for XML that allow one to
                create a structured XML vocabulary—a markup language that uses a defined set of
                elements and attributes that must be arranged in specified ways. When an XML
                document is compared against such a rule set and meets all of its requirements, it
                is said to be <term rend="italic">valid XML</term> (in addition to being well
                formed). Most software that processes XML can check for both well-formedness and
                validity.</p>
            <p>There are two basic technologies for writing XML rule sets: <term>Document Type Definitions</term>
            (DTDs) and <term>XML schemas</term>. DTDs were the earliest (in fact they go back all the way to the
            1970s, when they were used with GML, the Generalized Markup Language, which is more or
            less the grandparent of XML); in loose usage, people sometimes use the term <term
                rend="italic">DTD</term> to mean any rule set associated with an XML language:
                <q>Have you figured out what DTD to use for encoding your recipes?</q>. XML schemas
                were developed in conjunction with XML itself, in the 1990s. Schemas are more
                powerful and more complex; their use in connection with TEI will be discussed below
                in [REFERENCE]. Here we will provide a simple example of how a DTD could be used to
                define the rules of NRML, our Nursery Rhyme Markup Language.</p>
            <p>The rules for NRML are simple: an XML document encodes a single nursery rhyme in a
                root element called <gi>NurseryRhyme</gi>, which must have an identifier
                in an <att>ID</att> attribute. Under the root element there must be a title,
                contained in a <gi>title</gi> element, and one or more
                <gi>stanza</gi> elements; each <gi>stanza</gi> contains one or more verses in a
                <gi>verse</gi> element. A <gi>verse</gi> may contain only text.</p>
            <p>Here is the DTD which specifies those rules:</p>
            <eg><![CDATA[<!ELEMENT NurseryRhyme (title, stanza+)>
<!ATTLIST NurseryRhyme ID CDATA #REQUIRED >
<!ELEMENT title (#PCDATA)>
<!ELEMENT stanza (verse+)>
<!ELEMENT verse (#PCDATA)>]]></eg>
            <p>With the explanation that "CDATA" means "character data" and "#PCDATA" means "parsed
                character data" (text that may contain special constructs handled by the XML parser),
                the syntax of this DTD should be fairly intuitive. The <term rend="italic">content
                model</term> of an element is given in parentheses. Required elements are separated
                by a comma and must appear in the order given. A plus sign means "one or more".</p>
            <p>Once a DTD or schema has been written for a particular XML markup vocabulary, it can
                be applied to an XML file by an <term rend="italic">XML validator</term> to
                determine whether the file is valid or not. (The way this is done for TEI files will
            be discussed below [REF].) </p>
        </div>
        <div xml:id="tbxml.semantics">
            <head>XML Semantics</head>
            <p>If you have followed the discussion of XML well-formedness and validity, it may occur
            to you that nothing in the rules for NRML that we have described prevents someone from
            tagging "Mary Had a Little Lamb" like this:
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <stanza>
                    <verse>Mary had a little</verse>
                    <verse>lamb, its</verse>
                    <verse>fleece was white as</verse>
                    <verse>snow;</verse>
                    <!-- etc. -->
                    <!-- Incidentally, this structure and the previous are 'XML comments':
 they are not part of the formal document content and can be
 placed anywhere within an XML file. -->
                </stanza>
            </egXML>
            This markup is both well-formed and valid; no automated parser will ever complain about
            it. But a human reader is justified in calling it "bad markup", because the encoder has
            not correctly identifed the boundaries of metrical verses. From a human point of view,
            the most important rule governing the <gi>verse</gi> element is that it should encode a
                single line of verse. The <emph>semantics</emph> of <gi>verse</gi> cannot be
                expressed in XML or an XML technology; they depend on the conventions of poetics. If
            one is writing a guide to the NRML language, it is not enough to assume the basic syntax
            of XML and to present the rule set (DTD or schema) governing its structure: the
            appropriate use of the <gi>verse</gi> tag must be explained in terms of the rules for
            recognizing poetic verse.</p>
            <p>The same thing is true on a much larger scale with the TEI Guidelines. The TEI
                vocabulary extends to hundreds of elements, and the rules governing which elements
                may appear where are quite complex. But the largest part of the Guidelines consists
                of explanation, illustrated by examples, of which TEI elements should be used to
                encode various features of texts and their associated metadata. Often one needs to
                be an expert in a particular subject—bibliography, linguistics, manuscript
                editing—in order to use TEI encoding in a way that is meaningful as well as
                technically valid.</p>
        </div>
        <div xml:id="tbxml.namespaces">
            <head>Namespaces: Avoiding XML Vocabulary Collisions</head>
            <p>As the use of XML expanded and many different XML markup languages emerged, people
                realized that it would often be useful to permit one XML vocabulary to incorporate
                another one. For example, there is a formal XML language, MathML, that can be used
                to encode mathematical equations. If one were using TEI to encode the correspondence
                of a mathematician, rather than trying to extend the TEI tagset to include equations
                it would be much simpler to use MathML directly within one's TEI document.</p>
            <p>The first problem that arises when attempting to integrate differing XML languages is
                differentiating among the vocabularies, and in particular, avoiding name collisions.
                For example, suppose that we are encoding in TEI XML a scholarly work that has
                footnotes, which are tagged using <gi>note</gi>. And suppose that one footnote contains
                the opening bars of the song "Twinkle Twinkle Little Star". Let's say there is a
                widely used simple XML language called TuneML for encoding musical passages that
                also uses a <gi>note</gi> element, and we want to use it in our footnote. We might
                end up with something like this:
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                    <note type="footnote" n="1">In the margin, the author has inscribed the opening
                        bars of <title>Twinkle, Twinkle, Little Star</title>:
                        <tune clef="G"><note>C</note><note>C</note><note>G</note><note>G</note></tune>
                    [etc.].
                    </note>
                </egXML>
                We have an obvious problem. It's impossible to distinguish between the elements from
            TEI and from TuneML, and the <gi>note</gi> element is therefore used for two entirely
            different purposes.</p>
            <p>The solution adopted to resolve this problem was <term rend="italic">XML
            Namespaces</term>, a way of identifying the elements of a single XML
                vocabulary so that they occupy their own unique <soCalled>name space</soCalled>.
                Namespaces are optional in XML; an XML document does not have to use them. None of
                the preceding examples of XML do, so they would be said to be in "no namespace".
                Namespaces give great flexibility and power to XML, but unfortunately they are one
                of the more confusing parts of XML for beginners.</p>
            <p>A namespace is distinguished within an XML document using a unique identifier. And
                here is where the first confusion arises: namespace values share the same legal
                syntax as the Uniform Resource Identifiers (URI) used in the World Wide Web, and
                by convention they begin with <hi rend="code">http://</hi>. But a namespace
                identifier is <emph>not</emph> the name of a Web page, for all that it looks like
                one. For example, the namespace identifier of the TEI language is <hi
                    rend="italic">http://www.tei-c.org/ns/1.0</hi>. If you go to the Web address
                <ref target="http://www.tei-c.org/ns/1.0"
                    type="url">http://www.tei-c.org/ns/1.0</ref>, you will in fact find a short
                paragraph about the TEI namespace, but that is an optional courtesy on the part of
                the TEI. On the other hand, one of the namespaces used in Microsoft's XML format for
                its Office software is <hi
                    rend="italic">http://schemas.microsoft.com/office/word/2006/wordml</hi>, but
                there is nothing at the Web page <ref type="url"
                    target="http://schemas.microsoft.com/office/word/2006/wordml">http://schemas.microsoft.com/office/word/2006/wordml</ref>.</p>
            <p>A namespace must be <emph>declared</emph> in an XML document to take effect. It
                applies to the node it is declared in, and to all nodes below that unless they are
                declared to be in a different namespace. Thus, every TEI document begins
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <TEI xmlns="http://www.tei-c.org/ns/1.0">
                    ... content of TEI file
                </TEI>
            </egXML>
            where <code>xmlns=</code> can be read as <q>the XML Namespace is...</q>.</p>
            <p>Let's return to our hypothetical footnote above about <title>Twinkle, Twinkle Little
            Star</title>. Suppose we know that the namespace of the TuneML language is
                <code>http://tuneml.org/schema/2009</code>. We could then rewrite our XML footnote
                like so:
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                    <note xmlns="http://www.tei-c.org/ns/1.0" type="footnote" n="1">In the margin,
                        the author has inscribed the opening
                        bars of <title>Twinkle, Twinkle, Little Star</title>:
                        <tune clef="G" xmlns="http://tuneml.org/schema/2009"><note>C</note><note>C</note><note>G</note><note>G</note></tune>
                        [etc.].</note>
                </egXML>
                Now we genuine have two different <gi>note</gi> elements. The first one is declared
                to be in the TEI namespace. The others, describing musical notes, inherit the TuneML
                namespace that is declared on their parent element <gi>tune</gi>.
            </p>
            <div xml:id="namespace.prefixes">
                <head>Namespace Prefixes</head>
                <p>If you have followed the preceding description of namespaces and their
                    identifiers, it may occur to you that they are useful to computers but not very
                    friendly to human readers and editors of XML documents. If you are looking at XML
                nodes deep within a file using multiple namespaces, how can you easily figure out
                which namespace is in control of the current node? And isn't it cumbersome to attach
                long namespace identifers every time you refer to a namespace in a file?</p>
               <p>The solution adopted in the XML world is <term>namespace prefixes</term>. When
                   declaring a namespace, you may optionally associate it with a prefix. Then for
                   the current XML node and any nodes below it, adding the prefix to an element name
               is the same as declaring its full identifier. The simplest strategy is to declare all
               namespaces with prefixes at the top of the document (i.e., on the root element):</p>
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                    <TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:tn="http://tuneml.org/schema/2009">
                        <!-- lots of content, then: -->
                        <note type="footnote" n="1">In the margin,
                          the author has inscribed the opening
                          bars of <title>Twinkle, Twinkle, Little Star</title>: 
                          <tn:tune
                              clef="G"><tn:note>C</tn:note><tn:note>C</tn:note><tn:note>G</tn:note><tn:note>G</tn:note></tn:tune>
                        [etc.].</note>
                    </TEI>
                </egXML>
                <p>Compare this example with the preceding one. Note that the TEI namespace is
                    declared on the root element <gi>TEI</gi>, so it does not have to be repeated in
                descendant nodes; the footnote <gi>note</gi> inherits the TEI namespace. Also in the
                root element, the TuneML namespace is declared and associated with the prefix
                    <code>tn</code>. Thus, within the file when elements from the TuneML language
                    are used, they can simply be named with their prefix: <gi>tn:tune</gi>,
                    <gi>tn:note</gi>. When using prefixes in this way, you must prefix <emph>every
                    element you use</emph>, as there is no namespace inheritance—that is why
                    every TuneML note is written as <gi>tn:note</gi>. But most people find XML
                    documents with multiple namespaces more comprehensible when prefixes are used.</p>
            </div>
        </div>
        <div xml:id="tbxml.further">
            <head>Further Reading</head>
            <p>to come</p>
        </div>
    </div>
    <div xml:id="tbweb">
        <head>XML on the Web</head>
        <p>The <soCalled>angle-bracket language</soCalled> that people are most familiar with is
            HTML, the Hypertext Markup Language that has powered the World Wide Web (WWW) since 1991. Its
            earliest format (still used today) was based not on XML but on the ancestor of XML, the
            Standard Generalized Markup Language or SGML. But since 2000 it has also existed as a
            pure XML language known as XHTML, which obeys all of the rules of syntax outlined above.
        For the purposes of this section, we are going to ignore the older format and use
            <term>HTML</term> to mean the XML form of the language.</p>
        <div xml:id="client-server">
            <head>Web Servers, Web Clients</head>
            <p>The WWW is based on a client-server model. That is, a Web <term>server</term> on the
                Internet hosts content and delivers it over the network to <term>clients</term>—to
                individual computers, intelligent phones, or other network appliances.
                Oversimplifying some (but not much), every Web page view is the successful result of
                the delivery and interpretation of an HTML file with a structure like this:</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">]]>
                <html xmlns="http://www.w3.org/1999/xhtml">
                    <head>
                        <title>A Web Page</title>
                    </head>
                    <body>
                        <h1>A Sample Web Page</h1>
                        <p>This is a <em>minimal</em> HTML Web page.</p>
                    </body>
                </html>
            </egXML>
            <p>Chances are you're familiar with the syntax. Information about the document
                (<term>metadata</term>) goes inside the <gi>head</gi>, while the <gi>body</gi>
                contains the document text (plus references to graphics, multimedia, programs, etc.,
            that display within the page). Heading levels are designated by <gi>h1</gi>,
                <gi>h2</gi>, etc., paragraphs by <gi>p</gi>, emphasized text by <gi>em</gi>, and so
                on.</p>
            <p>The Web began its meteoric rise once people started writing client software that
                could interpret and display the HTML language in a standard way: the <term>Web
                browser</term>, or just <soCalled>browser</soCalled> for short. From Mosaic
                through Netscape to MS Internet Explorer, Firefox, Safari, and all the other
                contemporary ones, a browser has had the function of interpreting HTML code (and
                bits of programming languages and other data embedded with it) and
                <emph>displaying</emph> it to a user in a standard way. So, by convention, the
                <gi>title</gi> of an HTML file is shown at the very top of the browser window; an
                <gi>h1</gi> head is usually in boldface type much larger than the regular text font;
            text inside an <gi>i</gi> tag is of course rendered in <hi rend="italics">italics</hi>,
                and so on. The existence of a fairly limited set of uniform tags meant that Web
                designers could predict with some reliability how their HTML documents would appear
                at the recipients' end.</p>
            <figure>
                <graphic url="images/tb-webpage1.png"/>
                <head>Typical browser view of sample HTML</head>
            </figure>
        </div>
        <div xml:id="styling">
            <head>Styling the Web</head>
            <p>A piece of technology that has given the Web much of its presentational flexibility
                is Cascading Style Sheets, or CSS. As CSS is an indispensable tool for most projects
                using the TEI to present material on the Web, it is worth a brief detour here.</p>
            <p>CSS is a <term>style sheet language</term> that can be used to precisely define the
                appearance of XML documents (not just HTML ones, note!) on screen, in print, or even
            for audio or Braille devices. It allows Web designers to go well beyond the default
            renderings given to HTML elements by Web browsers. Consider the sample HTML file given
            above. Typically, a browser will render the <gi>h1</gi> in boldface font at around
                150–200% of the body font size, and will render the <gi>em</gi> as italics. But
                suppose I want my headings to be at 130%, in small capitals, colored green; and I
                want my emphasized text to be bold and red, not italicized. I can accomplish this by
            adding a <gi>style</gi> element to my HTML <gi>head</gi>, containing the relevant CSS
            instructions:</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <style type="text/css">
                    h1 { font-size:130%; font-variant:small-caps; color:green; }
                    em { font-weight:bold; color:red; font-variant:normal; }
                </style>
            </egXML>
            <figure>
                <graphic url="images/tb-webpage2.png"/>
                <head>Typical browser view of sample HTML with CSS styling</head>
            </figure>
        </div>
        <div>
            <head>Limitations of HTML</head>
            <p>In its origins, HTML was designed for the sharing of technical documents and other
                information generating by researchers. It has been expanded greatly since the
                beginning, but its legacy explains two key features of HTML: (1) a relatively
                impoverished semantic vocabulary for describing text structures, and (2) an emphasis
            on appearance over structure. Together with CSS, it has an extraordinarily rich array of
            mechanisms for sizing, coloring, and positioning text and graphics, but it has no native
            way of distinguishing between, for example, prose and poetry. Most of its structural or
            semantic tags describe features typical of technical documentation or memo-like prose
            (<gi>table</gi>, <gi>ol</gi> [ordered list], <gi>dl</gi> [definition list]), or exist
            to enable hyperlinking, form submission, etc. (<gi>a</gi>,
                <gi>form</gi>/<gi>input</gi>). It is a superb vehicle for <emph>presenting</emph>
                text, graphics, and multimedia, but an inadequate one for <emph>representing</emph>
                the underlying structure and meaning of the universe of human textual production.</p>
        </div>
        <div>
            <head>So... Why not Just Put XML on the Web?</head>
            <p>Let's return to our invented Nursery Rhyme Markup Language. Suppose I have used NMRL
            to mark up hundreds of nursery rhymes; can I just copy my files to the Web? Let's recall
            what an NRML file looks like; let's call it <hi rend="italic">MaryLamb.xml</hi>:
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <NurseryRhyme ID="mary_lamb">
                    <title>Mary Had a Little Lamb</title>
                    <stanza>
                        <verse><name>Mary</name> had a little lamb,</verse>
                        <verse>its fleece was white as snow;</verse>
                        <verse>and everywhere that <name>Mary</name> went</verse>
                        <verse>the lamb was sure to go.</verse>
                    </stanza>
                </NurseryRhyme>
            </egXML>
             (we've added a new <gi>name</gi> element for reasons that will be apparent below).</p> 
            <p>The answer is <q>yes and no</q>. I can certainly copy <hi
                rend="italic">MaryLamb.xml</hi> to a directory on a Web server, and invite people to
                look at it. But what they will see will be something like this:
            <figure>
                <graphic url="images/tb-webpage3.png"/>
                <head>MaryLamb.xml viewed in Firefox</head>
            </figure>
            This is a <soCalled>raw XML</soCalled> view of the file. Web browsers know how to
                display HTML because it has a known set of tags and styling commands. But without
                some hints, they cannot make any assumptions about how an unknown XML language
                should be displayed.</p>
        </div>
        <div>
            <head>CSS to the Rescue?</head>
            <p>CSS can define the appearance of <emph>any</emph> XML elements, not just ones from
                the HTML vocabulary. So it is entirely possible to take a newly invented XML
                language like our NRML and use CSS to display it on the Web. We do this by putting
                our CSS instructions into a separate file, and then referencing the CSS file from
                our XML file using an XML <term>processing instruction</term>. Let's say we create a
            file <hi rend="italic">NRML.css</hi> with the following contents:</p>
            <eg>NurseryRhyme { display:block; margin:1cm; font-size: 14pt; font-family: "Bookman Old Style"}
                
title        { display:block; font-size:larger; font-weight:bold; margin-bottom:1em;}

stanza       { display:block; margin-bottom:1em;}
                
verse        { display:block; line-height: 1.3;}
                
name         { display:inline; font-variant:small-caps; }</eg>
            <p>We then add the following code to the top of <hi
                rend="italic">MaryLamb.xml</hi>:
                <eg><![CDATA[<?xml-stylesheet href="NRML.css" type="text/css"?>]]></eg>
                The result, viewed in a modern Web brower, looks like this:</p>
            <figure>
                <graphic url="images/tb-webpage4.png"/>
                <head>MaryLamb.xml plus CSS, viewed in Firefox</head>
            </figure>
        </div>
    </div>
    <div xml:id="tbgen">
        <head>Transforming XML</head>
        <p>Even gentler intro into creating html from xml using xslt (mention but not discuss: pdf
            creation and other output formats): 5 p's</p>
    </div>
</div>

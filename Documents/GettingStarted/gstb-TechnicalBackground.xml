<?xml version="1.0" encoding="UTF-8"?>
<div xml:id="tb" xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <head>Technical background</head>
    <div xml:id="tbxml">
        <!-- XML: explain a few basics (including namespaces), then refer to gentle XML introduction: 5p -->
        <head>Text Encoding and XML</head>
        <p>Strictly speaking, one doesn't need a markup language to share or even analyze digitized
            text. Computer programs can and have been written to take as input plain text and
            to analyze or transform it in various ways. Suppose, for example, you have the entire
            text of James Joyce's <title>Ulysses</title> stored in an ASCII computer file:</p>
        <quote>
            <p>Stately, plump Buck Mulligan came from the stairhead, bearing a bowl of
                lather on which a mirror and a razor lay crossed. A yellow dressinggown,
                ungirdled, was sustained gently behind him on the mild morning air. He
                held the bowl aloft and intoned:</p>
            <p>—Introibo ad altare Dei.</p>
            <p>[etc.]</p>
        </quote>
        <p>You can do a reasonably good job of breaking the text into its component paragraphs,
            sentences, and words based on line breaks, punctuation, and spacing. So you can produce
            word counts and concordances, calculate the average length of sentences, find
            interesting patterns of word collocation, or even generate a Joyce pastiche by stringing
            together random sentences from the text. But with only the bare text itself as data,
            there are many more things you can't easily do: search for references to people, places,
            or titles; distinguish reliably between primary text and quoted text, or direct and
            indirect speech; search for passages in a particular language, such as Latin; find text
            that is in verse rather than prose; indicate that text is in italics or boldface. For
            these tasks it is necessary to add something to the bare text, to mark it up: hence the
            need for a <soCalled>markup language</soCalled>. Using a markup language you can
            identify "Buck Mulligan" as a personal name, and perhaps associate it with a standard
            identifier. You can indicate that the second paragraph represents a quotation, spoken by
            Buck Mulligan, in the Latin language, quoted from the Tridentine Mass, and
            typographically rendered in italics in the source text.</p>
        <p>Various markup languages have been developed in the past to accomplish this kind of
            identification, but the Text Encoding Initiative and the wider computing world have
            settled on a single standard: XML, the Extensible Markup Language.</p>
        <div xml:id="tbxml.what">
            <head>What Is XML?</head>
            <p>XML is popularly known as an <soCalled>angle-bracket language</soCalled>. If you have
                ever looked at or edited HTML source code, you have worked with a near cousin of
                XML—or with pure XML, if your code was in the HTML version known as XHTML
                (Extensible HyperText Markup Language).</p>
            <p>The most basic fact about XML is that XML is not a single markup standard, but rather
            a specification for creating markup languages, each with its own vocabulary and rules.
            Moreover, XML can be used to encode nearly any sort of material, from poems
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <NurseryRhyme ID="mary_lamb">
                    <title>Mary Had a Little Lamb</title>
                    <stanza>
                        <verse>Mary had a little lamb,</verse>
                        <verse>its fleece was white as snow;</verse>
                        <verse>and everywhere that Mary went</verse>
                        <verse>the lamb was sure to go.</verse>
                    </stanza>
                </NurseryRhyme>
            </egXML>
            to regular <soCalled>data</soCalled> of the sort that could be stored in a formal
                database:
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <place>
                    <name>London</name>
                    <latitude hemisphere="N">51.507778</latitude>
                    <longitude hemisphere="W">0.128056</longitude>
                </place>
            </egXML>
            Nearly anything can be encoded and expressed in XML, within the constraints of its
            syntax. There are XML languages for musical notation [ref
            http://xml.coverpages.org/xmlMusic.html], for mathematical equations (MathML), for
            representing vector graphics (SVG), for library catalog records (MARCXML)
            .&#160;.&#160;. [ref to Wikipedia
            http://en.wikipedia.org/wiki/List_of_XML_markup_languages?]</p>
        </div>
        <div xml:id="tbxml.nutshell">
            <head>XML Syntax in a Nutshell</head>
            <p>The basic grammar of XML is simple enough that it can be expressed in four brief
            rules. (They are oversimplifications, strictly, but the exceptions are not important
            enough to matter at this stage.)</p>
            <list type="ordered">
                <item>An XML file must have a single outermost <term rend="italic">root element</term> that
                contains everything else.
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                    <document>
                        . . . contents . . .
                    </document>
                </egXML>
                </item>
                <item>An XML element must always have a <term rend="italic">start tag</term> and an <term rend="italic">end tag</term>.
                    Both start and end tags are denoted by angle brackets preceding the name of the
                    element; the end tag must have a solidus (/) preceding the name: <eg>&lt;tag&gt; … &lt;/tag&gt;</eg> 
                    The two main things that an element can contain are text and other
                    elements.
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <document>
                            <para>This is a paragraph with text only.</para>
                            <para>This is <emph>another</emph> paragraph with a child element.</para>
                        </document>
                        
                    </egXML>
                </item>
                <item>An XML element may qualified by <term rend="italic">attributes</term>,
                    contained within the start tag. The value of each attribute is contained within
                    quotation marks (single or double):
                    <egXML xmlns="http://www.tei-c.org/ns/Examples"><document type="legal"
                        xml:id="DOC-2008-07-11-0003"> … </document></egXML>
                    Within running text, attributes are referred to by prefixing an at-sign (@) to
                    their name: <att>type</att>, <att>xml:id</att>.
                </item>
                <item>XML elements must be nested; they cannot overlap. This syntax is illegal:
                    <eg><![CDATA[<line><clause>April is the cruelest month</clause>, <clause>breeding</line>
<line>Lilacs out of the dead land</clause>, <clause>mixing</line>
<line>Memory and desire</clause>, <clause>stirring</line>
<line>Dull roots with spring rain</clause>.</line>]]></eg>
                    (The inability to capture "overlapping hierarchies" in this way is a fundamental
                    limitation of XML.)
                </item>
            </list>
            <p>Any XML document that correctly follows these syntax rules is said to be
                <soCalled>well formed</soCalled>. So long as XML is well formed, it can be parsed,
                edited, transformed, or otherwise processed by software tools. (Conversely, an
                ill-formed XML document will usually generate one or more error messages when opened
                by such tools, prompting the user to correct its syntax.)</p>
            <p>Well-formedness by itself is not usually enough to make XML particularly useful to
            humans, however. For example, the following XML document is well-formed:</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <NurseryRhyme>
                    <verse>
                        <stanza>Mary had a little lamb,</stanza>
                        its fleece was white as snow;
                        <stanza>and everywhere that Mary went</stanza>
                        <stanza>the lamb was sure to go.</stanza>
                    </verse>                    
                </NurseryRhyme>
            </egXML>
            <p>This attempts to encode a nursery rhyme, but it is lacking a title and
            switches the <gi>stanza</gi> and <gi>verse</gi> elements—we want the former to contain the
                latter, not vice-versa. And it has a verse line that lacks a tag entirely.</p>
        </div>
        <div xml:id="tbxml.valid">
            <head>Rules for Structuring an XML Vocabulary</head>
            <p>Fortunately, there are several ways of specifying rules for XML that allow one to
                create a structured XML vocabulary—a markup language that uses a defined set of
                elements and attributes that must be arranged in specified ways. When an XML
                document is compared against such a rule set and meets all of its requirements, it
                is said to be <term rend="italic">valid XML</term> (in addition to being well
                formed). Most software that processes XML can check for both well-formedness and
                validity.</p>
            <p>There are two basic technologies for writing XML rule sets: <term>Document Type Definitions</term>
            (DTDs) and <term>XML schemas</term>. DTDs were the earliest (in fact they go back all the way to the
            1970s, when they were used with GML, the Generalized Markup Language, which is more or
            less the grandparent of XML); in loose usage, people sometimes use the term <term
                rend="italic">DTD</term> to mean any rule set associated with an XML language:
                <q>Have you figured out what DTD to use for encoding your recipes?</q>. XML schemas
                were developed in conjunction with XML itself, in the 1990s. Schemas are more
                powerful and more complex; their use in connection with TEI will be discussed below
                in [REFERENCE]. Here we will provide a simple example of how a DTD could be used to
                define the rules of NRML, our Nursery Rhyme Markup Language.</p>
            <p>The rules for NRML are simple: an XML document encodes a single nursery rhyme in a
                root element called <gi>NurseryRhyme</gi>, which must have an identifier
                in an <att>ID</att> attribute. Under the root element there must be a title,
                contained in a <gi>title</gi> element, and one or more
                <gi>stanza</gi> elements; each <gi>stanza</gi> contains one or more verses in a
                <gi>verse</gi> element. A <gi>verse</gi> may contain only text.</p>
            <p>Here is the DTD which specifies those rules:</p>
            <eg><![CDATA[<!ELEMENT NurseryRhyme (title, stanza+)>
<!ATTLIST NurseryRhyme ID CDATA #REQUIRED >
<!ELEMENT title (#PCDATA)>
<!ELEMENT stanza (verse+)>
<!ELEMENT verse (#PCDATA)>]]></eg>
            <p>With the explanation that "CDATA" means "character data" and "#PCDATA" means "parsed
                character data" (text that may contain special constructs handled by the XML parser),
                the syntax of this DTD should be fairly intuitive. The <term rend="italic">content
                model</term> of an element is given in parentheses. Required elements are separated
                by a comma and must appear in the order given. A plus sign means "one or more".</p>
            <p>Once a DTD or schema has been written for a particular XML markup vocabulary, it can
                be applied to an XML file by an <term rend="italic">XML validator</term> to
                determine whether the file is valid or not. (The way this is done for TEI files will
            be discussed below [REF].) </p>
        </div>
        <div xml:id="tbxml.semantics">
            <head>XML Semantics</head>
            <p>If you have followed the discussion of XML well-formedness and validity, it may occur
            to you that nothing in the rules for NRML that we have described prevents someone from
            tagging "Mary Had a Little Lamb" like this:
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <stanza>
                    <verse>Mary had a little</verse>
                    <verse>lamb, its</verse>
                    <verse>fleece was white as</verse>
                    <verse>snow;</verse>
                    <!-- etc. -->
                    <!-- Incidentally, this structure and the previous are 'XML comments':
 they are not part of the formal document content and can be
 placed anywhere within an XML file. -->
                </stanza>
            </egXML>
            This markup is both well-formed and valid; no automated parser will ever complain about
            it. But a human reader is justified in calling it "bad markup", because the encoder has
            not correctly identifed the boundaries of metrical verses. From a human point of view,
            the most important rule governing the <gi>verse</gi> element is that it should encode a
                single line of verse. The <emph>semantics</emph> of <gi>verse</gi> cannot be
                expressed in XML or an XML technology; they depend on the conventions of poetics. If
            one is writing a guide to the NRML language, it is not enough to assume the basic syntax
            of XML and to present the rule set (DTD or schema) governing its structure: the
            appropriate use of the <gi>verse</gi> tag must be explained in terms of the rules for
            recognizing poetic verse.</p>
            <p>The same thing is true on a much larger scale with the TEI Guidelines. The TEI
                vocabulary extends to hundreds of elements, and the rules governing which elements
                may appear where are quite complex. But the largest part of the Guidelines consists
                of explanation, illustrated by examples, of which TEI elements should be used to
                encode various features of texts and their associated metadata. Often one needs to
                be an expert in a particular subject—bibliography, linguistics, manuscript
                editing—in order to use TEI encoding in a way that is meaningful as well as
                technically valid.</p>
        </div>
        <div xml:id="tbxml.namespaces">
            <head>Namespaces: Avoiding XML Vocabulary Collisions</head>
            <p>As the use of XML expanded and many different XML markup languages emerged, people
                realized that it would often be useful to permit one XML vocabulary to incorporate
                another one. For example, there is a formal XML language, MathML, that can be used
                to encode mathematical equations. If one were using TEI to encode the correspondence
                of a mathematician, rather than trying to extend the TEI tagset to include equations
                it would be much simpler to use MathML directly within one's TEI document.</p>
            <p>The first problem that arises when attempting to integrate differing XML languages is
                differentiating among the vocabularies, and in particular, avoiding name collisions.
                For example, suppose that we are encoding in TEI XML a scholarly work that has
                footnotes, which are tagged using <gi>note</gi>. And suppose that one footnote contains
                the opening bars of the song "Twinkle Twinkle Little Star". Let's say there is a
                widely used simple XML language called TuneML for encoding musical passages that
                also uses a <gi>note</gi> element, and we want to use it in our footnote. We might
                end up with something like this:
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                    <note type="footnote" n="1">In the margin, the author has inscribed the opening
                        bars of <title>Twinkle, Twinkle, Little Star</title>:
                        <tune clef="G"><note>C</note><note>C</note><note>G</note><note>G</note></tune>
                    [etc.].
                    </note>
                </egXML>
                We have an obvious problem. It's impossible to distinguish between the elements from
            TEI and from TuneML, and the <gi>note</gi> element is therefore used for two entirely
            different purposes.</p>
            <p>The solution adopted to resolve this problem was <term rend="italic">XML
            Namespaces</term>, a way of identifying the elements of a single XML
                vocabulary so that they occupy their own unique <soCalled>name space</soCalled>.
                Namespaces are optional in XML; an XML document does not have to use them. None of
                the preceding examples of XML do, so they would be said to be in "no namespace".
                Namespaces give great flexibility and power to XML, but unfortunately they are one
                of the more confusing parts of XML for beginners.</p>
            <p>A namespace is distinguished within an XML document using a unique identifier. And
                here is where the first confusion arises: namespace values share the same legal
                syntax as the Uniform Resource Identifiers (URI) used in the World Wide Web, and
                by convention they begin with <hi rend="code">http://</hi>. But a namespace
                identifier is <emph>not</emph> the name of a Web page, for all that it looks like
                one. For example, the namespace identifier of the TEI language is <hi
                    rend="italic">http://www.tei-c.org/ns/1.0</hi>. If you go to the Web address
                <ref target="http://www.tei-c.org/ns/1.0"
                    type="url">http://www.tei-c.org/ns/1.0</ref>, you will in fact find a short
                paragraph about the TEI namespace, but that is an optional courtesy on the part of
                the TEI. On the other hand, one of the namespaces used in Microsoft's XML format for
                its Office software is <hi
                    rend="italic">http://schemas.microsoft.com/office/word/2006/wordml</hi>, but
                there is nothing at the Web page <ref type="url"
                    target="http://schemas.microsoft.com/office/word/2006/wordml">http://schemas.microsoft.com/office/word/2006/wordml</ref>.</p>
            <p>A namespace must be <emph>declared</emph> in an XML document to take effect. It
                applies to the node it is declared in, and to all nodes below that unless they are
                declared to be in a different namespace. Thus, every TEI document begins
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <TEI xmlns="http://www.tei-c.org/ns/1.0">
                    ... content of TEI file
                </TEI>
            </egXML>
            where <code>xmlns=</code> can be read as <q>the XML Namespace is...</q>.</p>
            <p>Let's return to our hypothetical footnote above about <title>Twinkle, Twinkle Little
            Star</title>. Suppose we know that the namespace of the TuneML language is
                <code>http://tuneml.org/schema/2009</code>. We could then rewrite our XML footnote
                like so:
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                    <note xmlns="http://www.tei-c.org/ns/1.0" type="footnote" n="1">In the margin,
                        the author has inscribed the opening
                        bars of <title>Twinkle, Twinkle, Little Star</title>:
                        <tune clef="G" xmlns="http://tuneml.org/schema/2009"><note>C</note><note>C</note><note>G</note><note>G</note></tune>
                        [etc.].</note>
                </egXML>
                Now we genuine have two different <gi>note</gi> elements. The first one is declared
                to be in the TEI namespace. The others, describing musical notes, inherit the TuneML
                namespace that is declared on their parent element <gi>tune</gi>.
            </p>
            <div xml:id="namespace.prefixes">
                <head>Namespace Prefixes</head>
                <p>If you have followed the preceding description of namespaces and their
                    identifiers, it may occur to you that they are useful to computers but not very
                    friendly to human readers and editors of XML documents. If you are looking at XML
                nodes deep within a file using multiple namespaces, how can you easily figure out
                which namespace is in control of the current node? And isn't it cumbersome to attach
                long namespace identifers every time you refer to a namespace in a file?</p>
               <p>The solution adopted in the XML world is <term>namespace prefixes</term>. When
                   declaring a namespace, you may optionally associate it with a prefix. Then for
                   the current XML node and any nodes below it, adding the prefix to an element name
               is the same as declaring its full identifier. The simplest strategy is to declare all
               namespaces with prefixes at the top of the document (i.e., on the root element):</p>
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                    <TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:tn="http://tuneml.org/schema/2009">
                        <!-- lots of content, then: -->
                        <note type="footnote" n="1">In the margin,
                          the author has inscribed the opening
                          bars of <title>Twinkle, Twinkle, Little Star</title>: 
                          <tn:tune
                              clef="G"><tn:note>C</tn:note><tn:note>C</tn:note><tn:note>G</tn:note><tn:note>G</tn:note></tn:tune>
                        [etc.].</note>
                    </TEI>
                </egXML>
                <p>Compare this example with the preceding one. Note that the TEI namespace is
                    declared on the root element <gi>TEI</gi>, so it does not have to be repeated in
                descendant nodes; the footnote <gi>note</gi> inherits the TEI namespace. Also in the
                root element, the TuneML namespace is declared and associated with the prefix
                    <code>tn</code>. Thus, within the file when elements from the TuneML language
                    are used, they can simply be named with their prefix: <gi>tn:tune</gi>,
                    <gi>tn:note</gi>. When using prefixes in this way, you must prefix <emph>every
                    element you use</emph>, as there is no namespace inheritance—that is why
                    every TuneML note is written as <gi>tn:note</gi>. But most people find XML
                    documents with multiple namespaces more comprehensible when prefixes are used.</p>
            </div>
        </div>
        <div xml:id="tbxml.further">
            <head>Further Reading</head>
            <p>to come</p>
        </div>
    </div>
    <div xml:id="tbweb">
        <head>XML on the Web</head>
        <p>The <soCalled>angle-bracket language</soCalled> that people are most familiar with is
            HTML, the Hypertext Markup Language that has powered the World Wide Web (WWW) since 1991. Its
            earliest format (still used today) was based not on XML but on the ancestor of XML, the
            Standard Generalized Markup Language or SGML. But since 2000 it has also existed as a
            pure XML language known as XHTML, which obeys all of the rules of syntax outlined above.
        For the purposes of this section, we are going to ignore the older format and use
            <term>HTML</term> to mean the XML form of the language.</p>
        <div xml:id="client-server">
            <head>Web Servers, Web Clients</head>
            <p>The WWW is based on a client-server model. That is, a Web <term>server</term> on the
                Internet hosts content and delivers it over the network to <term>clients</term>—to
                individual computers, intelligent phones, or other network appliances.
                Oversimplifying some (but not much), every Web page view is the successful result of
                the delivery and interpretation of an HTML file with a structure like this:</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">]]>
                <html xmlns="http://www.w3.org/1999/xhtml">
                    <head>
                        <title>A Web Page</title>
                    </head>
                    <body>
                        <h1>A Sample Web Page</h1>
                        <p>This is a <em>minimal</em> HTML Web page.</p>
                    </body>
                </html>
            </egXML>
            <p>Chances are you're familiar with the syntax. Information about the document
                (<term>metadata</term>) goes inside the <gi>head</gi>, while the <gi>body</gi>
                contains the document text (plus references to graphics, multimedia, programs, etc.,
            that display within the page). Heading levels are designated by <gi>h1</gi>,
                <gi>h2</gi>, etc., paragraphs by <gi>p</gi>, emphasized text by <gi>em</gi>, and so
                on.</p>
            <p>The Web began its meteoric rise once people started writing client software that
                could interpret and display the HTML language in a standard way: the <term>Web
                browser</term>, or just <soCalled>browser</soCalled> for short. From Mosaic
                through Netscape to MS Internet Explorer, Firefox, Safari, and all the other
                contemporary ones, a browser has had the function of interpreting HTML code (and
                bits of programming languages and other data embedded with it) and
                <emph>displaying</emph> it to a user in a standard way. So, by convention, the
                <gi>title</gi> of an HTML file is shown at the very top of the browser window; an
                <gi>h1</gi> head is usually in boldface type much larger than the regular text font;
            text inside an <gi>i</gi> tag is of course rendered in <hi rend="italics">italics</hi>,
                and so on. The existence of a fairly limited set of uniform tags meant that Web
                designers could predict with some reliability how their HTML documents would appear
                at the recipients' end.</p>
            <figure>
                <graphic url="images/tb-webpage1.png"/>
                <head>Typical browser view of sample HTML</head>
            </figure>
        </div>
        <div xml:id="styling">
            <head>Styling the Web</head>
            <p>A piece of technology that has given the Web much of its presentational flexibility
                is Cascading Style Sheets, or CSS. As CSS is an indispensable tool for most projects
                using the TEI to present material on the Web, it is worth a brief detour here.</p>
            <p>CSS is a <term>style sheet language</term> that can be used to precisely define the
                appearance of XML documents (not just HTML ones, note!) on screen, in print, or even
            for audio or Braille devices. It allows Web designers to go well beyond the default
            renderings given to HTML elements by Web browsers. Consider the sample HTML file given
            above. Typically, a browser will render the <gi>h1</gi> in boldface font at around
                150–200% of the body font size, and will render the <gi>em</gi> as italics. But
                suppose I want my headings to be at 130%, in small capitals, colored green; and I
                want my emphasized text to be bold and red, not italicized. I can accomplish this by
            adding a <gi>style</gi> element to my HTML <gi>head</gi>, containing the relevant CSS
            instructions:</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <style type="text/css">
                    h1 { font-size:130%; font-variant:small-caps; color:green; }
                    em { font-weight:bold; color:red; font-variant:normal; }
                </style>
            </egXML>
            <figure>
                <graphic url="images/tb-webpage2.png"/>
                <head>Typical browser view of sample HTML with CSS styling</head>
            </figure>
        </div>
        <div>
            <head>Limitations of HTML</head>
            <p>In its origins, HTML was designed for the sharing of technical documents and other
                information generating by researchers. It has been expanded greatly since the
                beginning, but its legacy explains two key features of HTML: (1) a relatively
                impoverished semantic vocabulary for describing text structures, and (2) an emphasis
            on appearance over structure. Together with CSS, it has an extraordinarily rich array of
            mechanisms for sizing, coloring, and positioning text and graphics, but it has no native
            way of distinguishing between, for example, prose and poetry. Most of its structural or
            semantic tags describe features typical of technical documentation or memo-like prose
            (<gi>table</gi>, <gi>ol</gi> [ordered list], <gi>dl</gi> [definition list]), or exist
            to enable hyperlinking, form submission, etc. (<gi>a</gi>,
                <gi>form</gi>/<gi>input</gi>). It is a superb vehicle for <emph>presenting</emph>
                text, graphics, and multimedia, but an inadequate one for <emph>representing</emph>
                the underlying structure and meaning of the universe of human textual production.</p>
        </div>
        <div>
            <head>So... Why not Just Put XML on the Web?</head>
            <p>Let's return to our invented Nursery Rhyme Markup Language. Suppose I have used NMRL
            to mark up hundreds of nursery rhymes; can I just copy my files to the Web? Let's recall
            what an NRML file looks like; let's call it <hi rend="italic">MaryLamb.xml</hi>:
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <NurseryRhyme ID="mary_lamb">
                    <title>Mary Had a Little Lamb</title>
                    <stanza>
                        <verse><name>Mary</name> had a little lamb,</verse>
                        <verse>its fleece was white as snow;</verse>
                        <verse>and everywhere that <name>Mary</name> went</verse>
                        <verse>the lamb was sure to go.</verse>
                    </stanza>
                </NurseryRhyme>
            </egXML>
             (we've added a new <gi>name</gi> element for reasons that will be apparent below).</p> 
            <p>The answer is <q>yes and no</q>. I can certainly copy <hi
                rend="italic">MaryLamb.xml</hi> to a directory on a Web server, and invite people to
                look at it. But what they will see will be something like this:
            <figure>
                <graphic url="images/tb-webpage3.png"/>
                <head>MaryLamb.xml viewed in Firefox</head>
            </figure>
            This is a <soCalled>raw XML</soCalled> view of the file. Web browsers know how to
                display HTML because it has a known set of tags and styling commands. But without
                some hints, they cannot make any assumptions about how an unknown XML language
                should be displayed.</p>
        </div>
        <div>
            <head>CSS to the Rescue?</head>
            <p>CSS can define the appearance of <emph>any</emph> XML elements, not just ones from
                the HTML vocabulary. So it is entirely possible to take a newly invented XML
                language like our NRML and use CSS to display it on the Web. We do this by putting
                our CSS instructions into a separate file, and then referencing the CSS file from
                our XML file using an XML <term>processing instruction</term>. Let's say we create a
            file <hi rend="italic">NRML.css</hi> with the following contents:
            <eg>NurseryRhyme { display:block; margin:1cm; font-size: 14pt; font-family: "Bookman Old Style"}
                
title        { display:block; font-size:larger; font-weight:bold; margin-bottom:1em;}

stanza       { display:block; margin-bottom:1em;}
                
verse        { display:block; line-height: 1.3;}
                
name         { display:inline; font-variant:small-caps; }</eg>
            The CSS <code>display</code> instruction tells the browser whether each element is to
            be displayed as a <emph>block</emph> (separated from surrounding elements, like a 
                paragraph) or <emph>inline</emph> (part of the surrounding flow of text). We have
                defined margins plus a font size and style for the whole <gi>NurseryRhyme</gi> element, and added
                various spacing and typographic styling to the other elements.</p>  
            <p>With our CSS file done, we add the following code to the top of <hi
                rend="italic">MaryLamb.xml</hi>:
                <eg><![CDATA[<?xml-stylesheet href="NRML.css" type="text/css"?>]]></eg>
                The result, viewed in a modern Web brower, looks like this:</p>
            <figure>
                <graphic url="images/tb-webpage4.png"/>
                <head>MaryLamb.xml plus CSS, viewed in Firefox</head>
            </figure>
            <p>So is this all we need to do to publish XML documents, whether in TEI or any other XML
                language, on the Web? The answer is again <q>yes and no</q>. Yes, this is an
                effective simple way of displaying formatted XML; but no, it is not a flexible
                enough solution to handle several important needs when publishing on the Web:</p>
            <list type="bulleted">
                <item>CSS instructions merely tell a Web browser how to display an XML file; CSS
                    cannot add substantive content to the file. HTML files, for example, often
                    include important <term>metadata</term> via <gi>meta</gi> tags in the
                    <gi>head</gi>, which
                    convey information about the file's character encoding, language, authorship,
                    copyright status, and more. CSS cannot add <gi>meta</gi> tags.</item>
                <item>The version of CSS supported by most Web browsers can only tell browser how to
                    display XML elements in the order they are encountered. It cannot reorder,
                    transform, or apply special logic to the underlying data.</item>
            </list>
            <p>For example, suppose we want to publish our XML version of <title>Mary Had a Little
            Lamb</title> with the following enhancements:
            <list type="ordered">
                <item>each verse line is preceded by its line number in brackets</item>
                <item>every second line is indented</item>
                <item>the ID value of the document (<gi>NurseryRhyme</gi>/<att>ID</att>) is given in
                a footnote line following the verse</item>
                <item>An HTML <gi>meta</gi> tag is added to provide the keyword "nursery rhyme" to
                    be picked up by Web indexers like Google</item>
            </list>
            All this can be done, but not by the CSS language. Instead, we must use a more powerful
            general-purpose programming language that can operate on XML data. Fortunately, there
            are well-established tools for this purpose, and they are usually indispensable for any
            project with a body of TEI-encoded texts that they want to share on the Web. The
            following section looks at one of the most commonly used transformation tools.</p>

        </div>
    </div>
    <div xml:id="tbgen">
        <head>Transforming XML</head>
        <p>The XML language was formally proposed by the World Wide Web Consortium (W3C) in 1998. As
        the language was being developed, it was recognized that for XML to be useful there would
        have to be programming tools available to query, transform, and render XML in various ways,
        whether for Web publishing or for other purposes. Concurrently, therefore, a working group
        developed specifications for an <term>extensible stylesheet language</term>: a kind of
            programming language that could be applied to XML documents to extract data, transform
            on type of XML file into another, generate text output, or produce a print-ready
            document in an entirely different typesetting language such as LaTeX or PostScript. The
            result, formalized during 1999–2001, was XSL, the eXtensible Stylesheet Language. XSL is
        the umbrella term for three specific language that do the actual work of transformation:</p>
        <list type="gloss">
            <label>XPath</label>
            <item>The XML Path language, or XPath, provides a way to identify and retrieve specific
                parts of an XML document. For example, using our nursery rhyme example, the
                <gi>verse</gi> element reading <q>its fleece was white as snow</q> can be extracted
                with the following XPath instruction: <code>//stanza[1]/verse[2]</code>. Or we can
                return every verse containing the word <emph>Mary</emph> with the XPath
                <code>//verse[contains(., "Mary")]</code>.</item>
            <label>XSLT</label>
            <item>XSLT (which stands for <q>Extensible Stylesheet Language Transformations</q>,
                though the full name is rarely used) is the workhorse of XML programming languages.
                It is designed to take as input one or more XML documents, and to enable a wide
                variety of operations on them in order to transform their contents in virtually any
                way. XSLT is commonly used to transform content from one XML language to
                another—for example, from TEI to HTML—or to add or subtract features within a
                particular XML language. For example, we could use XSLT to add internal line numbers
                to our NRML verse elements: <egXML xmlns="http://www.tei-c.org/ns/Examples"><verse
                    n="2">its fleece was white as snow;</verse></egXML>
                    XSLT can also transform XML to plain text. XSLT contains many of the structures
                    of other general-purpose programming languages: variables, flow control, if-then
            logic, and (via XPath, which it incorporates) many functions that operate on strings and
            numeric values.</item>
            <label>XSL-FO</label>
            <item>XSL-FO stands for <q>XSL Formatting Objects</q>. It is a stylesheet language
                designed specifically to apply document formatting to XML files primarily for paged
                output, such as book publication. It is commonly used to convert an XML file into
                PDF that can be displayed or printed.</item>
        </list>
        <p>The most common application of XSL in the TEI world is probably the use of XSLT to transform TEI
            documents for display on the Web. In the remainder of this section, we will give a
            realistic example of how XSLT can be used with our nursery rhyme to achieve the exact
            Web publication format we want.</p>
    </div>
    <div xml:id="mary-xslt">
        <head>XSLT: A Practical Example</head>
        <p>For reference, here is our nursery rhyme XML:</p>
        <egXML xmlns="http://www.tei-c.org/ns/Examples">
            <NurseryRhyme ID="mary_lamb">
                <title>Mary Had a Little Lamb</title>
                <stanza>
                    <verse>Mary had a little lamb,</verse>
                    <verse>its fleece was white as snow;</verse>
                    <verse>and everywhere that Mary went</verse>
                    <verse>the lamb was sure to go.</verse>
                </stanza>
            </NurseryRhyme>
        </egXML>
        <p>We want to publish it on the Web with the formatting we used in the CSS output example
            above, but we also want to (1) number verse lines, (2) indent every other line, (3)
            show the document ID in a footnote line, and (4) add a <gi>meta</gi> tag with the
            keyword "nursery rhyme". To accomplish this, we are going to write a
            short XSLT program that takes <hi rend="italic">MaryLamb.xml</hi> as input, and
            produces as output a single HTML file that contains all the content and style
            instructions needed. The result will look like this:</p>
        <figure>
            <graphic url="images/tb-webpage5.png"/>
            <head>MaryLamb.xml as transformed by XSLT, viewed in Firefox</head>
        </figure>
        <p>The XSLT used to produce our new HTML file follows. Viewing XSLT for the first time can
            be intimidating, as it is a relatively verbose language. Here are a few preliminary
            comments and things to notice in the code:</p>
        <list type="bulleted">
            <item>XSLT is itself written as an XML document. All of its basic instructions take the
                form of XML elements with the namespace prefix <code>xsl</code>. For example, where
                another programming language might create a variable called <q>lineNo</q> with an
                assignment like <code>let $lineNo := number(line)</code>, in XSLT you would create
                the variable with an XML element:
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <xsl:variable name="lineNo">
                    <xsl:number/>
                </xsl:variable>
            </egXML>
            </item>
            <item>The root element of every XSLT program is an <gi>xsl:stylesheet</gi> element. It
                declares namespaces and sets other options. An <gi>xsl:output</gi> element can be
                used to specify output in XML, HTML, XHTML (as below), or text.</item>
            <item>The first workhorse of XSLT is the <term>template</term>, expressed in a
                <gi>xsl:template</gi> element. For transforming XML, templates are typically created
            for all or most distinct elements in the input document. They provide the rules for
            transforming each kind of element into something else. The real strength of XSLT is that
            it applies templates <emph>recursively</emph>, meaning that it can descend into your XML
            document and transform all its nested elements without your having to write any special
            program logic.</item>
            <item>The other workhorse of XSLT is the fact that you can create XML output simply by
                inserting an XML element in your program. If you look through the
                <gi>xsl:template</gi> sections below, you will see that in each case it is followed
                by a construct in HTML. For example, the first template matches the NRML root
                element <gi>NurseryRhyme</gi>, and it immediately contstructs an HTML document
                template using <gi>html</gi>, <gi>head</gi>, <gi>body</gi>, and so on.</item>
        </list>
        <p>Look over the script, and by comparing it with the input nursery rhyme and your knowledge
        of HTML elemements, try to get a general sense of what it is doing. You'll find the template
        for <gi>verse</gi> is the most complicated. After the script we'll present a bit of
            explication of what is going on in the templates.</p>
        <egXML xmlns="http://www.tei-c.org/ns/Examples">
<![CDATA[<?xml version="1.0" encoding="UTF-8"?>]]>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">
  <!-- NRML-to-HTML.xsl: transform Nursery Rhyme Markup Language into HTML -->
  <xsl:output method="xhtml"/>
  <xsl:template match="NurseryRhyme">
    <html>
      <head>
        <title>
          <xsl:value-of select="title"/>
        </title>
        <style type="text/css">
          body       { margin:1cm; font-size: 14pt; font-family: "Bookman Old Style"}
          h1         { font-size:larger; font-weight:bold; margin-bottom:1em;}
          div.id     { color: blue; font-family: sans-serif; font-size: 80%; margin-top: 2em;} 
          div.stanza { margin-bottom:1em; line-height: 1.3}
          p.verse    { margin: 0;}
          p.verseI   { margin: 0; text-indent: 1.5em;}
          span.name  { font-variant: small-caps; }
        </style>
        <meta content="nursery rhyme"/>
      </head>
      <body>
        <h1><xsl:apply-templates select="title"/></h1>
        <xsl:apply-templates select="stanza"/>
        <div class="id">[Document ID: <b><xsl:value-of select="@ID"/></b>]</div>
      </body>
    </html>
  </xsl:template>
  <xsl:template match="stanza">
    <div class="stanza">
      <xsl:apply-templates/>
    </div>
  </xsl:template>
  <xsl:template match="verse">
    <xsl:variable name="lineNo">
      <xsl:number level="any"/>
    </xsl:variable>
    <p>
      <xsl:attribute name="class">
        <xsl:choose>
          <xsl:when test="$lineNo mod 2 eq 0">verseI</xsl:when>
          <xsl:otherwise>verse</xsl:otherwise>
        </xsl:choose>
      </xsl:attribute>
      <xsl:value-of select="concat('[', $lineNo, '] ')"/>
      <xsl:apply-templates/>
    </p>    
  </xsl:template>
  <xsl:template match="name">
    <span class="name"><xsl:apply-templates/></span>
  </xsl:template>
</xsl:stylesheet>
        </egXML>
        <p>You should be able to see that for nearly every element in NRML, there is an
            <gi>xsl:template</gi> section in our XSLT program. For example, when the program
            encounters an NRML <gi>name</gi>, this is what it does:
        <egXML xmlns="http://www.tei-c.org/ns/Examples">
            <xsl:template match="name">
                <span class="name"><xsl:apply-templates/></span>
            </xsl:template>
        </egXML>
        It outputs an HTML <gi>span</gi> element with <att>class</att> set to <code>"name"</code>
            (so that CSS will format it appropriately). Then it <emph>applies templates</emph> using
            the <gi>xsl:apply-templates</gi> element. <gi>xsl:apply-templates</gi> is the heart of
            XSLT recursion. Essentially, it says this:
        <list type="bulleted">
            <item>examine the contents of the current element (here, <gi>name</gi>)</item>
            <item>if the element has children (child nodes) for which there are template rules
            elsewhere in the XSLT file, apply those rules</item>
            <item>if we encounter children for which there are no template rules, apply the <term>default
                template</term>: output the textual content.</item>
        </list>
            Thus when our XSLT script encounters <egXML
                xmlns="http://www.tei-c.org/ns/Examples"><name>Mary</name></egXML>, it will output
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><span class="name">Mary</span></egXML>
            following the template rule for "name".
        </p>
        <p>The template for <gi>verse</gi> provides an example of the power of XSLT. It sets a
            variable <code>lineNo</code>, which is simply the ordinal number of the current
            <gi>verse</gi> within the poem. It does this by calling on a built-in XSLT operation,
            the <gi>xsl:number</gi> element, which alows for highly flexible numbering. It then uses
        the <code>$lineNo</code> variable ('$' is the sign for <q>variable</q>) within a numeric
            function that tests whether the current verse is even or odd (<code>$lineNo mod 2 eq
            0</code>) in order to assign the appropriate <att>class</att> attribute to the HTML
            <gi>p</gi> that controls whether or not the line is indented. <code>$lineNo</code> is
            also used to add the line number within [&#160;] preceding each verse.</p>
        <p>XSLT is a powerful and complex language, and like any full-featured programming language
            it requires considerable learning time to reach productivity. But once learned, XSLT can
        be an extraordinarly productive tool for manipulating any text encoded as XML. For instance,
        it took the author of this section about half an hour to write the 50-line XSLT program
        above. Once written, it can transform any number of nursery rhymes encoded in NRML. Compare
        that against the labor it would take to convert, say, 1000 NRML files to HTML by hand!</p>
    </div>
</div>
